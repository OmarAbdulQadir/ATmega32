
APP_31_FreeRTOS-test0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003b54  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001e  00800060  00003b54  00003be8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002b9  0080007e  0080007e  00003c06  2**0
                  ALLOC
  3 .stab         00006a2c  00000000  00000000  00003c08  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00005264  00000000  00000000  0000a634  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 16 08 	jmp	0x102c	; 0x102c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e5       	ldi	r30, 0x54	; 84
      68:	fb e3       	ldi	r31, 0x3B	; 59
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 37       	cpi	r26, 0x7E	; 126
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	ae e7       	ldi	r26, 0x7E	; 126
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 33       	cpi	r26, 0x37	; 55
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 a8 1d 	jmp	0x3b50	; 0x3b50 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	ff cf       	rjmp	.-2      	; 0x9a <main+0x8>

0000009c <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
      9c:	df 93       	push	r29
      9e:	cf 93       	push	r28
      a0:	00 d0       	rcall	.+0      	; 0xa2 <xEventGroupCreate+0x6>
      a2:	cd b7       	in	r28, 0x3d	; 61
      a4:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
      a6:	8b e0       	ldi	r24, 0x0B	; 11
      a8:	90 e0       	ldi	r25, 0x00	; 0
      aa:	0e 94 93 03 	call	0x726	; 0x726 <pvPortMalloc>
      ae:	9a 83       	std	Y+2, r25	; 0x02
      b0:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
      b2:	89 81       	ldd	r24, Y+1	; 0x01
      b4:	9a 81       	ldd	r25, Y+2	; 0x02
      b6:	00 97       	sbiw	r24, 0x00	; 0
      b8:	49 f0       	breq	.+18     	; 0xcc <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
      ba:	e9 81       	ldd	r30, Y+1	; 0x01
      bc:	fa 81       	ldd	r31, Y+2	; 0x02
      be:	11 82       	std	Z+1, r1	; 0x01
      c0:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
      c2:	89 81       	ldd	r24, Y+1	; 0x01
      c4:	9a 81       	ldd	r25, Y+2	; 0x02
      c6:	02 96       	adiw	r24, 0x02	; 2
      c8:	0e 94 0f 04 	call	0x81e	; 0x81e <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
      cc:	89 81       	ldd	r24, Y+1	; 0x01
      ce:	9a 81       	ldd	r25, Y+2	; 0x02
	}
      d0:	0f 90       	pop	r0
      d2:	0f 90       	pop	r0
      d4:	cf 91       	pop	r28
      d6:	df 91       	pop	r29
      d8:	08 95       	ret

000000da <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
      da:	df 93       	push	r29
      dc:	cf 93       	push	r28
      de:	cd b7       	in	r28, 0x3d	; 61
      e0:	de b7       	in	r29, 0x3e	; 62
      e2:	60 97       	sbiw	r28, 0x10	; 16
      e4:	0f b6       	in	r0, 0x3f	; 63
      e6:	f8 94       	cli
      e8:	de bf       	out	0x3e, r29	; 62
      ea:	0f be       	out	0x3f, r0	; 63
      ec:	cd bf       	out	0x3d, r28	; 61
      ee:	9a 87       	std	Y+10, r25	; 0x0a
      f0:	89 87       	std	Y+9, r24	; 0x09
      f2:	7c 87       	std	Y+12, r23	; 0x0c
      f4:	6b 87       	std	Y+11, r22	; 0x0b
      f6:	5e 87       	std	Y+14, r21	; 0x0e
      f8:	4d 87       	std	Y+13, r20	; 0x0d
      fa:	38 8b       	std	Y+16, r19	; 0x10
      fc:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
      fe:	89 85       	ldd	r24, Y+9	; 0x09
     100:	9a 85       	ldd	r25, Y+10	; 0x0a
     102:	9c 83       	std	Y+4, r25	; 0x04
     104:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     106:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     108:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     10c:	eb 81       	ldd	r30, Y+3	; 0x03
     10e:	fc 81       	ldd	r31, Y+4	; 0x04
     110:	80 81       	ld	r24, Z
     112:	91 81       	ldd	r25, Z+1	; 0x01
     114:	98 87       	std	Y+8, r25	; 0x08
     116:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     118:	89 85       	ldd	r24, Y+9	; 0x09
     11a:	9a 85       	ldd	r25, Y+10	; 0x0a
     11c:	2b 85       	ldd	r18, Y+11	; 0x0b
     11e:	3c 85       	ldd	r19, Y+12	; 0x0c
     120:	b9 01       	movw	r22, r18
     122:	0e 94 44 02 	call	0x488	; 0x488 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     126:	2f 81       	ldd	r18, Y+7	; 0x07
     128:	38 85       	ldd	r19, Y+8	; 0x08
     12a:	8b 85       	ldd	r24, Y+11	; 0x0b
     12c:	9c 85       	ldd	r25, Y+12	; 0x0c
     12e:	28 2b       	or	r18, r24
     130:	39 2b       	or	r19, r25
     132:	8d 85       	ldd	r24, Y+13	; 0x0d
     134:	9e 85       	ldd	r25, Y+14	; 0x0e
     136:	28 23       	and	r18, r24
     138:	39 23       	and	r19, r25
     13a:	8d 85       	ldd	r24, Y+13	; 0x0d
     13c:	9e 85       	ldd	r25, Y+14	; 0x0e
     13e:	28 17       	cp	r18, r24
     140:	39 07       	cpc	r19, r25
     142:	c9 f4       	brne	.+50     	; 0x176 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     144:	2f 81       	ldd	r18, Y+7	; 0x07
     146:	38 85       	ldd	r19, Y+8	; 0x08
     148:	8b 85       	ldd	r24, Y+11	; 0x0b
     14a:	9c 85       	ldd	r25, Y+12	; 0x0c
     14c:	82 2b       	or	r24, r18
     14e:	93 2b       	or	r25, r19
     150:	9e 83       	std	Y+6, r25	; 0x06
     152:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     154:	eb 81       	ldd	r30, Y+3	; 0x03
     156:	fc 81       	ldd	r31, Y+4	; 0x04
     158:	20 81       	ld	r18, Z
     15a:	31 81       	ldd	r19, Z+1	; 0x01
     15c:	8d 85       	ldd	r24, Y+13	; 0x0d
     15e:	9e 85       	ldd	r25, Y+14	; 0x0e
     160:	80 95       	com	r24
     162:	90 95       	com	r25
     164:	82 23       	and	r24, r18
     166:	93 23       	and	r25, r19
     168:	eb 81       	ldd	r30, Y+3	; 0x03
     16a:	fc 81       	ldd	r31, Y+4	; 0x04
     16c:	91 83       	std	Z+1, r25	; 0x01
     16e:	80 83       	st	Z, r24

			xTicksToWait = 0;
     170:	18 8a       	std	Y+16, r1	; 0x10
     172:	1f 86       	std	Y+15, r1	; 0x0f
     174:	1e c0       	rjmp	.+60     	; 0x1b2 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     176:	8f 85       	ldd	r24, Y+15	; 0x0f
     178:	98 89       	ldd	r25, Y+16	; 0x10
     17a:	00 97       	sbiw	r24, 0x00	; 0
     17c:	91 f0       	breq	.+36     	; 0x1a2 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     17e:	8b 81       	ldd	r24, Y+3	; 0x03
     180:	9c 81       	ldd	r25, Y+4	; 0x04
     182:	bc 01       	movw	r22, r24
     184:	6e 5f       	subi	r22, 0xFE	; 254
     186:	7f 4f       	sbci	r23, 0xFF	; 255
     188:	8d 85       	ldd	r24, Y+13	; 0x0d
     18a:	9e 85       	ldd	r25, Y+14	; 0x0e
     18c:	9c 01       	movw	r18, r24
     18e:	35 60       	ori	r19, 0x05	; 5
     190:	4f 85       	ldd	r20, Y+15	; 0x0f
     192:	58 89       	ldd	r21, Y+16	; 0x10
     194:	cb 01       	movw	r24, r22
     196:	b9 01       	movw	r22, r18
     198:	0e 94 9b 14 	call	0x2936	; 0x2936 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     19c:	1e 82       	std	Y+6, r1	; 0x06
     19e:	1d 82       	std	Y+5, r1	; 0x05
     1a0:	08 c0       	rjmp	.+16     	; 0x1b2 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     1a2:	eb 81       	ldd	r30, Y+3	; 0x03
     1a4:	fc 81       	ldd	r31, Y+4	; 0x04
     1a6:	80 81       	ld	r24, Z
     1a8:	91 81       	ldd	r25, Z+1	; 0x01
     1aa:	9e 83       	std	Y+6, r25	; 0x06
     1ac:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     1ae:	81 e0       	ldi	r24, 0x01	; 1
     1b0:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     1b2:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
     1b6:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     1b8:	8f 85       	ldd	r24, Y+15	; 0x0f
     1ba:	98 89       	ldd	r25, Y+16	; 0x10
     1bc:	00 97       	sbiw	r24, 0x00	; 0
     1be:	09 f4       	brne	.+2      	; 0x1c2 <xEventGroupSync+0xe8>
     1c0:	3a c0       	rjmp	.+116    	; 0x236 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     1c2:	8a 81       	ldd	r24, Y+2	; 0x02
     1c4:	88 23       	and	r24, r24
     1c6:	11 f4       	brne	.+4      	; 0x1cc <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     1c8:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     1cc:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <uxTaskResetEventItemValue>
     1d0:	9e 83       	std	Y+6, r25	; 0x06
     1d2:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     1d4:	8d 81       	ldd	r24, Y+5	; 0x05
     1d6:	9e 81       	ldd	r25, Y+6	; 0x06
     1d8:	80 70       	andi	r24, 0x00	; 0
     1da:	92 70       	andi	r25, 0x02	; 2
     1dc:	00 97       	sbiw	r24, 0x00	; 0
     1de:	31 f5       	brne	.+76     	; 0x22c <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     1e0:	0f b6       	in	r0, 0x3f	; 63
     1e2:	f8 94       	cli
     1e4:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     1e6:	eb 81       	ldd	r30, Y+3	; 0x03
     1e8:	fc 81       	ldd	r31, Y+4	; 0x04
     1ea:	80 81       	ld	r24, Z
     1ec:	91 81       	ldd	r25, Z+1	; 0x01
     1ee:	9e 83       	std	Y+6, r25	; 0x06
     1f0:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     1f2:	2d 81       	ldd	r18, Y+5	; 0x05
     1f4:	3e 81       	ldd	r19, Y+6	; 0x06
     1f6:	8d 85       	ldd	r24, Y+13	; 0x0d
     1f8:	9e 85       	ldd	r25, Y+14	; 0x0e
     1fa:	28 23       	and	r18, r24
     1fc:	39 23       	and	r19, r25
     1fe:	8d 85       	ldd	r24, Y+13	; 0x0d
     200:	9e 85       	ldd	r25, Y+14	; 0x0e
     202:	28 17       	cp	r18, r24
     204:	39 07       	cpc	r19, r25
     206:	71 f4       	brne	.+28     	; 0x224 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     208:	eb 81       	ldd	r30, Y+3	; 0x03
     20a:	fc 81       	ldd	r31, Y+4	; 0x04
     20c:	20 81       	ld	r18, Z
     20e:	31 81       	ldd	r19, Z+1	; 0x01
     210:	8d 85       	ldd	r24, Y+13	; 0x0d
     212:	9e 85       	ldd	r25, Y+14	; 0x0e
     214:	80 95       	com	r24
     216:	90 95       	com	r25
     218:	82 23       	and	r24, r18
     21a:	93 23       	and	r25, r19
     21c:	eb 81       	ldd	r30, Y+3	; 0x03
     21e:	fc 81       	ldd	r31, Y+4	; 0x04
     220:	91 83       	std	Z+1, r25	; 0x01
     222:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     224:	0f 90       	pop	r0
     226:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     228:	81 e0       	ldi	r24, 0x01	; 1
     22a:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     22c:	8d 81       	ldd	r24, Y+5	; 0x05
     22e:	9e 81       	ldd	r25, Y+6	; 0x06
     230:	90 70       	andi	r25, 0x00	; 0
     232:	9e 83       	std	Y+6, r25	; 0x06
     234:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     236:	8d 81       	ldd	r24, Y+5	; 0x05
     238:	9e 81       	ldd	r25, Y+6	; 0x06
}
     23a:	60 96       	adiw	r28, 0x10	; 16
     23c:	0f b6       	in	r0, 0x3f	; 63
     23e:	f8 94       	cli
     240:	de bf       	out	0x3e, r29	; 62
     242:	0f be       	out	0x3f, r0	; 63
     244:	cd bf       	out	0x3d, r28	; 61
     246:	cf 91       	pop	r28
     248:	df 91       	pop	r29
     24a:	08 95       	ret

0000024c <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     24c:	0f 93       	push	r16
     24e:	1f 93       	push	r17
     250:	df 93       	push	r29
     252:	cf 93       	push	r28
     254:	cd b7       	in	r28, 0x3d	; 61
     256:	de b7       	in	r29, 0x3e	; 62
     258:	63 97       	sbiw	r28, 0x13	; 19
     25a:	0f b6       	in	r0, 0x3f	; 63
     25c:	f8 94       	cli
     25e:	de bf       	out	0x3e, r29	; 62
     260:	0f be       	out	0x3f, r0	; 63
     262:	cd bf       	out	0x3d, r28	; 61
     264:	9d 87       	std	Y+13, r25	; 0x0d
     266:	8c 87       	std	Y+12, r24	; 0x0c
     268:	7f 87       	std	Y+15, r23	; 0x0f
     26a:	6e 87       	std	Y+14, r22	; 0x0e
     26c:	48 8b       	std	Y+16, r20	; 0x10
     26e:	29 8b       	std	Y+17, r18	; 0x11
     270:	1b 8b       	std	Y+19, r17	; 0x13
     272:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     274:	8c 85       	ldd	r24, Y+12	; 0x0c
     276:	9d 85       	ldd	r25, Y+13	; 0x0d
     278:	9b 87       	std	Y+11, r25	; 0x0b
     27a:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     27c:	1f 82       	std	Y+7, r1	; 0x07
     27e:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     280:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     282:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     286:	ea 85       	ldd	r30, Y+10	; 0x0a
     288:	fb 85       	ldd	r31, Y+11	; 0x0b
     28a:	80 81       	ld	r24, Z
     28c:	91 81       	ldd	r25, Z+1	; 0x01
     28e:	9a 83       	std	Y+2, r25	; 0x02
     290:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     292:	89 81       	ldd	r24, Y+1	; 0x01
     294:	9a 81       	ldd	r25, Y+2	; 0x02
     296:	2e 85       	ldd	r18, Y+14	; 0x0e
     298:	3f 85       	ldd	r19, Y+15	; 0x0f
     29a:	b9 01       	movw	r22, r18
     29c:	49 89       	ldd	r20, Y+17	; 0x11
     29e:	0e 94 61 03 	call	0x6c2	; 0x6c2 <prvTestWaitCondition>
     2a2:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     2a4:	8d 81       	ldd	r24, Y+5	; 0x05
     2a6:	88 23       	and	r24, r24
     2a8:	c1 f0       	breq	.+48     	; 0x2da <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     2aa:	89 81       	ldd	r24, Y+1	; 0x01
     2ac:	9a 81       	ldd	r25, Y+2	; 0x02
     2ae:	99 87       	std	Y+9, r25	; 0x09
     2b0:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     2b2:	1b 8a       	std	Y+19, r1	; 0x13
     2b4:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     2b6:	88 89       	ldd	r24, Y+16	; 0x10
     2b8:	88 23       	and	r24, r24
     2ba:	e9 f1       	breq	.+122    	; 0x336 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     2bc:	ea 85       	ldd	r30, Y+10	; 0x0a
     2be:	fb 85       	ldd	r31, Y+11	; 0x0b
     2c0:	20 81       	ld	r18, Z
     2c2:	31 81       	ldd	r19, Z+1	; 0x01
     2c4:	8e 85       	ldd	r24, Y+14	; 0x0e
     2c6:	9f 85       	ldd	r25, Y+15	; 0x0f
     2c8:	80 95       	com	r24
     2ca:	90 95       	com	r25
     2cc:	82 23       	and	r24, r18
     2ce:	93 23       	and	r25, r19
     2d0:	ea 85       	ldd	r30, Y+10	; 0x0a
     2d2:	fb 85       	ldd	r31, Y+11	; 0x0b
     2d4:	91 83       	std	Z+1, r25	; 0x01
     2d6:	80 83       	st	Z, r24
     2d8:	2e c0       	rjmp	.+92     	; 0x336 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     2da:	8a 89       	ldd	r24, Y+18	; 0x12
     2dc:	9b 89       	ldd	r25, Y+19	; 0x13
     2de:	00 97       	sbiw	r24, 0x00	; 0
     2e0:	39 f4       	brne	.+14     	; 0x2f0 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	9a 81       	ldd	r25, Y+2	; 0x02
     2e6:	99 87       	std	Y+9, r25	; 0x09
     2e8:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     2ea:	81 e0       	ldi	r24, 0x01	; 1
     2ec:	8b 83       	std	Y+3, r24	; 0x03
     2ee:	23 c0       	rjmp	.+70     	; 0x336 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     2f0:	88 89       	ldd	r24, Y+16	; 0x10
     2f2:	88 23       	and	r24, r24
     2f4:	29 f0       	breq	.+10     	; 0x300 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     2f6:	8e 81       	ldd	r24, Y+6	; 0x06
     2f8:	9f 81       	ldd	r25, Y+7	; 0x07
     2fa:	91 60       	ori	r25, 0x01	; 1
     2fc:	9f 83       	std	Y+7, r25	; 0x07
     2fe:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     300:	89 89       	ldd	r24, Y+17	; 0x11
     302:	88 23       	and	r24, r24
     304:	29 f0       	breq	.+10     	; 0x310 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     306:	8e 81       	ldd	r24, Y+6	; 0x06
     308:	9f 81       	ldd	r25, Y+7	; 0x07
     30a:	94 60       	ori	r25, 0x04	; 4
     30c:	9f 83       	std	Y+7, r25	; 0x07
     30e:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     310:	8a 85       	ldd	r24, Y+10	; 0x0a
     312:	9b 85       	ldd	r25, Y+11	; 0x0b
     314:	bc 01       	movw	r22, r24
     316:	6e 5f       	subi	r22, 0xFE	; 254
     318:	7f 4f       	sbci	r23, 0xFF	; 255
     31a:	2e 85       	ldd	r18, Y+14	; 0x0e
     31c:	3f 85       	ldd	r19, Y+15	; 0x0f
     31e:	8e 81       	ldd	r24, Y+6	; 0x06
     320:	9f 81       	ldd	r25, Y+7	; 0x07
     322:	28 2b       	or	r18, r24
     324:	39 2b       	or	r19, r25
     326:	4a 89       	ldd	r20, Y+18	; 0x12
     328:	5b 89       	ldd	r21, Y+19	; 0x13
     32a:	cb 01       	movw	r24, r22
     32c:	b9 01       	movw	r22, r18
     32e:	0e 94 9b 14 	call	0x2936	; 0x2936 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     332:	19 86       	std	Y+9, r1	; 0x09
     334:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     336:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
     33a:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     33c:	8a 89       	ldd	r24, Y+18	; 0x12
     33e:	9b 89       	ldd	r25, Y+19	; 0x13
     340:	00 97       	sbiw	r24, 0x00	; 0
     342:	09 f4       	brne	.+2      	; 0x346 <xEventGroupWaitBits+0xfa>
     344:	3c c0       	rjmp	.+120    	; 0x3be <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     346:	8c 81       	ldd	r24, Y+4	; 0x04
     348:	88 23       	and	r24, r24
     34a:	11 f4       	brne	.+4      	; 0x350 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     34c:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     350:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <uxTaskResetEventItemValue>
     354:	99 87       	std	Y+9, r25	; 0x09
     356:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     358:	88 85       	ldd	r24, Y+8	; 0x08
     35a:	99 85       	ldd	r25, Y+9	; 0x09
     35c:	80 70       	andi	r24, 0x00	; 0
     35e:	92 70       	andi	r25, 0x02	; 2
     360:	00 97       	sbiw	r24, 0x00	; 0
     362:	41 f5       	brne	.+80     	; 0x3b4 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     364:	0f b6       	in	r0, 0x3f	; 63
     366:	f8 94       	cli
     368:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     36a:	ea 85       	ldd	r30, Y+10	; 0x0a
     36c:	fb 85       	ldd	r31, Y+11	; 0x0b
     36e:	80 81       	ld	r24, Z
     370:	91 81       	ldd	r25, Z+1	; 0x01
     372:	99 87       	std	Y+9, r25	; 0x09
     374:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     376:	88 85       	ldd	r24, Y+8	; 0x08
     378:	99 85       	ldd	r25, Y+9	; 0x09
     37a:	2e 85       	ldd	r18, Y+14	; 0x0e
     37c:	3f 85       	ldd	r19, Y+15	; 0x0f
     37e:	b9 01       	movw	r22, r18
     380:	49 89       	ldd	r20, Y+17	; 0x11
     382:	0e 94 61 03 	call	0x6c2	; 0x6c2 <prvTestWaitCondition>
     386:	88 23       	and	r24, r24
     388:	89 f0       	breq	.+34     	; 0x3ac <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     38a:	88 89       	ldd	r24, Y+16	; 0x10
     38c:	88 23       	and	r24, r24
     38e:	71 f0       	breq	.+28     	; 0x3ac <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     390:	ea 85       	ldd	r30, Y+10	; 0x0a
     392:	fb 85       	ldd	r31, Y+11	; 0x0b
     394:	20 81       	ld	r18, Z
     396:	31 81       	ldd	r19, Z+1	; 0x01
     398:	8e 85       	ldd	r24, Y+14	; 0x0e
     39a:	9f 85       	ldd	r25, Y+15	; 0x0f
     39c:	80 95       	com	r24
     39e:	90 95       	com	r25
     3a0:	82 23       	and	r24, r18
     3a2:	93 23       	and	r25, r19
     3a4:	ea 85       	ldd	r30, Y+10	; 0x0a
     3a6:	fb 85       	ldd	r31, Y+11	; 0x0b
     3a8:	91 83       	std	Z+1, r25	; 0x01
     3aa:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     3ac:	81 e0       	ldi	r24, 0x01	; 1
     3ae:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     3b0:	0f 90       	pop	r0
     3b2:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     3b4:	88 85       	ldd	r24, Y+8	; 0x08
     3b6:	99 85       	ldd	r25, Y+9	; 0x09
     3b8:	90 70       	andi	r25, 0x00	; 0
     3ba:	99 87       	std	Y+9, r25	; 0x09
     3bc:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     3be:	88 85       	ldd	r24, Y+8	; 0x08
     3c0:	99 85       	ldd	r25, Y+9	; 0x09
}
     3c2:	63 96       	adiw	r28, 0x13	; 19
     3c4:	0f b6       	in	r0, 0x3f	; 63
     3c6:	f8 94       	cli
     3c8:	de bf       	out	0x3e, r29	; 62
     3ca:	0f be       	out	0x3f, r0	; 63
     3cc:	cd bf       	out	0x3d, r28	; 61
     3ce:	cf 91       	pop	r28
     3d0:	df 91       	pop	r29
     3d2:	1f 91       	pop	r17
     3d4:	0f 91       	pop	r16
     3d6:	08 95       	ret

000003d8 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     3d8:	df 93       	push	r29
     3da:	cf 93       	push	r28
     3dc:	cd b7       	in	r28, 0x3d	; 61
     3de:	de b7       	in	r29, 0x3e	; 62
     3e0:	28 97       	sbiw	r28, 0x08	; 8
     3e2:	0f b6       	in	r0, 0x3f	; 63
     3e4:	f8 94       	cli
     3e6:	de bf       	out	0x3e, r29	; 62
     3e8:	0f be       	out	0x3f, r0	; 63
     3ea:	cd bf       	out	0x3d, r28	; 61
     3ec:	9e 83       	std	Y+6, r25	; 0x06
     3ee:	8d 83       	std	Y+5, r24	; 0x05
     3f0:	78 87       	std	Y+8, r23	; 0x08
     3f2:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     3f4:	8d 81       	ldd	r24, Y+5	; 0x05
     3f6:	9e 81       	ldd	r25, Y+6	; 0x06
     3f8:	9c 83       	std	Y+4, r25	; 0x04
     3fa:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     3fc:	0f b6       	in	r0, 0x3f	; 63
     3fe:	f8 94       	cli
     400:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     402:	eb 81       	ldd	r30, Y+3	; 0x03
     404:	fc 81       	ldd	r31, Y+4	; 0x04
     406:	80 81       	ld	r24, Z
     408:	91 81       	ldd	r25, Z+1	; 0x01
     40a:	9a 83       	std	Y+2, r25	; 0x02
     40c:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     40e:	eb 81       	ldd	r30, Y+3	; 0x03
     410:	fc 81       	ldd	r31, Y+4	; 0x04
     412:	20 81       	ld	r18, Z
     414:	31 81       	ldd	r19, Z+1	; 0x01
     416:	8f 81       	ldd	r24, Y+7	; 0x07
     418:	98 85       	ldd	r25, Y+8	; 0x08
     41a:	80 95       	com	r24
     41c:	90 95       	com	r25
     41e:	82 23       	and	r24, r18
     420:	93 23       	and	r25, r19
     422:	eb 81       	ldd	r30, Y+3	; 0x03
     424:	fc 81       	ldd	r31, Y+4	; 0x04
     426:	91 83       	std	Z+1, r25	; 0x01
     428:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     42a:	0f 90       	pop	r0
     42c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     42e:	89 81       	ldd	r24, Y+1	; 0x01
     430:	9a 81       	ldd	r25, Y+2	; 0x02
}
     432:	28 96       	adiw	r28, 0x08	; 8
     434:	0f b6       	in	r0, 0x3f	; 63
     436:	f8 94       	cli
     438:	de bf       	out	0x3e, r29	; 62
     43a:	0f be       	out	0x3f, r0	; 63
     43c:	cd bf       	out	0x3d, r28	; 61
     43e:	cf 91       	pop	r28
     440:	df 91       	pop	r29
     442:	08 95       	ret

00000444 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     444:	df 93       	push	r29
     446:	cf 93       	push	r28
     448:	cd b7       	in	r28, 0x3d	; 61
     44a:	de b7       	in	r29, 0x3e	; 62
     44c:	27 97       	sbiw	r28, 0x07	; 7
     44e:	0f b6       	in	r0, 0x3f	; 63
     450:	f8 94       	cli
     452:	de bf       	out	0x3e, r29	; 62
     454:	0f be       	out	0x3f, r0	; 63
     456:	cd bf       	out	0x3d, r28	; 61
     458:	9f 83       	std	Y+7, r25	; 0x07
     45a:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     45c:	8e 81       	ldd	r24, Y+6	; 0x06
     45e:	9f 81       	ldd	r25, Y+7	; 0x07
     460:	9c 83       	std	Y+4, r25	; 0x04
     462:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     464:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     466:	eb 81       	ldd	r30, Y+3	; 0x03
     468:	fc 81       	ldd	r31, Y+4	; 0x04
     46a:	80 81       	ld	r24, Z
     46c:	91 81       	ldd	r25, Z+1	; 0x01
     46e:	9a 83       	std	Y+2, r25	; 0x02
     470:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     472:	89 81       	ldd	r24, Y+1	; 0x01
     474:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     476:	27 96       	adiw	r28, 0x07	; 7
     478:	0f b6       	in	r0, 0x3f	; 63
     47a:	f8 94       	cli
     47c:	de bf       	out	0x3e, r29	; 62
     47e:	0f be       	out	0x3f, r0	; 63
     480:	cd bf       	out	0x3d, r28	; 61
     482:	cf 91       	pop	r28
     484:	df 91       	pop	r29
     486:	08 95       	ret

00000488 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     488:	df 93       	push	r29
     48a:	cf 93       	push	r28
     48c:	cd b7       	in	r28, 0x3d	; 61
     48e:	de b7       	in	r29, 0x3e	; 62
     490:	65 97       	sbiw	r28, 0x15	; 21
     492:	0f b6       	in	r0, 0x3f	; 63
     494:	f8 94       	cli
     496:	de bf       	out	0x3e, r29	; 62
     498:	0f be       	out	0x3f, r0	; 63
     49a:	cd bf       	out	0x3d, r28	; 61
     49c:	9b 8b       	std	Y+19, r25	; 0x13
     49e:	8a 8b       	std	Y+18, r24	; 0x12
     4a0:	7d 8b       	std	Y+21, r23	; 0x15
     4a2:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     4a4:	19 86       	std	Y+9, r1	; 0x09
     4a6:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     4a8:	8a 89       	ldd	r24, Y+18	; 0x12
     4aa:	9b 89       	ldd	r25, Y+19	; 0x13
     4ac:	9b 83       	std	Y+3, r25	; 0x03
     4ae:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     4b0:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     4b2:	8a 81       	ldd	r24, Y+2	; 0x02
     4b4:	9b 81       	ldd	r25, Y+3	; 0x03
     4b6:	02 96       	adiw	r24, 0x02	; 2
     4b8:	9b 87       	std	Y+11, r25	; 0x0b
     4ba:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4bc:	8a 85       	ldd	r24, Y+10	; 0x0a
     4be:	9b 85       	ldd	r25, Y+11	; 0x0b
     4c0:	03 96       	adiw	r24, 0x03	; 3
     4c2:	9d 87       	std	Y+13, r25	; 0x0d
     4c4:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     4c6:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     4ca:	ea 85       	ldd	r30, Y+10	; 0x0a
     4cc:	fb 85       	ldd	r31, Y+11	; 0x0b
     4ce:	85 81       	ldd	r24, Z+5	; 0x05
     4d0:	96 81       	ldd	r25, Z+6	; 0x06
     4d2:	99 8b       	std	Y+17, r25	; 0x11
     4d4:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     4d6:	ea 81       	ldd	r30, Y+2	; 0x02
     4d8:	fb 81       	ldd	r31, Y+3	; 0x03
     4da:	20 81       	ld	r18, Z
     4dc:	31 81       	ldd	r19, Z+1	; 0x01
     4de:	8c 89       	ldd	r24, Y+20	; 0x14
     4e0:	9d 89       	ldd	r25, Y+21	; 0x15
     4e2:	82 2b       	or	r24, r18
     4e4:	93 2b       	or	r25, r19
     4e6:	ea 81       	ldd	r30, Y+2	; 0x02
     4e8:	fb 81       	ldd	r31, Y+3	; 0x03
     4ea:	91 83       	std	Z+1, r25	; 0x01
     4ec:	80 83       	st	Z, r24
     4ee:	59 c0       	rjmp	.+178    	; 0x5a2 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     4f0:	e8 89       	ldd	r30, Y+16	; 0x10
     4f2:	f9 89       	ldd	r31, Y+17	; 0x11
     4f4:	82 81       	ldd	r24, Z+2	; 0x02
     4f6:	93 81       	ldd	r25, Z+3	; 0x03
     4f8:	9f 87       	std	Y+15, r25	; 0x0f
     4fa:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     4fc:	e8 89       	ldd	r30, Y+16	; 0x10
     4fe:	f9 89       	ldd	r31, Y+17	; 0x11
     500:	80 81       	ld	r24, Z
     502:	91 81       	ldd	r25, Z+1	; 0x01
     504:	9f 83       	std	Y+7, r25	; 0x07
     506:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     508:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     50a:	8e 81       	ldd	r24, Y+6	; 0x06
     50c:	9f 81       	ldd	r25, Y+7	; 0x07
     50e:	80 70       	andi	r24, 0x00	; 0
     510:	9d 83       	std	Y+5, r25	; 0x05
     512:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     514:	8e 81       	ldd	r24, Y+6	; 0x06
     516:	9f 81       	ldd	r25, Y+7	; 0x07
     518:	90 70       	andi	r25, 0x00	; 0
     51a:	9f 83       	std	Y+7, r25	; 0x07
     51c:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     51e:	8c 81       	ldd	r24, Y+4	; 0x04
     520:	9d 81       	ldd	r25, Y+5	; 0x05
     522:	80 70       	andi	r24, 0x00	; 0
     524:	94 70       	andi	r25, 0x04	; 4
     526:	00 97       	sbiw	r24, 0x00	; 0
     528:	69 f4       	brne	.+26     	; 0x544 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     52a:	ea 81       	ldd	r30, Y+2	; 0x02
     52c:	fb 81       	ldd	r31, Y+3	; 0x03
     52e:	20 81       	ld	r18, Z
     530:	31 81       	ldd	r19, Z+1	; 0x01
     532:	8e 81       	ldd	r24, Y+6	; 0x06
     534:	9f 81       	ldd	r25, Y+7	; 0x07
     536:	82 23       	and	r24, r18
     538:	93 23       	and	r25, r19
     53a:	00 97       	sbiw	r24, 0x00	; 0
     53c:	91 f0       	breq	.+36     	; 0x562 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	89 83       	std	Y+1, r24	; 0x01
     542:	0f c0       	rjmp	.+30     	; 0x562 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     544:	ea 81       	ldd	r30, Y+2	; 0x02
     546:	fb 81       	ldd	r31, Y+3	; 0x03
     548:	20 81       	ld	r18, Z
     54a:	31 81       	ldd	r19, Z+1	; 0x01
     54c:	8e 81       	ldd	r24, Y+6	; 0x06
     54e:	9f 81       	ldd	r25, Y+7	; 0x07
     550:	28 23       	and	r18, r24
     552:	39 23       	and	r19, r25
     554:	8e 81       	ldd	r24, Y+6	; 0x06
     556:	9f 81       	ldd	r25, Y+7	; 0x07
     558:	28 17       	cp	r18, r24
     55a:	39 07       	cpc	r19, r25
     55c:	11 f4       	brne	.+4      	; 0x562 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     562:	89 81       	ldd	r24, Y+1	; 0x01
     564:	88 23       	and	r24, r24
     566:	c9 f0       	breq	.+50     	; 0x59a <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     568:	8c 81       	ldd	r24, Y+4	; 0x04
     56a:	9d 81       	ldd	r25, Y+5	; 0x05
     56c:	80 70       	andi	r24, 0x00	; 0
     56e:	91 70       	andi	r25, 0x01	; 1
     570:	00 97       	sbiw	r24, 0x00	; 0
     572:	41 f0       	breq	.+16     	; 0x584 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     574:	88 85       	ldd	r24, Y+8	; 0x08
     576:	99 85       	ldd	r25, Y+9	; 0x09
     578:	2e 81       	ldd	r18, Y+6	; 0x06
     57a:	3f 81       	ldd	r19, Y+7	; 0x07
     57c:	82 2b       	or	r24, r18
     57e:	93 2b       	or	r25, r19
     580:	99 87       	std	Y+9, r25	; 0x09
     582:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     584:	ea 81       	ldd	r30, Y+2	; 0x02
     586:	fb 81       	ldd	r31, Y+3	; 0x03
     588:	80 81       	ld	r24, Z
     58a:	91 81       	ldd	r25, Z+1	; 0x01
     58c:	9c 01       	movw	r18, r24
     58e:	32 60       	ori	r19, 0x02	; 2
     590:	88 89       	ldd	r24, Y+16	; 0x10
     592:	99 89       	ldd	r25, Y+17	; 0x11
     594:	b9 01       	movw	r22, r18
     596:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     59a:	8e 85       	ldd	r24, Y+14	; 0x0e
     59c:	9f 85       	ldd	r25, Y+15	; 0x0f
     59e:	99 8b       	std	Y+17, r25	; 0x11
     5a0:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     5a2:	28 89       	ldd	r18, Y+16	; 0x10
     5a4:	39 89       	ldd	r19, Y+17	; 0x11
     5a6:	8c 85       	ldd	r24, Y+12	; 0x0c
     5a8:	9d 85       	ldd	r25, Y+13	; 0x0d
     5aa:	28 17       	cp	r18, r24
     5ac:	39 07       	cpc	r19, r25
     5ae:	09 f0       	breq	.+2      	; 0x5b2 <xEventGroupSetBits+0x12a>
     5b0:	9f cf       	rjmp	.-194    	; 0x4f0 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     5b2:	ea 81       	ldd	r30, Y+2	; 0x02
     5b4:	fb 81       	ldd	r31, Y+3	; 0x03
     5b6:	20 81       	ld	r18, Z
     5b8:	31 81       	ldd	r19, Z+1	; 0x01
     5ba:	88 85       	ldd	r24, Y+8	; 0x08
     5bc:	99 85       	ldd	r25, Y+9	; 0x09
     5be:	80 95       	com	r24
     5c0:	90 95       	com	r25
     5c2:	82 23       	and	r24, r18
     5c4:	93 23       	and	r25, r19
     5c6:	ea 81       	ldd	r30, Y+2	; 0x02
     5c8:	fb 81       	ldd	r31, Y+3	; 0x03
     5ca:	91 83       	std	Z+1, r25	; 0x01
     5cc:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     5ce:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     5d2:	ea 81       	ldd	r30, Y+2	; 0x02
     5d4:	fb 81       	ldd	r31, Y+3	; 0x03
     5d6:	80 81       	ld	r24, Z
     5d8:	91 81       	ldd	r25, Z+1	; 0x01
}
     5da:	65 96       	adiw	r28, 0x15	; 21
     5dc:	0f b6       	in	r0, 0x3f	; 63
     5de:	f8 94       	cli
     5e0:	de bf       	out	0x3e, r29	; 62
     5e2:	0f be       	out	0x3f, r0	; 63
     5e4:	cd bf       	out	0x3d, r28	; 61
     5e6:	cf 91       	pop	r28
     5e8:	df 91       	pop	r29
     5ea:	08 95       	ret

000005ec <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     5ec:	df 93       	push	r29
     5ee:	cf 93       	push	r28
     5f0:	00 d0       	rcall	.+0      	; 0x5f2 <vEventGroupDelete+0x6>
     5f2:	00 d0       	rcall	.+0      	; 0x5f4 <vEventGroupDelete+0x8>
     5f4:	00 d0       	rcall	.+0      	; 0x5f6 <vEventGroupDelete+0xa>
     5f6:	cd b7       	in	r28, 0x3d	; 61
     5f8:	de b7       	in	r29, 0x3e	; 62
     5fa:	9e 83       	std	Y+6, r25	; 0x06
     5fc:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     5fe:	8d 81       	ldd	r24, Y+5	; 0x05
     600:	9e 81       	ldd	r25, Y+6	; 0x06
     602:	9c 83       	std	Y+4, r25	; 0x04
     604:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     606:	8b 81       	ldd	r24, Y+3	; 0x03
     608:	9c 81       	ldd	r25, Y+4	; 0x04
     60a:	02 96       	adiw	r24, 0x02	; 2
     60c:	9a 83       	std	Y+2, r25	; 0x02
     60e:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     610:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
     614:	08 c0       	rjmp	.+16     	; 0x626 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     616:	e9 81       	ldd	r30, Y+1	; 0x01
     618:	fa 81       	ldd	r31, Y+2	; 0x02
     61a:	85 81       	ldd	r24, Z+5	; 0x05
     61c:	96 81       	ldd	r25, Z+6	; 0x06
     61e:	60 e0       	ldi	r22, 0x00	; 0
     620:	72 e0       	ldi	r23, 0x02	; 2
     622:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     626:	e9 81       	ldd	r30, Y+1	; 0x01
     628:	fa 81       	ldd	r31, Y+2	; 0x02
     62a:	80 81       	ld	r24, Z
     62c:	88 23       	and	r24, r24
     62e:	99 f7       	brne	.-26     	; 0x616 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     630:	8b 81       	ldd	r24, Y+3	; 0x03
     632:	9c 81       	ldd	r25, Y+4	; 0x04
     634:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     638:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
}
     63c:	26 96       	adiw	r28, 0x06	; 6
     63e:	0f b6       	in	r0, 0x3f	; 63
     640:	f8 94       	cli
     642:	de bf       	out	0x3e, r29	; 62
     644:	0f be       	out	0x3f, r0	; 63
     646:	cd bf       	out	0x3d, r28	; 61
     648:	cf 91       	pop	r28
     64a:	df 91       	pop	r29
     64c:	08 95       	ret

0000064e <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     64e:	df 93       	push	r29
     650:	cf 93       	push	r28
     652:	00 d0       	rcall	.+0      	; 0x654 <vEventGroupSetBitsCallback+0x6>
     654:	00 d0       	rcall	.+0      	; 0x656 <vEventGroupSetBitsCallback+0x8>
     656:	00 d0       	rcall	.+0      	; 0x658 <vEventGroupSetBitsCallback+0xa>
     658:	cd b7       	in	r28, 0x3d	; 61
     65a:	de b7       	in	r29, 0x3e	; 62
     65c:	9a 83       	std	Y+2, r25	; 0x02
     65e:	89 83       	std	Y+1, r24	; 0x01
     660:	4b 83       	std	Y+3, r20	; 0x03
     662:	5c 83       	std	Y+4, r21	; 0x04
     664:	6d 83       	std	Y+5, r22	; 0x05
     666:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     668:	89 81       	ldd	r24, Y+1	; 0x01
     66a:	9a 81       	ldd	r25, Y+2	; 0x02
     66c:	2b 81       	ldd	r18, Y+3	; 0x03
     66e:	3c 81       	ldd	r19, Y+4	; 0x04
     670:	b9 01       	movw	r22, r18
     672:	0e 94 44 02 	call	0x488	; 0x488 <xEventGroupSetBits>
}
     676:	26 96       	adiw	r28, 0x06	; 6
     678:	0f b6       	in	r0, 0x3f	; 63
     67a:	f8 94       	cli
     67c:	de bf       	out	0x3e, r29	; 62
     67e:	0f be       	out	0x3f, r0	; 63
     680:	cd bf       	out	0x3d, r28	; 61
     682:	cf 91       	pop	r28
     684:	df 91       	pop	r29
     686:	08 95       	ret

00000688 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     688:	df 93       	push	r29
     68a:	cf 93       	push	r28
     68c:	00 d0       	rcall	.+0      	; 0x68e <vEventGroupClearBitsCallback+0x6>
     68e:	00 d0       	rcall	.+0      	; 0x690 <vEventGroupClearBitsCallback+0x8>
     690:	00 d0       	rcall	.+0      	; 0x692 <vEventGroupClearBitsCallback+0xa>
     692:	cd b7       	in	r28, 0x3d	; 61
     694:	de b7       	in	r29, 0x3e	; 62
     696:	9a 83       	std	Y+2, r25	; 0x02
     698:	89 83       	std	Y+1, r24	; 0x01
     69a:	4b 83       	std	Y+3, r20	; 0x03
     69c:	5c 83       	std	Y+4, r21	; 0x04
     69e:	6d 83       	std	Y+5, r22	; 0x05
     6a0:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     6a2:	89 81       	ldd	r24, Y+1	; 0x01
     6a4:	9a 81       	ldd	r25, Y+2	; 0x02
     6a6:	2b 81       	ldd	r18, Y+3	; 0x03
     6a8:	3c 81       	ldd	r19, Y+4	; 0x04
     6aa:	b9 01       	movw	r22, r18
     6ac:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <xEventGroupClearBits>
}
     6b0:	26 96       	adiw	r28, 0x06	; 6
     6b2:	0f b6       	in	r0, 0x3f	; 63
     6b4:	f8 94       	cli
     6b6:	de bf       	out	0x3e, r29	; 62
     6b8:	0f be       	out	0x3f, r0	; 63
     6ba:	cd bf       	out	0x3d, r28	; 61
     6bc:	cf 91       	pop	r28
     6be:	df 91       	pop	r29
     6c0:	08 95       	ret

000006c2 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     6c2:	df 93       	push	r29
     6c4:	cf 93       	push	r28
     6c6:	00 d0       	rcall	.+0      	; 0x6c8 <prvTestWaitCondition+0x6>
     6c8:	00 d0       	rcall	.+0      	; 0x6ca <prvTestWaitCondition+0x8>
     6ca:	00 d0       	rcall	.+0      	; 0x6cc <prvTestWaitCondition+0xa>
     6cc:	cd b7       	in	r28, 0x3d	; 61
     6ce:	de b7       	in	r29, 0x3e	; 62
     6d0:	9b 83       	std	Y+3, r25	; 0x03
     6d2:	8a 83       	std	Y+2, r24	; 0x02
     6d4:	7d 83       	std	Y+5, r23	; 0x05
     6d6:	6c 83       	std	Y+4, r22	; 0x04
     6d8:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     6da:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     6dc:	8e 81       	ldd	r24, Y+6	; 0x06
     6de:	88 23       	and	r24, r24
     6e0:	59 f4       	brne	.+22     	; 0x6f8 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     6e2:	8a 81       	ldd	r24, Y+2	; 0x02
     6e4:	9b 81       	ldd	r25, Y+3	; 0x03
     6e6:	2c 81       	ldd	r18, Y+4	; 0x04
     6e8:	3d 81       	ldd	r19, Y+5	; 0x05
     6ea:	82 23       	and	r24, r18
     6ec:	93 23       	and	r25, r19
     6ee:	00 97       	sbiw	r24, 0x00	; 0
     6f0:	81 f0       	breq	.+32     	; 0x712 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     6f2:	81 e0       	ldi	r24, 0x01	; 1
     6f4:	89 83       	std	Y+1, r24	; 0x01
     6f6:	0d c0       	rjmp	.+26     	; 0x712 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     6f8:	2a 81       	ldd	r18, Y+2	; 0x02
     6fa:	3b 81       	ldd	r19, Y+3	; 0x03
     6fc:	8c 81       	ldd	r24, Y+4	; 0x04
     6fe:	9d 81       	ldd	r25, Y+5	; 0x05
     700:	28 23       	and	r18, r24
     702:	39 23       	and	r19, r25
     704:	8c 81       	ldd	r24, Y+4	; 0x04
     706:	9d 81       	ldd	r25, Y+5	; 0x05
     708:	28 17       	cp	r18, r24
     70a:	39 07       	cpc	r19, r25
     70c:	11 f4       	brne	.+4      	; 0x712 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     70e:	81 e0       	ldi	r24, 0x01	; 1
     710:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     712:	89 81       	ldd	r24, Y+1	; 0x01
}
     714:	26 96       	adiw	r28, 0x06	; 6
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	f8 94       	cli
     71a:	de bf       	out	0x3e, r29	; 62
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	cd bf       	out	0x3d, r28	; 61
     720:	cf 91       	pop	r28
     722:	df 91       	pop	r29
     724:	08 95       	ret

00000726 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     726:	df 93       	push	r29
     728:	cf 93       	push	r28
     72a:	00 d0       	rcall	.+0      	; 0x72c <pvPortMalloc+0x6>
     72c:	00 d0       	rcall	.+0      	; 0x72e <pvPortMalloc+0x8>
     72e:	cd b7       	in	r28, 0x3d	; 61
     730:	de b7       	in	r29, 0x3e	; 62
     732:	9c 83       	std	Y+4, r25	; 0x04
     734:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     736:	1a 82       	std	Y+2, r1	; 0x02
     738:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     73a:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     73e:	80 91 80 00 	lds	r24, 0x0080
     742:	90 91 81 00 	lds	r25, 0x0081
     746:	00 97       	sbiw	r24, 0x00	; 0
     748:	31 f4       	brne	.+12     	; 0x756 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     74a:	83 e8       	ldi	r24, 0x83	; 131
     74c:	90 e0       	ldi	r25, 0x00	; 0
     74e:	90 93 81 00 	sts	0x0081, r25
     752:	80 93 80 00 	sts	0x0080, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     756:	80 91 7e 00 	lds	r24, 0x007E
     75a:	90 91 7f 00 	lds	r25, 0x007F
     75e:	2b 81       	ldd	r18, Y+3	; 0x03
     760:	3c 81       	ldd	r19, Y+4	; 0x04
     762:	82 0f       	add	r24, r18
     764:	93 1f       	adc	r25, r19
     766:	22 e0       	ldi	r18, 0x02	; 2
     768:	87 35       	cpi	r24, 0x57	; 87
     76a:	92 07       	cpc	r25, r18
     76c:	38 f5       	brcc	.+78     	; 0x7bc <pvPortMalloc+0x96>
     76e:	20 91 7e 00 	lds	r18, 0x007E
     772:	30 91 7f 00 	lds	r19, 0x007F
     776:	8b 81       	ldd	r24, Y+3	; 0x03
     778:	9c 81       	ldd	r25, Y+4	; 0x04
     77a:	28 0f       	add	r18, r24
     77c:	39 1f       	adc	r19, r25
     77e:	80 91 7e 00 	lds	r24, 0x007E
     782:	90 91 7f 00 	lds	r25, 0x007F
     786:	82 17       	cp	r24, r18
     788:	93 07       	cpc	r25, r19
     78a:	c0 f4       	brcc	.+48     	; 0x7bc <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     78c:	20 91 80 00 	lds	r18, 0x0080
     790:	30 91 81 00 	lds	r19, 0x0081
     794:	80 91 7e 00 	lds	r24, 0x007E
     798:	90 91 7f 00 	lds	r25, 0x007F
     79c:	82 0f       	add	r24, r18
     79e:	93 1f       	adc	r25, r19
     7a0:	9a 83       	std	Y+2, r25	; 0x02
     7a2:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     7a4:	20 91 7e 00 	lds	r18, 0x007E
     7a8:	30 91 7f 00 	lds	r19, 0x007F
     7ac:	8b 81       	ldd	r24, Y+3	; 0x03
     7ae:	9c 81       	ldd	r25, Y+4	; 0x04
     7b0:	82 0f       	add	r24, r18
     7b2:	93 1f       	adc	r25, r19
     7b4:	90 93 7f 00 	sts	0x007F, r25
     7b8:	80 93 7e 00 	sts	0x007E, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     7bc:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     7c0:	89 81       	ldd	r24, Y+1	; 0x01
     7c2:	9a 81       	ldd	r25, Y+2	; 0x02
}
     7c4:	0f 90       	pop	r0
     7c6:	0f 90       	pop	r0
     7c8:	0f 90       	pop	r0
     7ca:	0f 90       	pop	r0
     7cc:	cf 91       	pop	r28
     7ce:	df 91       	pop	r29
     7d0:	08 95       	ret

000007d2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7d2:	df 93       	push	r29
     7d4:	cf 93       	push	r28
     7d6:	00 d0       	rcall	.+0      	; 0x7d8 <vPortFree+0x6>
     7d8:	cd b7       	in	r28, 0x3d	; 61
     7da:	de b7       	in	r29, 0x3e	; 62
     7dc:	9a 83       	std	Y+2, r25	; 0x02
     7de:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     7e0:	0f 90       	pop	r0
     7e2:	0f 90       	pop	r0
     7e4:	cf 91       	pop	r28
     7e6:	df 91       	pop	r29
     7e8:	08 95       	ret

000007ea <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     7ea:	df 93       	push	r29
     7ec:	cf 93       	push	r28
     7ee:	cd b7       	in	r28, 0x3d	; 61
     7f0:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     7f2:	10 92 7f 00 	sts	0x007F, r1
     7f6:	10 92 7e 00 	sts	0x007E, r1
}
     7fa:	cf 91       	pop	r28
     7fc:	df 91       	pop	r29
     7fe:	08 95       	ret

00000800 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     800:	df 93       	push	r29
     802:	cf 93       	push	r28
     804:	cd b7       	in	r28, 0x3d	; 61
     806:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     808:	20 91 7e 00 	lds	r18, 0x007E
     80c:	30 91 7f 00 	lds	r19, 0x007F
     810:	87 e5       	ldi	r24, 0x57	; 87
     812:	92 e0       	ldi	r25, 0x02	; 2
     814:	82 1b       	sub	r24, r18
     816:	93 0b       	sbc	r25, r19
}
     818:	cf 91       	pop	r28
     81a:	df 91       	pop	r29
     81c:	08 95       	ret

0000081e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     81e:	df 93       	push	r29
     820:	cf 93       	push	r28
     822:	00 d0       	rcall	.+0      	; 0x824 <vListInitialise+0x6>
     824:	cd b7       	in	r28, 0x3d	; 61
     826:	de b7       	in	r29, 0x3e	; 62
     828:	9a 83       	std	Y+2, r25	; 0x02
     82a:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     82c:	89 81       	ldd	r24, Y+1	; 0x01
     82e:	9a 81       	ldd	r25, Y+2	; 0x02
     830:	03 96       	adiw	r24, 0x03	; 3
     832:	e9 81       	ldd	r30, Y+1	; 0x01
     834:	fa 81       	ldd	r31, Y+2	; 0x02
     836:	92 83       	std	Z+2, r25	; 0x02
     838:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     83a:	e9 81       	ldd	r30, Y+1	; 0x01
     83c:	fa 81       	ldd	r31, Y+2	; 0x02
     83e:	8f ef       	ldi	r24, 0xFF	; 255
     840:	9f ef       	ldi	r25, 0xFF	; 255
     842:	94 83       	std	Z+4, r25	; 0x04
     844:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     846:	89 81       	ldd	r24, Y+1	; 0x01
     848:	9a 81       	ldd	r25, Y+2	; 0x02
     84a:	03 96       	adiw	r24, 0x03	; 3
     84c:	e9 81       	ldd	r30, Y+1	; 0x01
     84e:	fa 81       	ldd	r31, Y+2	; 0x02
     850:	96 83       	std	Z+6, r25	; 0x06
     852:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     854:	89 81       	ldd	r24, Y+1	; 0x01
     856:	9a 81       	ldd	r25, Y+2	; 0x02
     858:	03 96       	adiw	r24, 0x03	; 3
     85a:	e9 81       	ldd	r30, Y+1	; 0x01
     85c:	fa 81       	ldd	r31, Y+2	; 0x02
     85e:	90 87       	std	Z+8, r25	; 0x08
     860:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     862:	e9 81       	ldd	r30, Y+1	; 0x01
     864:	fa 81       	ldd	r31, Y+2	; 0x02
     866:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     868:	0f 90       	pop	r0
     86a:	0f 90       	pop	r0
     86c:	cf 91       	pop	r28
     86e:	df 91       	pop	r29
     870:	08 95       	ret

00000872 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     872:	df 93       	push	r29
     874:	cf 93       	push	r28
     876:	00 d0       	rcall	.+0      	; 0x878 <vListInitialiseItem+0x6>
     878:	cd b7       	in	r28, 0x3d	; 61
     87a:	de b7       	in	r29, 0x3e	; 62
     87c:	9a 83       	std	Y+2, r25	; 0x02
     87e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     880:	e9 81       	ldd	r30, Y+1	; 0x01
     882:	fa 81       	ldd	r31, Y+2	; 0x02
     884:	11 86       	std	Z+9, r1	; 0x09
     886:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     888:	0f 90       	pop	r0
     88a:	0f 90       	pop	r0
     88c:	cf 91       	pop	r28
     88e:	df 91       	pop	r29
     890:	08 95       	ret

00000892 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     892:	df 93       	push	r29
     894:	cf 93       	push	r28
     896:	00 d0       	rcall	.+0      	; 0x898 <vListInsertEnd+0x6>
     898:	00 d0       	rcall	.+0      	; 0x89a <vListInsertEnd+0x8>
     89a:	00 d0       	rcall	.+0      	; 0x89c <vListInsertEnd+0xa>
     89c:	cd b7       	in	r28, 0x3d	; 61
     89e:	de b7       	in	r29, 0x3e	; 62
     8a0:	9c 83       	std	Y+4, r25	; 0x04
     8a2:	8b 83       	std	Y+3, r24	; 0x03
     8a4:	7e 83       	std	Y+6, r23	; 0x06
     8a6:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     8a8:	eb 81       	ldd	r30, Y+3	; 0x03
     8aa:	fc 81       	ldd	r31, Y+4	; 0x04
     8ac:	81 81       	ldd	r24, Z+1	; 0x01
     8ae:	92 81       	ldd	r25, Z+2	; 0x02
     8b0:	9a 83       	std	Y+2, r25	; 0x02
     8b2:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8b4:	ed 81       	ldd	r30, Y+5	; 0x05
     8b6:	fe 81       	ldd	r31, Y+6	; 0x06
     8b8:	89 81       	ldd	r24, Y+1	; 0x01
     8ba:	9a 81       	ldd	r25, Y+2	; 0x02
     8bc:	93 83       	std	Z+3, r25	; 0x03
     8be:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8c0:	e9 81       	ldd	r30, Y+1	; 0x01
     8c2:	fa 81       	ldd	r31, Y+2	; 0x02
     8c4:	84 81       	ldd	r24, Z+4	; 0x04
     8c6:	95 81       	ldd	r25, Z+5	; 0x05
     8c8:	ed 81       	ldd	r30, Y+5	; 0x05
     8ca:	fe 81       	ldd	r31, Y+6	; 0x06
     8cc:	95 83       	std	Z+5, r25	; 0x05
     8ce:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8d0:	e9 81       	ldd	r30, Y+1	; 0x01
     8d2:	fa 81       	ldd	r31, Y+2	; 0x02
     8d4:	04 80       	ldd	r0, Z+4	; 0x04
     8d6:	f5 81       	ldd	r31, Z+5	; 0x05
     8d8:	e0 2d       	mov	r30, r0
     8da:	8d 81       	ldd	r24, Y+5	; 0x05
     8dc:	9e 81       	ldd	r25, Y+6	; 0x06
     8de:	93 83       	std	Z+3, r25	; 0x03
     8e0:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     8e2:	e9 81       	ldd	r30, Y+1	; 0x01
     8e4:	fa 81       	ldd	r31, Y+2	; 0x02
     8e6:	8d 81       	ldd	r24, Y+5	; 0x05
     8e8:	9e 81       	ldd	r25, Y+6	; 0x06
     8ea:	95 83       	std	Z+5, r25	; 0x05
     8ec:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     8ee:	ed 81       	ldd	r30, Y+5	; 0x05
     8f0:	fe 81       	ldd	r31, Y+6	; 0x06
     8f2:	8b 81       	ldd	r24, Y+3	; 0x03
     8f4:	9c 81       	ldd	r25, Y+4	; 0x04
     8f6:	91 87       	std	Z+9, r25	; 0x09
     8f8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8fa:	eb 81       	ldd	r30, Y+3	; 0x03
     8fc:	fc 81       	ldd	r31, Y+4	; 0x04
     8fe:	80 81       	ld	r24, Z
     900:	8f 5f       	subi	r24, 0xFF	; 255
     902:	eb 81       	ldd	r30, Y+3	; 0x03
     904:	fc 81       	ldd	r31, Y+4	; 0x04
     906:	80 83       	st	Z, r24
}
     908:	26 96       	adiw	r28, 0x06	; 6
     90a:	0f b6       	in	r0, 0x3f	; 63
     90c:	f8 94       	cli
     90e:	de bf       	out	0x3e, r29	; 62
     910:	0f be       	out	0x3f, r0	; 63
     912:	cd bf       	out	0x3d, r28	; 61
     914:	cf 91       	pop	r28
     916:	df 91       	pop	r29
     918:	08 95       	ret

0000091a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     91a:	df 93       	push	r29
     91c:	cf 93       	push	r28
     91e:	cd b7       	in	r28, 0x3d	; 61
     920:	de b7       	in	r29, 0x3e	; 62
     922:	28 97       	sbiw	r28, 0x08	; 8
     924:	0f b6       	in	r0, 0x3f	; 63
     926:	f8 94       	cli
     928:	de bf       	out	0x3e, r29	; 62
     92a:	0f be       	out	0x3f, r0	; 63
     92c:	cd bf       	out	0x3d, r28	; 61
     92e:	9e 83       	std	Y+6, r25	; 0x06
     930:	8d 83       	std	Y+5, r24	; 0x05
     932:	78 87       	std	Y+8, r23	; 0x08
     934:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     936:	ef 81       	ldd	r30, Y+7	; 0x07
     938:	f8 85       	ldd	r31, Y+8	; 0x08
     93a:	80 81       	ld	r24, Z
     93c:	91 81       	ldd	r25, Z+1	; 0x01
     93e:	9a 83       	std	Y+2, r25	; 0x02
     940:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     942:	89 81       	ldd	r24, Y+1	; 0x01
     944:	9a 81       	ldd	r25, Y+2	; 0x02
     946:	2f ef       	ldi	r18, 0xFF	; 255
     948:	8f 3f       	cpi	r24, 0xFF	; 255
     94a:	92 07       	cpc	r25, r18
     94c:	39 f4       	brne	.+14     	; 0x95c <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     94e:	ed 81       	ldd	r30, Y+5	; 0x05
     950:	fe 81       	ldd	r31, Y+6	; 0x06
     952:	87 81       	ldd	r24, Z+7	; 0x07
     954:	90 85       	ldd	r25, Z+8	; 0x08
     956:	9c 83       	std	Y+4, r25	; 0x04
     958:	8b 83       	std	Y+3, r24	; 0x03
     95a:	18 c0       	rjmp	.+48     	; 0x98c <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     95c:	8d 81       	ldd	r24, Y+5	; 0x05
     95e:	9e 81       	ldd	r25, Y+6	; 0x06
     960:	03 96       	adiw	r24, 0x03	; 3
     962:	9c 83       	std	Y+4, r25	; 0x04
     964:	8b 83       	std	Y+3, r24	; 0x03
     966:	06 c0       	rjmp	.+12     	; 0x974 <vListInsert+0x5a>
     968:	eb 81       	ldd	r30, Y+3	; 0x03
     96a:	fc 81       	ldd	r31, Y+4	; 0x04
     96c:	82 81       	ldd	r24, Z+2	; 0x02
     96e:	93 81       	ldd	r25, Z+3	; 0x03
     970:	9c 83       	std	Y+4, r25	; 0x04
     972:	8b 83       	std	Y+3, r24	; 0x03
     974:	eb 81       	ldd	r30, Y+3	; 0x03
     976:	fc 81       	ldd	r31, Y+4	; 0x04
     978:	02 80       	ldd	r0, Z+2	; 0x02
     97a:	f3 81       	ldd	r31, Z+3	; 0x03
     97c:	e0 2d       	mov	r30, r0
     97e:	20 81       	ld	r18, Z
     980:	31 81       	ldd	r19, Z+1	; 0x01
     982:	89 81       	ldd	r24, Y+1	; 0x01
     984:	9a 81       	ldd	r25, Y+2	; 0x02
     986:	82 17       	cp	r24, r18
     988:	93 07       	cpc	r25, r19
     98a:	70 f7       	brcc	.-36     	; 0x968 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     98c:	eb 81       	ldd	r30, Y+3	; 0x03
     98e:	fc 81       	ldd	r31, Y+4	; 0x04
     990:	82 81       	ldd	r24, Z+2	; 0x02
     992:	93 81       	ldd	r25, Z+3	; 0x03
     994:	ef 81       	ldd	r30, Y+7	; 0x07
     996:	f8 85       	ldd	r31, Y+8	; 0x08
     998:	93 83       	std	Z+3, r25	; 0x03
     99a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     99c:	ef 81       	ldd	r30, Y+7	; 0x07
     99e:	f8 85       	ldd	r31, Y+8	; 0x08
     9a0:	02 80       	ldd	r0, Z+2	; 0x02
     9a2:	f3 81       	ldd	r31, Z+3	; 0x03
     9a4:	e0 2d       	mov	r30, r0
     9a6:	8f 81       	ldd	r24, Y+7	; 0x07
     9a8:	98 85       	ldd	r25, Y+8	; 0x08
     9aa:	95 83       	std	Z+5, r25	; 0x05
     9ac:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     9ae:	ef 81       	ldd	r30, Y+7	; 0x07
     9b0:	f8 85       	ldd	r31, Y+8	; 0x08
     9b2:	8b 81       	ldd	r24, Y+3	; 0x03
     9b4:	9c 81       	ldd	r25, Y+4	; 0x04
     9b6:	95 83       	std	Z+5, r25	; 0x05
     9b8:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     9ba:	eb 81       	ldd	r30, Y+3	; 0x03
     9bc:	fc 81       	ldd	r31, Y+4	; 0x04
     9be:	8f 81       	ldd	r24, Y+7	; 0x07
     9c0:	98 85       	ldd	r25, Y+8	; 0x08
     9c2:	93 83       	std	Z+3, r25	; 0x03
     9c4:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     9c6:	ef 81       	ldd	r30, Y+7	; 0x07
     9c8:	f8 85       	ldd	r31, Y+8	; 0x08
     9ca:	8d 81       	ldd	r24, Y+5	; 0x05
     9cc:	9e 81       	ldd	r25, Y+6	; 0x06
     9ce:	91 87       	std	Z+9, r25	; 0x09
     9d0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9d2:	ed 81       	ldd	r30, Y+5	; 0x05
     9d4:	fe 81       	ldd	r31, Y+6	; 0x06
     9d6:	80 81       	ld	r24, Z
     9d8:	8f 5f       	subi	r24, 0xFF	; 255
     9da:	ed 81       	ldd	r30, Y+5	; 0x05
     9dc:	fe 81       	ldd	r31, Y+6	; 0x06
     9de:	80 83       	st	Z, r24
}
     9e0:	28 96       	adiw	r28, 0x08	; 8
     9e2:	0f b6       	in	r0, 0x3f	; 63
     9e4:	f8 94       	cli
     9e6:	de bf       	out	0x3e, r29	; 62
     9e8:	0f be       	out	0x3f, r0	; 63
     9ea:	cd bf       	out	0x3d, r28	; 61
     9ec:	cf 91       	pop	r28
     9ee:	df 91       	pop	r29
     9f0:	08 95       	ret

000009f2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     9f2:	df 93       	push	r29
     9f4:	cf 93       	push	r28
     9f6:	00 d0       	rcall	.+0      	; 0x9f8 <uxListRemove+0x6>
     9f8:	00 d0       	rcall	.+0      	; 0x9fa <uxListRemove+0x8>
     9fa:	cd b7       	in	r28, 0x3d	; 61
     9fc:	de b7       	in	r29, 0x3e	; 62
     9fe:	9c 83       	std	Y+4, r25	; 0x04
     a00:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     a02:	eb 81       	ldd	r30, Y+3	; 0x03
     a04:	fc 81       	ldd	r31, Y+4	; 0x04
     a06:	80 85       	ldd	r24, Z+8	; 0x08
     a08:	91 85       	ldd	r25, Z+9	; 0x09
     a0a:	9a 83       	std	Y+2, r25	; 0x02
     a0c:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a0e:	eb 81       	ldd	r30, Y+3	; 0x03
     a10:	fc 81       	ldd	r31, Y+4	; 0x04
     a12:	a2 81       	ldd	r26, Z+2	; 0x02
     a14:	b3 81       	ldd	r27, Z+3	; 0x03
     a16:	eb 81       	ldd	r30, Y+3	; 0x03
     a18:	fc 81       	ldd	r31, Y+4	; 0x04
     a1a:	84 81       	ldd	r24, Z+4	; 0x04
     a1c:	95 81       	ldd	r25, Z+5	; 0x05
     a1e:	15 96       	adiw	r26, 0x05	; 5
     a20:	9c 93       	st	X, r25
     a22:	8e 93       	st	-X, r24
     a24:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a26:	eb 81       	ldd	r30, Y+3	; 0x03
     a28:	fc 81       	ldd	r31, Y+4	; 0x04
     a2a:	a4 81       	ldd	r26, Z+4	; 0x04
     a2c:	b5 81       	ldd	r27, Z+5	; 0x05
     a2e:	eb 81       	ldd	r30, Y+3	; 0x03
     a30:	fc 81       	ldd	r31, Y+4	; 0x04
     a32:	82 81       	ldd	r24, Z+2	; 0x02
     a34:	93 81       	ldd	r25, Z+3	; 0x03
     a36:	13 96       	adiw	r26, 0x03	; 3
     a38:	9c 93       	st	X, r25
     a3a:	8e 93       	st	-X, r24
     a3c:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a3e:	e9 81       	ldd	r30, Y+1	; 0x01
     a40:	fa 81       	ldd	r31, Y+2	; 0x02
     a42:	21 81       	ldd	r18, Z+1	; 0x01
     a44:	32 81       	ldd	r19, Z+2	; 0x02
     a46:	8b 81       	ldd	r24, Y+3	; 0x03
     a48:	9c 81       	ldd	r25, Y+4	; 0x04
     a4a:	28 17       	cp	r18, r24
     a4c:	39 07       	cpc	r19, r25
     a4e:	41 f4       	brne	.+16     	; 0xa60 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a50:	eb 81       	ldd	r30, Y+3	; 0x03
     a52:	fc 81       	ldd	r31, Y+4	; 0x04
     a54:	84 81       	ldd	r24, Z+4	; 0x04
     a56:	95 81       	ldd	r25, Z+5	; 0x05
     a58:	e9 81       	ldd	r30, Y+1	; 0x01
     a5a:	fa 81       	ldd	r31, Y+2	; 0x02
     a5c:	92 83       	std	Z+2, r25	; 0x02
     a5e:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     a60:	eb 81       	ldd	r30, Y+3	; 0x03
     a62:	fc 81       	ldd	r31, Y+4	; 0x04
     a64:	11 86       	std	Z+9, r1	; 0x09
     a66:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a68:	e9 81       	ldd	r30, Y+1	; 0x01
     a6a:	fa 81       	ldd	r31, Y+2	; 0x02
     a6c:	80 81       	ld	r24, Z
     a6e:	81 50       	subi	r24, 0x01	; 1
     a70:	e9 81       	ldd	r30, Y+1	; 0x01
     a72:	fa 81       	ldd	r31, Y+2	; 0x02
     a74:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
     a76:	e9 81       	ldd	r30, Y+1	; 0x01
     a78:	fa 81       	ldd	r31, Y+2	; 0x02
     a7a:	80 81       	ld	r24, Z
}
     a7c:	0f 90       	pop	r0
     a7e:	0f 90       	pop	r0
     a80:	0f 90       	pop	r0
     a82:	0f 90       	pop	r0
     a84:	cf 91       	pop	r28
     a86:	df 91       	pop	r29
     a88:	08 95       	ret

00000a8a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     a8a:	df 93       	push	r29
     a8c:	cf 93       	push	r28
     a8e:	cd b7       	in	r28, 0x3d	; 61
     a90:	de b7       	in	r29, 0x3e	; 62
     a92:	28 97       	sbiw	r28, 0x08	; 8
     a94:	0f b6       	in	r0, 0x3f	; 63
     a96:	f8 94       	cli
     a98:	de bf       	out	0x3e, r29	; 62
     a9a:	0f be       	out	0x3f, r0	; 63
     a9c:	cd bf       	out	0x3d, r28	; 61
     a9e:	9c 83       	std	Y+4, r25	; 0x04
     aa0:	8b 83       	std	Y+3, r24	; 0x03
     aa2:	7e 83       	std	Y+6, r23	; 0x06
     aa4:	6d 83       	std	Y+5, r22	; 0x05
     aa6:	58 87       	std	Y+8, r21	; 0x08
     aa8:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     aaa:	eb 81       	ldd	r30, Y+3	; 0x03
     aac:	fc 81       	ldd	r31, Y+4	; 0x04
     aae:	81 e1       	ldi	r24, 0x11	; 17
     ab0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ab2:	8b 81       	ldd	r24, Y+3	; 0x03
     ab4:	9c 81       	ldd	r25, Y+4	; 0x04
     ab6:	01 97       	sbiw	r24, 0x01	; 1
     ab8:	9c 83       	std	Y+4, r25	; 0x04
     aba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     abc:	eb 81       	ldd	r30, Y+3	; 0x03
     abe:	fc 81       	ldd	r31, Y+4	; 0x04
     ac0:	82 e2       	ldi	r24, 0x22	; 34
     ac2:	80 83       	st	Z, r24
	pxTopOfStack--;
     ac4:	8b 81       	ldd	r24, Y+3	; 0x03
     ac6:	9c 81       	ldd	r25, Y+4	; 0x04
     ac8:	01 97       	sbiw	r24, 0x01	; 1
     aca:	9c 83       	std	Y+4, r25	; 0x04
     acc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     ace:	eb 81       	ldd	r30, Y+3	; 0x03
     ad0:	fc 81       	ldd	r31, Y+4	; 0x04
     ad2:	83 e3       	ldi	r24, 0x33	; 51
     ad4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ad6:	8b 81       	ldd	r24, Y+3	; 0x03
     ad8:	9c 81       	ldd	r25, Y+4	; 0x04
     ada:	01 97       	sbiw	r24, 0x01	; 1
     adc:	9c 83       	std	Y+4, r25	; 0x04
     ade:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     ae0:	8d 81       	ldd	r24, Y+5	; 0x05
     ae2:	9e 81       	ldd	r25, Y+6	; 0x06
     ae4:	9a 83       	std	Y+2, r25	; 0x02
     ae6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ae8:	89 81       	ldd	r24, Y+1	; 0x01
     aea:	eb 81       	ldd	r30, Y+3	; 0x03
     aec:	fc 81       	ldd	r31, Y+4	; 0x04
     aee:	80 83       	st	Z, r24
	pxTopOfStack--;
     af0:	8b 81       	ldd	r24, Y+3	; 0x03
     af2:	9c 81       	ldd	r25, Y+4	; 0x04
     af4:	01 97       	sbiw	r24, 0x01	; 1
     af6:	9c 83       	std	Y+4, r25	; 0x04
     af8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     afa:	89 81       	ldd	r24, Y+1	; 0x01
     afc:	9a 81       	ldd	r25, Y+2	; 0x02
     afe:	89 2f       	mov	r24, r25
     b00:	99 27       	eor	r25, r25
     b02:	9a 83       	std	Y+2, r25	; 0x02
     b04:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     b06:	89 81       	ldd	r24, Y+1	; 0x01
     b08:	eb 81       	ldd	r30, Y+3	; 0x03
     b0a:	fc 81       	ldd	r31, Y+4	; 0x04
     b0c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b0e:	8b 81       	ldd	r24, Y+3	; 0x03
     b10:	9c 81       	ldd	r25, Y+4	; 0x04
     b12:	01 97       	sbiw	r24, 0x01	; 1
     b14:	9c 83       	std	Y+4, r25	; 0x04
     b16:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     b18:	eb 81       	ldd	r30, Y+3	; 0x03
     b1a:	fc 81       	ldd	r31, Y+4	; 0x04
     b1c:	10 82       	st	Z, r1
	pxTopOfStack--;
     b1e:	8b 81       	ldd	r24, Y+3	; 0x03
     b20:	9c 81       	ldd	r25, Y+4	; 0x04
     b22:	01 97       	sbiw	r24, 0x01	; 1
     b24:	9c 83       	std	Y+4, r25	; 0x04
     b26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     b28:	eb 81       	ldd	r30, Y+3	; 0x03
     b2a:	fc 81       	ldd	r31, Y+4	; 0x04
     b2c:	80 e8       	ldi	r24, 0x80	; 128
     b2e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b30:	8b 81       	ldd	r24, Y+3	; 0x03
     b32:	9c 81       	ldd	r25, Y+4	; 0x04
     b34:	01 97       	sbiw	r24, 0x01	; 1
     b36:	9c 83       	std	Y+4, r25	; 0x04
     b38:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     b3a:	eb 81       	ldd	r30, Y+3	; 0x03
     b3c:	fc 81       	ldd	r31, Y+4	; 0x04
     b3e:	10 82       	st	Z, r1
	pxTopOfStack--;
     b40:	8b 81       	ldd	r24, Y+3	; 0x03
     b42:	9c 81       	ldd	r25, Y+4	; 0x04
     b44:	01 97       	sbiw	r24, 0x01	; 1
     b46:	9c 83       	std	Y+4, r25	; 0x04
     b48:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     b4a:	eb 81       	ldd	r30, Y+3	; 0x03
     b4c:	fc 81       	ldd	r31, Y+4	; 0x04
     b4e:	82 e0       	ldi	r24, 0x02	; 2
     b50:	80 83       	st	Z, r24
	pxTopOfStack--;
     b52:	8b 81       	ldd	r24, Y+3	; 0x03
     b54:	9c 81       	ldd	r25, Y+4	; 0x04
     b56:	01 97       	sbiw	r24, 0x01	; 1
     b58:	9c 83       	std	Y+4, r25	; 0x04
     b5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     b5c:	eb 81       	ldd	r30, Y+3	; 0x03
     b5e:	fc 81       	ldd	r31, Y+4	; 0x04
     b60:	83 e0       	ldi	r24, 0x03	; 3
     b62:	80 83       	st	Z, r24
	pxTopOfStack--;
     b64:	8b 81       	ldd	r24, Y+3	; 0x03
     b66:	9c 81       	ldd	r25, Y+4	; 0x04
     b68:	01 97       	sbiw	r24, 0x01	; 1
     b6a:	9c 83       	std	Y+4, r25	; 0x04
     b6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     b6e:	eb 81       	ldd	r30, Y+3	; 0x03
     b70:	fc 81       	ldd	r31, Y+4	; 0x04
     b72:	84 e0       	ldi	r24, 0x04	; 4
     b74:	80 83       	st	Z, r24
	pxTopOfStack--;
     b76:	8b 81       	ldd	r24, Y+3	; 0x03
     b78:	9c 81       	ldd	r25, Y+4	; 0x04
     b7a:	01 97       	sbiw	r24, 0x01	; 1
     b7c:	9c 83       	std	Y+4, r25	; 0x04
     b7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     b80:	eb 81       	ldd	r30, Y+3	; 0x03
     b82:	fc 81       	ldd	r31, Y+4	; 0x04
     b84:	85 e0       	ldi	r24, 0x05	; 5
     b86:	80 83       	st	Z, r24
	pxTopOfStack--;
     b88:	8b 81       	ldd	r24, Y+3	; 0x03
     b8a:	9c 81       	ldd	r25, Y+4	; 0x04
     b8c:	01 97       	sbiw	r24, 0x01	; 1
     b8e:	9c 83       	std	Y+4, r25	; 0x04
     b90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     b92:	eb 81       	ldd	r30, Y+3	; 0x03
     b94:	fc 81       	ldd	r31, Y+4	; 0x04
     b96:	86 e0       	ldi	r24, 0x06	; 6
     b98:	80 83       	st	Z, r24
	pxTopOfStack--;
     b9a:	8b 81       	ldd	r24, Y+3	; 0x03
     b9c:	9c 81       	ldd	r25, Y+4	; 0x04
     b9e:	01 97       	sbiw	r24, 0x01	; 1
     ba0:	9c 83       	std	Y+4, r25	; 0x04
     ba2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     ba4:	eb 81       	ldd	r30, Y+3	; 0x03
     ba6:	fc 81       	ldd	r31, Y+4	; 0x04
     ba8:	87 e0       	ldi	r24, 0x07	; 7
     baa:	80 83       	st	Z, r24
	pxTopOfStack--;
     bac:	8b 81       	ldd	r24, Y+3	; 0x03
     bae:	9c 81       	ldd	r25, Y+4	; 0x04
     bb0:	01 97       	sbiw	r24, 0x01	; 1
     bb2:	9c 83       	std	Y+4, r25	; 0x04
     bb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     bb6:	eb 81       	ldd	r30, Y+3	; 0x03
     bb8:	fc 81       	ldd	r31, Y+4	; 0x04
     bba:	88 e0       	ldi	r24, 0x08	; 8
     bbc:	80 83       	st	Z, r24
	pxTopOfStack--;
     bbe:	8b 81       	ldd	r24, Y+3	; 0x03
     bc0:	9c 81       	ldd	r25, Y+4	; 0x04
     bc2:	01 97       	sbiw	r24, 0x01	; 1
     bc4:	9c 83       	std	Y+4, r25	; 0x04
     bc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     bc8:	eb 81       	ldd	r30, Y+3	; 0x03
     bca:	fc 81       	ldd	r31, Y+4	; 0x04
     bcc:	89 e0       	ldi	r24, 0x09	; 9
     bce:	80 83       	st	Z, r24
	pxTopOfStack--;
     bd0:	8b 81       	ldd	r24, Y+3	; 0x03
     bd2:	9c 81       	ldd	r25, Y+4	; 0x04
     bd4:	01 97       	sbiw	r24, 0x01	; 1
     bd6:	9c 83       	std	Y+4, r25	; 0x04
     bd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     bda:	eb 81       	ldd	r30, Y+3	; 0x03
     bdc:	fc 81       	ldd	r31, Y+4	; 0x04
     bde:	80 e1       	ldi	r24, 0x10	; 16
     be0:	80 83       	st	Z, r24
	pxTopOfStack--;
     be2:	8b 81       	ldd	r24, Y+3	; 0x03
     be4:	9c 81       	ldd	r25, Y+4	; 0x04
     be6:	01 97       	sbiw	r24, 0x01	; 1
     be8:	9c 83       	std	Y+4, r25	; 0x04
     bea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     bec:	eb 81       	ldd	r30, Y+3	; 0x03
     bee:	fc 81       	ldd	r31, Y+4	; 0x04
     bf0:	81 e1       	ldi	r24, 0x11	; 17
     bf2:	80 83       	st	Z, r24
	pxTopOfStack--;
     bf4:	8b 81       	ldd	r24, Y+3	; 0x03
     bf6:	9c 81       	ldd	r25, Y+4	; 0x04
     bf8:	01 97       	sbiw	r24, 0x01	; 1
     bfa:	9c 83       	std	Y+4, r25	; 0x04
     bfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     bfe:	eb 81       	ldd	r30, Y+3	; 0x03
     c00:	fc 81       	ldd	r31, Y+4	; 0x04
     c02:	82 e1       	ldi	r24, 0x12	; 18
     c04:	80 83       	st	Z, r24
	pxTopOfStack--;
     c06:	8b 81       	ldd	r24, Y+3	; 0x03
     c08:	9c 81       	ldd	r25, Y+4	; 0x04
     c0a:	01 97       	sbiw	r24, 0x01	; 1
     c0c:	9c 83       	std	Y+4, r25	; 0x04
     c0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     c10:	eb 81       	ldd	r30, Y+3	; 0x03
     c12:	fc 81       	ldd	r31, Y+4	; 0x04
     c14:	83 e1       	ldi	r24, 0x13	; 19
     c16:	80 83       	st	Z, r24
	pxTopOfStack--;
     c18:	8b 81       	ldd	r24, Y+3	; 0x03
     c1a:	9c 81       	ldd	r25, Y+4	; 0x04
     c1c:	01 97       	sbiw	r24, 0x01	; 1
     c1e:	9c 83       	std	Y+4, r25	; 0x04
     c20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     c22:	eb 81       	ldd	r30, Y+3	; 0x03
     c24:	fc 81       	ldd	r31, Y+4	; 0x04
     c26:	84 e1       	ldi	r24, 0x14	; 20
     c28:	80 83       	st	Z, r24
	pxTopOfStack--;
     c2a:	8b 81       	ldd	r24, Y+3	; 0x03
     c2c:	9c 81       	ldd	r25, Y+4	; 0x04
     c2e:	01 97       	sbiw	r24, 0x01	; 1
     c30:	9c 83       	std	Y+4, r25	; 0x04
     c32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     c34:	eb 81       	ldd	r30, Y+3	; 0x03
     c36:	fc 81       	ldd	r31, Y+4	; 0x04
     c38:	85 e1       	ldi	r24, 0x15	; 21
     c3a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c3c:	8b 81       	ldd	r24, Y+3	; 0x03
     c3e:	9c 81       	ldd	r25, Y+4	; 0x04
     c40:	01 97       	sbiw	r24, 0x01	; 1
     c42:	9c 83       	std	Y+4, r25	; 0x04
     c44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     c46:	eb 81       	ldd	r30, Y+3	; 0x03
     c48:	fc 81       	ldd	r31, Y+4	; 0x04
     c4a:	86 e1       	ldi	r24, 0x16	; 22
     c4c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c4e:	8b 81       	ldd	r24, Y+3	; 0x03
     c50:	9c 81       	ldd	r25, Y+4	; 0x04
     c52:	01 97       	sbiw	r24, 0x01	; 1
     c54:	9c 83       	std	Y+4, r25	; 0x04
     c56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     c58:	eb 81       	ldd	r30, Y+3	; 0x03
     c5a:	fc 81       	ldd	r31, Y+4	; 0x04
     c5c:	87 e1       	ldi	r24, 0x17	; 23
     c5e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c60:	8b 81       	ldd	r24, Y+3	; 0x03
     c62:	9c 81       	ldd	r25, Y+4	; 0x04
     c64:	01 97       	sbiw	r24, 0x01	; 1
     c66:	9c 83       	std	Y+4, r25	; 0x04
     c68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     c6a:	eb 81       	ldd	r30, Y+3	; 0x03
     c6c:	fc 81       	ldd	r31, Y+4	; 0x04
     c6e:	88 e1       	ldi	r24, 0x18	; 24
     c70:	80 83       	st	Z, r24
	pxTopOfStack--;
     c72:	8b 81       	ldd	r24, Y+3	; 0x03
     c74:	9c 81       	ldd	r25, Y+4	; 0x04
     c76:	01 97       	sbiw	r24, 0x01	; 1
     c78:	9c 83       	std	Y+4, r25	; 0x04
     c7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     c7c:	eb 81       	ldd	r30, Y+3	; 0x03
     c7e:	fc 81       	ldd	r31, Y+4	; 0x04
     c80:	89 e1       	ldi	r24, 0x19	; 25
     c82:	80 83       	st	Z, r24
	pxTopOfStack--;
     c84:	8b 81       	ldd	r24, Y+3	; 0x03
     c86:	9c 81       	ldd	r25, Y+4	; 0x04
     c88:	01 97       	sbiw	r24, 0x01	; 1
     c8a:	9c 83       	std	Y+4, r25	; 0x04
     c8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     c8e:	eb 81       	ldd	r30, Y+3	; 0x03
     c90:	fc 81       	ldd	r31, Y+4	; 0x04
     c92:	80 e2       	ldi	r24, 0x20	; 32
     c94:	80 83       	st	Z, r24
	pxTopOfStack--;
     c96:	8b 81       	ldd	r24, Y+3	; 0x03
     c98:	9c 81       	ldd	r25, Y+4	; 0x04
     c9a:	01 97       	sbiw	r24, 0x01	; 1
     c9c:	9c 83       	std	Y+4, r25	; 0x04
     c9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     ca0:	eb 81       	ldd	r30, Y+3	; 0x03
     ca2:	fc 81       	ldd	r31, Y+4	; 0x04
     ca4:	81 e2       	ldi	r24, 0x21	; 33
     ca6:	80 83       	st	Z, r24
	pxTopOfStack--;
     ca8:	8b 81       	ldd	r24, Y+3	; 0x03
     caa:	9c 81       	ldd	r25, Y+4	; 0x04
     cac:	01 97       	sbiw	r24, 0x01	; 1
     cae:	9c 83       	std	Y+4, r25	; 0x04
     cb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     cb2:	eb 81       	ldd	r30, Y+3	; 0x03
     cb4:	fc 81       	ldd	r31, Y+4	; 0x04
     cb6:	82 e2       	ldi	r24, 0x22	; 34
     cb8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cba:	8b 81       	ldd	r24, Y+3	; 0x03
     cbc:	9c 81       	ldd	r25, Y+4	; 0x04
     cbe:	01 97       	sbiw	r24, 0x01	; 1
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     cc4:	eb 81       	ldd	r30, Y+3	; 0x03
     cc6:	fc 81       	ldd	r31, Y+4	; 0x04
     cc8:	83 e2       	ldi	r24, 0x23	; 35
     cca:	80 83       	st	Z, r24
	pxTopOfStack--;
     ccc:	8b 81       	ldd	r24, Y+3	; 0x03
     cce:	9c 81       	ldd	r25, Y+4	; 0x04
     cd0:	01 97       	sbiw	r24, 0x01	; 1
     cd2:	9c 83       	std	Y+4, r25	; 0x04
     cd4:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     cd6:	8f 81       	ldd	r24, Y+7	; 0x07
     cd8:	98 85       	ldd	r25, Y+8	; 0x08
     cda:	9a 83       	std	Y+2, r25	; 0x02
     cdc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     cde:	89 81       	ldd	r24, Y+1	; 0x01
     ce0:	eb 81       	ldd	r30, Y+3	; 0x03
     ce2:	fc 81       	ldd	r31, Y+4	; 0x04
     ce4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ce6:	8b 81       	ldd	r24, Y+3	; 0x03
     ce8:	9c 81       	ldd	r25, Y+4	; 0x04
     cea:	01 97       	sbiw	r24, 0x01	; 1
     cec:	9c 83       	std	Y+4, r25	; 0x04
     cee:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     cf0:	89 81       	ldd	r24, Y+1	; 0x01
     cf2:	9a 81       	ldd	r25, Y+2	; 0x02
     cf4:	89 2f       	mov	r24, r25
     cf6:	99 27       	eor	r25, r25
     cf8:	9a 83       	std	Y+2, r25	; 0x02
     cfa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     cfc:	89 81       	ldd	r24, Y+1	; 0x01
     cfe:	eb 81       	ldd	r30, Y+3	; 0x03
     d00:	fc 81       	ldd	r31, Y+4	; 0x04
     d02:	80 83       	st	Z, r24
	pxTopOfStack--;
     d04:	8b 81       	ldd	r24, Y+3	; 0x03
     d06:	9c 81       	ldd	r25, Y+4	; 0x04
     d08:	01 97       	sbiw	r24, 0x01	; 1
     d0a:	9c 83       	std	Y+4, r25	; 0x04
     d0c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     d0e:	eb 81       	ldd	r30, Y+3	; 0x03
     d10:	fc 81       	ldd	r31, Y+4	; 0x04
     d12:	86 e2       	ldi	r24, 0x26	; 38
     d14:	80 83       	st	Z, r24
	pxTopOfStack--;
     d16:	8b 81       	ldd	r24, Y+3	; 0x03
     d18:	9c 81       	ldd	r25, Y+4	; 0x04
     d1a:	01 97       	sbiw	r24, 0x01	; 1
     d1c:	9c 83       	std	Y+4, r25	; 0x04
     d1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     d20:	eb 81       	ldd	r30, Y+3	; 0x03
     d22:	fc 81       	ldd	r31, Y+4	; 0x04
     d24:	87 e2       	ldi	r24, 0x27	; 39
     d26:	80 83       	st	Z, r24
	pxTopOfStack--;
     d28:	8b 81       	ldd	r24, Y+3	; 0x03
     d2a:	9c 81       	ldd	r25, Y+4	; 0x04
     d2c:	01 97       	sbiw	r24, 0x01	; 1
     d2e:	9c 83       	std	Y+4, r25	; 0x04
     d30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     d32:	eb 81       	ldd	r30, Y+3	; 0x03
     d34:	fc 81       	ldd	r31, Y+4	; 0x04
     d36:	88 e2       	ldi	r24, 0x28	; 40
     d38:	80 83       	st	Z, r24
	pxTopOfStack--;
     d3a:	8b 81       	ldd	r24, Y+3	; 0x03
     d3c:	9c 81       	ldd	r25, Y+4	; 0x04
     d3e:	01 97       	sbiw	r24, 0x01	; 1
     d40:	9c 83       	std	Y+4, r25	; 0x04
     d42:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     d44:	eb 81       	ldd	r30, Y+3	; 0x03
     d46:	fc 81       	ldd	r31, Y+4	; 0x04
     d48:	89 e2       	ldi	r24, 0x29	; 41
     d4a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d4c:	8b 81       	ldd	r24, Y+3	; 0x03
     d4e:	9c 81       	ldd	r25, Y+4	; 0x04
     d50:	01 97       	sbiw	r24, 0x01	; 1
     d52:	9c 83       	std	Y+4, r25	; 0x04
     d54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     d56:	eb 81       	ldd	r30, Y+3	; 0x03
     d58:	fc 81       	ldd	r31, Y+4	; 0x04
     d5a:	80 e3       	ldi	r24, 0x30	; 48
     d5c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d5e:	8b 81       	ldd	r24, Y+3	; 0x03
     d60:	9c 81       	ldd	r25, Y+4	; 0x04
     d62:	01 97       	sbiw	r24, 0x01	; 1
     d64:	9c 83       	std	Y+4, r25	; 0x04
     d66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     d68:	eb 81       	ldd	r30, Y+3	; 0x03
     d6a:	fc 81       	ldd	r31, Y+4	; 0x04
     d6c:	81 e3       	ldi	r24, 0x31	; 49
     d6e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d70:	8b 81       	ldd	r24, Y+3	; 0x03
     d72:	9c 81       	ldd	r25, Y+4	; 0x04
     d74:	01 97       	sbiw	r24, 0x01	; 1
     d76:	9c 83       	std	Y+4, r25	; 0x04
     d78:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d7a:	8b 81       	ldd	r24, Y+3	; 0x03
     d7c:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d7e:	28 96       	adiw	r28, 0x08	; 8
     d80:	0f b6       	in	r0, 0x3f	; 63
     d82:	f8 94       	cli
     d84:	de bf       	out	0x3e, r29	; 62
     d86:	0f be       	out	0x3f, r0	; 63
     d88:	cd bf       	out	0x3d, r28	; 61
     d8a:	cf 91       	pop	r28
     d8c:	df 91       	pop	r29
     d8e:	08 95       	ret

00000d90 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     d90:	df 93       	push	r29
     d92:	cf 93       	push	r28
     d94:	cd b7       	in	r28, 0x3d	; 61
     d96:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     d98:	0e 94 ba 07 	call	0xf74	; 0xf74 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d9c:	a0 91 da 02 	lds	r26, 0x02DA
     da0:	b0 91 db 02 	lds	r27, 0x02DB
     da4:	cd 91       	ld	r28, X+
     da6:	cd bf       	out	0x3d, r28	; 61
     da8:	dd 91       	ld	r29, X+
     daa:	de bf       	out	0x3e, r29	; 62
     dac:	ff 91       	pop	r31
     dae:	ef 91       	pop	r30
     db0:	df 91       	pop	r29
     db2:	cf 91       	pop	r28
     db4:	bf 91       	pop	r27
     db6:	af 91       	pop	r26
     db8:	9f 91       	pop	r25
     dba:	8f 91       	pop	r24
     dbc:	7f 91       	pop	r23
     dbe:	6f 91       	pop	r22
     dc0:	5f 91       	pop	r21
     dc2:	4f 91       	pop	r20
     dc4:	3f 91       	pop	r19
     dc6:	2f 91       	pop	r18
     dc8:	1f 91       	pop	r17
     dca:	0f 91       	pop	r16
     dcc:	ff 90       	pop	r15
     dce:	ef 90       	pop	r14
     dd0:	df 90       	pop	r13
     dd2:	cf 90       	pop	r12
     dd4:	bf 90       	pop	r11
     dd6:	af 90       	pop	r10
     dd8:	9f 90       	pop	r9
     dda:	8f 90       	pop	r8
     ddc:	7f 90       	pop	r7
     dde:	6f 90       	pop	r6
     de0:	5f 90       	pop	r5
     de2:	4f 90       	pop	r4
     de4:	3f 90       	pop	r3
     de6:	2f 90       	pop	r2
     de8:	1f 90       	pop	r1
     dea:	0f 90       	pop	r0
     dec:	0f be       	out	0x3f, r0	; 63
     dee:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     df0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     df2:	81 e0       	ldi	r24, 0x01	; 1
}
     df4:	cf 91       	pop	r28
     df6:	df 91       	pop	r29
     df8:	08 95       	ret

00000dfa <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     dfa:	df 93       	push	r29
     dfc:	cf 93       	push	r28
     dfe:	cd b7       	in	r28, 0x3d	; 61
     e00:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     e02:	cf 91       	pop	r28
     e04:	df 91       	pop	r29
     e06:	08 95       	ret

00000e08 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e08:	0f 92       	push	r0
     e0a:	0f b6       	in	r0, 0x3f	; 63
     e0c:	f8 94       	cli
     e0e:	0f 92       	push	r0
     e10:	1f 92       	push	r1
     e12:	11 24       	eor	r1, r1
     e14:	2f 92       	push	r2
     e16:	3f 92       	push	r3
     e18:	4f 92       	push	r4
     e1a:	5f 92       	push	r5
     e1c:	6f 92       	push	r6
     e1e:	7f 92       	push	r7
     e20:	8f 92       	push	r8
     e22:	9f 92       	push	r9
     e24:	af 92       	push	r10
     e26:	bf 92       	push	r11
     e28:	cf 92       	push	r12
     e2a:	df 92       	push	r13
     e2c:	ef 92       	push	r14
     e2e:	ff 92       	push	r15
     e30:	0f 93       	push	r16
     e32:	1f 93       	push	r17
     e34:	2f 93       	push	r18
     e36:	3f 93       	push	r19
     e38:	4f 93       	push	r20
     e3a:	5f 93       	push	r21
     e3c:	6f 93       	push	r22
     e3e:	7f 93       	push	r23
     e40:	8f 93       	push	r24
     e42:	9f 93       	push	r25
     e44:	af 93       	push	r26
     e46:	bf 93       	push	r27
     e48:	cf 93       	push	r28
     e4a:	df 93       	push	r29
     e4c:	ef 93       	push	r30
     e4e:	ff 93       	push	r31
     e50:	a0 91 da 02 	lds	r26, 0x02DA
     e54:	b0 91 db 02 	lds	r27, 0x02DB
     e58:	0d b6       	in	r0, 0x3d	; 61
     e5a:	0d 92       	st	X+, r0
     e5c:	0e b6       	in	r0, 0x3e	; 62
     e5e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e60:	0e 94 0c 14 	call	0x2818	; 0x2818 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e64:	a0 91 da 02 	lds	r26, 0x02DA
     e68:	b0 91 db 02 	lds	r27, 0x02DB
     e6c:	cd 91       	ld	r28, X+
     e6e:	cd bf       	out	0x3d, r28	; 61
     e70:	dd 91       	ld	r29, X+
     e72:	de bf       	out	0x3e, r29	; 62
     e74:	ff 91       	pop	r31
     e76:	ef 91       	pop	r30
     e78:	df 91       	pop	r29
     e7a:	cf 91       	pop	r28
     e7c:	bf 91       	pop	r27
     e7e:	af 91       	pop	r26
     e80:	9f 91       	pop	r25
     e82:	8f 91       	pop	r24
     e84:	7f 91       	pop	r23
     e86:	6f 91       	pop	r22
     e88:	5f 91       	pop	r21
     e8a:	4f 91       	pop	r20
     e8c:	3f 91       	pop	r19
     e8e:	2f 91       	pop	r18
     e90:	1f 91       	pop	r17
     e92:	0f 91       	pop	r16
     e94:	ff 90       	pop	r15
     e96:	ef 90       	pop	r14
     e98:	df 90       	pop	r13
     e9a:	cf 90       	pop	r12
     e9c:	bf 90       	pop	r11
     e9e:	af 90       	pop	r10
     ea0:	9f 90       	pop	r9
     ea2:	8f 90       	pop	r8
     ea4:	7f 90       	pop	r7
     ea6:	6f 90       	pop	r6
     ea8:	5f 90       	pop	r5
     eaa:	4f 90       	pop	r4
     eac:	3f 90       	pop	r3
     eae:	2f 90       	pop	r2
     eb0:	1f 90       	pop	r1
     eb2:	0f 90       	pop	r0
     eb4:	0f be       	out	0x3f, r0	; 63
     eb6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     eb8:	08 95       	ret

00000eba <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     eba:	0f 92       	push	r0
     ebc:	0f b6       	in	r0, 0x3f	; 63
     ebe:	f8 94       	cli
     ec0:	0f 92       	push	r0
     ec2:	1f 92       	push	r1
     ec4:	11 24       	eor	r1, r1
     ec6:	2f 92       	push	r2
     ec8:	3f 92       	push	r3
     eca:	4f 92       	push	r4
     ecc:	5f 92       	push	r5
     ece:	6f 92       	push	r6
     ed0:	7f 92       	push	r7
     ed2:	8f 92       	push	r8
     ed4:	9f 92       	push	r9
     ed6:	af 92       	push	r10
     ed8:	bf 92       	push	r11
     eda:	cf 92       	push	r12
     edc:	df 92       	push	r13
     ede:	ef 92       	push	r14
     ee0:	ff 92       	push	r15
     ee2:	0f 93       	push	r16
     ee4:	1f 93       	push	r17
     ee6:	2f 93       	push	r18
     ee8:	3f 93       	push	r19
     eea:	4f 93       	push	r20
     eec:	5f 93       	push	r21
     eee:	6f 93       	push	r22
     ef0:	7f 93       	push	r23
     ef2:	8f 93       	push	r24
     ef4:	9f 93       	push	r25
     ef6:	af 93       	push	r26
     ef8:	bf 93       	push	r27
     efa:	cf 93       	push	r28
     efc:	df 93       	push	r29
     efe:	ef 93       	push	r30
     f00:	ff 93       	push	r31
     f02:	a0 91 da 02 	lds	r26, 0x02DA
     f06:	b0 91 db 02 	lds	r27, 0x02DB
     f0a:	0d b6       	in	r0, 0x3d	; 61
     f0c:	0d 92       	st	X+, r0
     f0e:	0e b6       	in	r0, 0x3e	; 62
     f10:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f12:	0e 94 27 13 	call	0x264e	; 0x264e <xTaskIncrementTick>
     f16:	88 23       	and	r24, r24
     f18:	11 f0       	breq	.+4      	; 0xf1e <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     f1a:	0e 94 0c 14 	call	0x2818	; 0x2818 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f1e:	a0 91 da 02 	lds	r26, 0x02DA
     f22:	b0 91 db 02 	lds	r27, 0x02DB
     f26:	cd 91       	ld	r28, X+
     f28:	cd bf       	out	0x3d, r28	; 61
     f2a:	dd 91       	ld	r29, X+
     f2c:	de bf       	out	0x3e, r29	; 62
     f2e:	ff 91       	pop	r31
     f30:	ef 91       	pop	r30
     f32:	df 91       	pop	r29
     f34:	cf 91       	pop	r28
     f36:	bf 91       	pop	r27
     f38:	af 91       	pop	r26
     f3a:	9f 91       	pop	r25
     f3c:	8f 91       	pop	r24
     f3e:	7f 91       	pop	r23
     f40:	6f 91       	pop	r22
     f42:	5f 91       	pop	r21
     f44:	4f 91       	pop	r20
     f46:	3f 91       	pop	r19
     f48:	2f 91       	pop	r18
     f4a:	1f 91       	pop	r17
     f4c:	0f 91       	pop	r16
     f4e:	ff 90       	pop	r15
     f50:	ef 90       	pop	r14
     f52:	df 90       	pop	r13
     f54:	cf 90       	pop	r12
     f56:	bf 90       	pop	r11
     f58:	af 90       	pop	r10
     f5a:	9f 90       	pop	r9
     f5c:	8f 90       	pop	r8
     f5e:	7f 90       	pop	r7
     f60:	6f 90       	pop	r6
     f62:	5f 90       	pop	r5
     f64:	4f 90       	pop	r4
     f66:	3f 90       	pop	r3
     f68:	2f 90       	pop	r2
     f6a:	1f 90       	pop	r1
     f6c:	0f 90       	pop	r0
     f6e:	0f be       	out	0x3f, r0	; 63
     f70:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f72:	08 95       	ret

00000f74 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f74:	df 93       	push	r29
     f76:	cf 93       	push	r28
     f78:	00 d0       	rcall	.+0      	; 0xf7a <prvSetupTimerInterrupt+0x6>
     f7a:	00 d0       	rcall	.+0      	; 0xf7c <prvSetupTimerInterrupt+0x8>
     f7c:	00 d0       	rcall	.+0      	; 0xf7e <prvSetupTimerInterrupt+0xa>
     f7e:	cd b7       	in	r28, 0x3d	; 61
     f80:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     f82:	80 e4       	ldi	r24, 0x40	; 64
     f84:	9f e1       	ldi	r25, 0x1F	; 31
     f86:	a0 e0       	ldi	r26, 0x00	; 0
     f88:	b0 e0       	ldi	r27, 0x00	; 0
     f8a:	8b 83       	std	Y+3, r24	; 0x03
     f8c:	9c 83       	std	Y+4, r25	; 0x04
     f8e:	ad 83       	std	Y+5, r26	; 0x05
     f90:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     f92:	8b 81       	ldd	r24, Y+3	; 0x03
     f94:	9c 81       	ldd	r25, Y+4	; 0x04
     f96:	ad 81       	ldd	r26, Y+5	; 0x05
     f98:	be 81       	ldd	r27, Y+6	; 0x06
     f9a:	68 94       	set
     f9c:	15 f8       	bld	r1, 5
     f9e:	b6 95       	lsr	r27
     fa0:	a7 95       	ror	r26
     fa2:	97 95       	ror	r25
     fa4:	87 95       	ror	r24
     fa6:	16 94       	lsr	r1
     fa8:	d1 f7       	brne	.-12     	; 0xf9e <prvSetupTimerInterrupt+0x2a>
     faa:	8b 83       	std	Y+3, r24	; 0x03
     fac:	9c 83       	std	Y+4, r25	; 0x04
     fae:	ad 83       	std	Y+5, r26	; 0x05
     fb0:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     fb2:	8b 81       	ldd	r24, Y+3	; 0x03
     fb4:	9c 81       	ldd	r25, Y+4	; 0x04
     fb6:	ad 81       	ldd	r26, Y+5	; 0x05
     fb8:	be 81       	ldd	r27, Y+6	; 0x06
     fba:	01 97       	sbiw	r24, 0x01	; 1
     fbc:	a1 09       	sbc	r26, r1
     fbe:	b1 09       	sbc	r27, r1
     fc0:	8b 83       	std	Y+3, r24	; 0x03
     fc2:	9c 83       	std	Y+4, r25	; 0x04
     fc4:	ad 83       	std	Y+5, r26	; 0x05
     fc6:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     fc8:	8b 81       	ldd	r24, Y+3	; 0x03
     fca:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     fcc:	8b 81       	ldd	r24, Y+3	; 0x03
     fce:	9c 81       	ldd	r25, Y+4	; 0x04
     fd0:	ad 81       	ldd	r26, Y+5	; 0x05
     fd2:	be 81       	ldd	r27, Y+6	; 0x06
     fd4:	89 2f       	mov	r24, r25
     fd6:	9a 2f       	mov	r25, r26
     fd8:	ab 2f       	mov	r26, r27
     fda:	bb 27       	eor	r27, r27
     fdc:	8b 83       	std	Y+3, r24	; 0x03
     fde:	9c 83       	std	Y+4, r25	; 0x04
     fe0:	ad 83       	std	Y+5, r26	; 0x05
     fe2:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     fe4:	8b 81       	ldd	r24, Y+3	; 0x03
     fe6:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     fe8:	eb e4       	ldi	r30, 0x4B	; 75
     fea:	f0 e0       	ldi	r31, 0x00	; 0
     fec:	8a 81       	ldd	r24, Y+2	; 0x02
     fee:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     ff0:	ea e4       	ldi	r30, 0x4A	; 74
     ff2:	f0 e0       	ldi	r31, 0x00	; 0
     ff4:	89 81       	ldd	r24, Y+1	; 0x01
     ff6:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     ff8:	8b e0       	ldi	r24, 0x0B	; 11
     ffa:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     ffc:	ee e4       	ldi	r30, 0x4E	; 78
     ffe:	f0 e0       	ldi	r31, 0x00	; 0
    1000:	89 81       	ldd	r24, Y+1	; 0x01
    1002:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1004:	e9 e5       	ldi	r30, 0x59	; 89
    1006:	f0 e0       	ldi	r31, 0x00	; 0
    1008:	80 81       	ld	r24, Z
    100a:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    100c:	89 81       	ldd	r24, Y+1	; 0x01
    100e:	80 61       	ori	r24, 0x10	; 16
    1010:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1012:	e9 e5       	ldi	r30, 0x59	; 89
    1014:	f0 e0       	ldi	r31, 0x00	; 0
    1016:	89 81       	ldd	r24, Y+1	; 0x01
    1018:	80 83       	st	Z, r24
}
    101a:	26 96       	adiw	r28, 0x06	; 6
    101c:	0f b6       	in	r0, 0x3f	; 63
    101e:	f8 94       	cli
    1020:	de bf       	out	0x3e, r29	; 62
    1022:	0f be       	out	0x3f, r0	; 63
    1024:	cd bf       	out	0x3d, r28	; 61
    1026:	cf 91       	pop	r28
    1028:	df 91       	pop	r29
    102a:	08 95       	ret

0000102c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    102c:	0e 94 5d 07 	call	0xeba	; 0xeba <vPortYieldFromTick>
		asm volatile ( "reti" );
    1030:	18 95       	reti

00001032 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1032:	df 93       	push	r29
    1034:	cf 93       	push	r28
    1036:	00 d0       	rcall	.+0      	; 0x1038 <xQueueGenericReset+0x6>
    1038:	00 d0       	rcall	.+0      	; 0x103a <xQueueGenericReset+0x8>
    103a:	0f 92       	push	r0
    103c:	cd b7       	in	r28, 0x3d	; 61
    103e:	de b7       	in	r29, 0x3e	; 62
    1040:	9c 83       	std	Y+4, r25	; 0x04
    1042:	8b 83       	std	Y+3, r24	; 0x03
    1044:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1046:	8b 81       	ldd	r24, Y+3	; 0x03
    1048:	9c 81       	ldd	r25, Y+4	; 0x04
    104a:	9a 83       	std	Y+2, r25	; 0x02
    104c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1054:	e9 81       	ldd	r30, Y+1	; 0x01
    1056:	fa 81       	ldd	r31, Y+2	; 0x02
    1058:	40 81       	ld	r20, Z
    105a:	51 81       	ldd	r21, Z+1	; 0x01
    105c:	e9 81       	ldd	r30, Y+1	; 0x01
    105e:	fa 81       	ldd	r31, Y+2	; 0x02
    1060:	83 8d       	ldd	r24, Z+27	; 0x1b
    1062:	28 2f       	mov	r18, r24
    1064:	30 e0       	ldi	r19, 0x00	; 0
    1066:	e9 81       	ldd	r30, Y+1	; 0x01
    1068:	fa 81       	ldd	r31, Y+2	; 0x02
    106a:	84 8d       	ldd	r24, Z+28	; 0x1c
    106c:	88 2f       	mov	r24, r24
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	bc 01       	movw	r22, r24
    1072:	26 9f       	mul	r18, r22
    1074:	c0 01       	movw	r24, r0
    1076:	27 9f       	mul	r18, r23
    1078:	90 0d       	add	r25, r0
    107a:	36 9f       	mul	r19, r22
    107c:	90 0d       	add	r25, r0
    107e:	11 24       	eor	r1, r1
    1080:	84 0f       	add	r24, r20
    1082:	95 1f       	adc	r25, r21
    1084:	e9 81       	ldd	r30, Y+1	; 0x01
    1086:	fa 81       	ldd	r31, Y+2	; 0x02
    1088:	95 83       	std	Z+5, r25	; 0x05
    108a:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    108c:	e9 81       	ldd	r30, Y+1	; 0x01
    108e:	fa 81       	ldd	r31, Y+2	; 0x02
    1090:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1092:	e9 81       	ldd	r30, Y+1	; 0x01
    1094:	fa 81       	ldd	r31, Y+2	; 0x02
    1096:	80 81       	ld	r24, Z
    1098:	91 81       	ldd	r25, Z+1	; 0x01
    109a:	e9 81       	ldd	r30, Y+1	; 0x01
    109c:	fa 81       	ldd	r31, Y+2	; 0x02
    109e:	93 83       	std	Z+3, r25	; 0x03
    10a0:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    10a2:	e9 81       	ldd	r30, Y+1	; 0x01
    10a4:	fa 81       	ldd	r31, Y+2	; 0x02
    10a6:	40 81       	ld	r20, Z
    10a8:	51 81       	ldd	r21, Z+1	; 0x01
    10aa:	e9 81       	ldd	r30, Y+1	; 0x01
    10ac:	fa 81       	ldd	r31, Y+2	; 0x02
    10ae:	83 8d       	ldd	r24, Z+27	; 0x1b
    10b0:	88 2f       	mov	r24, r24
    10b2:	90 e0       	ldi	r25, 0x00	; 0
    10b4:	9c 01       	movw	r18, r24
    10b6:	21 50       	subi	r18, 0x01	; 1
    10b8:	30 40       	sbci	r19, 0x00	; 0
    10ba:	e9 81       	ldd	r30, Y+1	; 0x01
    10bc:	fa 81       	ldd	r31, Y+2	; 0x02
    10be:	84 8d       	ldd	r24, Z+28	; 0x1c
    10c0:	88 2f       	mov	r24, r24
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	bc 01       	movw	r22, r24
    10c6:	26 9f       	mul	r18, r22
    10c8:	c0 01       	movw	r24, r0
    10ca:	27 9f       	mul	r18, r23
    10cc:	90 0d       	add	r25, r0
    10ce:	36 9f       	mul	r19, r22
    10d0:	90 0d       	add	r25, r0
    10d2:	11 24       	eor	r1, r1
    10d4:	84 0f       	add	r24, r20
    10d6:	95 1f       	adc	r25, r21
    10d8:	e9 81       	ldd	r30, Y+1	; 0x01
    10da:	fa 81       	ldd	r31, Y+2	; 0x02
    10dc:	97 83       	std	Z+7, r25	; 0x07
    10de:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    10e0:	e9 81       	ldd	r30, Y+1	; 0x01
    10e2:	fa 81       	ldd	r31, Y+2	; 0x02
    10e4:	8f ef       	ldi	r24, 0xFF	; 255
    10e6:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    10e8:	e9 81       	ldd	r30, Y+1	; 0x01
    10ea:	fa 81       	ldd	r31, Y+2	; 0x02
    10ec:	8f ef       	ldi	r24, 0xFF	; 255
    10ee:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    10f0:	8d 81       	ldd	r24, Y+5	; 0x05
    10f2:	88 23       	and	r24, r24
    10f4:	79 f4       	brne	.+30     	; 0x1114 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10f6:	e9 81       	ldd	r30, Y+1	; 0x01
    10f8:	fa 81       	ldd	r31, Y+2	; 0x02
    10fa:	80 85       	ldd	r24, Z+8	; 0x08
    10fc:	88 23       	and	r24, r24
    10fe:	a1 f0       	breq	.+40     	; 0x1128 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1100:	89 81       	ldd	r24, Y+1	; 0x01
    1102:	9a 81       	ldd	r25, Y+2	; 0x02
    1104:	08 96       	adiw	r24, 0x08	; 8
    1106:	0e 94 cb 14 	call	0x2996	; 0x2996 <xTaskRemoveFromEventList>
    110a:	88 23       	and	r24, r24
    110c:	69 f0       	breq	.+26     	; 0x1128 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    110e:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
    1112:	0a c0       	rjmp	.+20     	; 0x1128 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1114:	89 81       	ldd	r24, Y+1	; 0x01
    1116:	9a 81       	ldd	r25, Y+2	; 0x02
    1118:	08 96       	adiw	r24, 0x08	; 8
    111a:	0e 94 0f 04 	call	0x81e	; 0x81e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    111e:	89 81       	ldd	r24, Y+1	; 0x01
    1120:	9a 81       	ldd	r25, Y+2	; 0x02
    1122:	41 96       	adiw	r24, 0x11	; 17
    1124:	0e 94 0f 04 	call	0x81e	; 0x81e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1128:	0f 90       	pop	r0
    112a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    112c:	81 e0       	ldi	r24, 0x01	; 1
}
    112e:	0f 90       	pop	r0
    1130:	0f 90       	pop	r0
    1132:	0f 90       	pop	r0
    1134:	0f 90       	pop	r0
    1136:	0f 90       	pop	r0
    1138:	cf 91       	pop	r28
    113a:	df 91       	pop	r29
    113c:	08 95       	ret

0000113e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    113e:	0f 93       	push	r16
    1140:	1f 93       	push	r17
    1142:	df 93       	push	r29
    1144:	cf 93       	push	r28
    1146:	cd b7       	in	r28, 0x3d	; 61
    1148:	de b7       	in	r29, 0x3e	; 62
    114a:	29 97       	sbiw	r28, 0x09	; 9
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	f8 94       	cli
    1150:	de bf       	out	0x3e, r29	; 62
    1152:	0f be       	out	0x3f, r0	; 63
    1154:	cd bf       	out	0x3d, r28	; 61
    1156:	8f 83       	std	Y+7, r24	; 0x07
    1158:	68 87       	std	Y+8, r22	; 0x08
    115a:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    115c:	88 85       	ldd	r24, Y+8	; 0x08
    115e:	88 23       	and	r24, r24
    1160:	19 f4       	brne	.+6      	; 0x1168 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1162:	1c 82       	std	Y+4, r1	; 0x04
    1164:	1b 82       	std	Y+3, r1	; 0x03
    1166:	10 c0       	rjmp	.+32     	; 0x1188 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1168:	8f 81       	ldd	r24, Y+7	; 0x07
    116a:	28 2f       	mov	r18, r24
    116c:	30 e0       	ldi	r19, 0x00	; 0
    116e:	88 85       	ldd	r24, Y+8	; 0x08
    1170:	88 2f       	mov	r24, r24
    1172:	90 e0       	ldi	r25, 0x00	; 0
    1174:	ac 01       	movw	r20, r24
    1176:	24 9f       	mul	r18, r20
    1178:	c0 01       	movw	r24, r0
    117a:	25 9f       	mul	r18, r21
    117c:	90 0d       	add	r25, r0
    117e:	34 9f       	mul	r19, r20
    1180:	90 0d       	add	r25, r0
    1182:	11 24       	eor	r1, r1
    1184:	9c 83       	std	Y+4, r25	; 0x04
    1186:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1188:	8b 81       	ldd	r24, Y+3	; 0x03
    118a:	9c 81       	ldd	r25, Y+4	; 0x04
    118c:	4f 96       	adiw	r24, 0x1f	; 31
    118e:	0e 94 93 03 	call	0x726	; 0x726 <pvPortMalloc>
    1192:	9e 83       	std	Y+6, r25	; 0x06
    1194:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1196:	8d 81       	ldd	r24, Y+5	; 0x05
    1198:	9e 81       	ldd	r25, Y+6	; 0x06
    119a:	00 97       	sbiw	r24, 0x00	; 0
    119c:	a1 f0       	breq	.+40     	; 0x11c6 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    119e:	8d 81       	ldd	r24, Y+5	; 0x05
    11a0:	9e 81       	ldd	r25, Y+6	; 0x06
    11a2:	9a 83       	std	Y+2, r25	; 0x02
    11a4:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    11a6:	89 81       	ldd	r24, Y+1	; 0x01
    11a8:	9a 81       	ldd	r25, Y+2	; 0x02
    11aa:	4f 96       	adiw	r24, 0x1f	; 31
    11ac:	9a 83       	std	Y+2, r25	; 0x02
    11ae:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    11b0:	29 81       	ldd	r18, Y+1	; 0x01
    11b2:	3a 81       	ldd	r19, Y+2	; 0x02
    11b4:	ed 81       	ldd	r30, Y+5	; 0x05
    11b6:	fe 81       	ldd	r31, Y+6	; 0x06
    11b8:	8f 81       	ldd	r24, Y+7	; 0x07
    11ba:	68 85       	ldd	r22, Y+8	; 0x08
    11bc:	a9 01       	movw	r20, r18
    11be:	29 85       	ldd	r18, Y+9	; 0x09
    11c0:	8f 01       	movw	r16, r30
    11c2:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    11c6:	8d 81       	ldd	r24, Y+5	; 0x05
    11c8:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    11ca:	29 96       	adiw	r28, 0x09	; 9
    11cc:	0f b6       	in	r0, 0x3f	; 63
    11ce:	f8 94       	cli
    11d0:	de bf       	out	0x3e, r29	; 62
    11d2:	0f be       	out	0x3f, r0	; 63
    11d4:	cd bf       	out	0x3d, r28	; 61
    11d6:	cf 91       	pop	r28
    11d8:	df 91       	pop	r29
    11da:	1f 91       	pop	r17
    11dc:	0f 91       	pop	r16
    11de:	08 95       	ret

000011e0 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    11e0:	0f 93       	push	r16
    11e2:	1f 93       	push	r17
    11e4:	df 93       	push	r29
    11e6:	cf 93       	push	r28
    11e8:	cd b7       	in	r28, 0x3d	; 61
    11ea:	de b7       	in	r29, 0x3e	; 62
    11ec:	27 97       	sbiw	r28, 0x07	; 7
    11ee:	0f b6       	in	r0, 0x3f	; 63
    11f0:	f8 94       	cli
    11f2:	de bf       	out	0x3e, r29	; 62
    11f4:	0f be       	out	0x3f, r0	; 63
    11f6:	cd bf       	out	0x3d, r28	; 61
    11f8:	89 83       	std	Y+1, r24	; 0x01
    11fa:	6a 83       	std	Y+2, r22	; 0x02
    11fc:	5c 83       	std	Y+4, r21	; 0x04
    11fe:	4b 83       	std	Y+3, r20	; 0x03
    1200:	2d 83       	std	Y+5, r18	; 0x05
    1202:	1f 83       	std	Y+7, r17	; 0x07
    1204:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1206:	8a 81       	ldd	r24, Y+2	; 0x02
    1208:	88 23       	and	r24, r24
    120a:	39 f4       	brne	.+14     	; 0x121a <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    120c:	8e 81       	ldd	r24, Y+6	; 0x06
    120e:	9f 81       	ldd	r25, Y+7	; 0x07
    1210:	ee 81       	ldd	r30, Y+6	; 0x06
    1212:	ff 81       	ldd	r31, Y+7	; 0x07
    1214:	91 83       	std	Z+1, r25	; 0x01
    1216:	80 83       	st	Z, r24
    1218:	06 c0       	rjmp	.+12     	; 0x1226 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    121a:	8b 81       	ldd	r24, Y+3	; 0x03
    121c:	9c 81       	ldd	r25, Y+4	; 0x04
    121e:	ee 81       	ldd	r30, Y+6	; 0x06
    1220:	ff 81       	ldd	r31, Y+7	; 0x07
    1222:	91 83       	std	Z+1, r25	; 0x01
    1224:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1226:	ee 81       	ldd	r30, Y+6	; 0x06
    1228:	ff 81       	ldd	r31, Y+7	; 0x07
    122a:	89 81       	ldd	r24, Y+1	; 0x01
    122c:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    122e:	ee 81       	ldd	r30, Y+6	; 0x06
    1230:	ff 81       	ldd	r31, Y+7	; 0x07
    1232:	8a 81       	ldd	r24, Y+2	; 0x02
    1234:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1236:	8e 81       	ldd	r24, Y+6	; 0x06
    1238:	9f 81       	ldd	r25, Y+7	; 0x07
    123a:	61 e0       	ldi	r22, 0x01	; 1
    123c:	0e 94 19 08 	call	0x1032	; 0x1032 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1240:	27 96       	adiw	r28, 0x07	; 7
    1242:	0f b6       	in	r0, 0x3f	; 63
    1244:	f8 94       	cli
    1246:	de bf       	out	0x3e, r29	; 62
    1248:	0f be       	out	0x3f, r0	; 63
    124a:	cd bf       	out	0x3d, r28	; 61
    124c:	cf 91       	pop	r28
    124e:	df 91       	pop	r29
    1250:	1f 91       	pop	r17
    1252:	0f 91       	pop	r16
    1254:	08 95       	ret

00001256 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1256:	df 93       	push	r29
    1258:	cf 93       	push	r28
    125a:	cd b7       	in	r28, 0x3d	; 61
    125c:	de b7       	in	r29, 0x3e	; 62
    125e:	2f 97       	sbiw	r28, 0x0f	; 15
    1260:	0f b6       	in	r0, 0x3f	; 63
    1262:	f8 94       	cli
    1264:	de bf       	out	0x3e, r29	; 62
    1266:	0f be       	out	0x3f, r0	; 63
    1268:	cd bf       	out	0x3d, r28	; 61
    126a:	99 87       	std	Y+9, r25	; 0x09
    126c:	88 87       	std	Y+8, r24	; 0x08
    126e:	7b 87       	std	Y+11, r23	; 0x0b
    1270:	6a 87       	std	Y+10, r22	; 0x0a
    1272:	5d 87       	std	Y+13, r21	; 0x0d
    1274:	4c 87       	std	Y+12, r20	; 0x0c
    1276:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1278:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    127a:	88 85       	ldd	r24, Y+8	; 0x08
    127c:	99 85       	ldd	r25, Y+9	; 0x09
    127e:	9a 83       	std	Y+2, r25	; 0x02
    1280:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1282:	0f b6       	in	r0, 0x3f	; 63
    1284:	f8 94       	cli
    1286:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1288:	e9 81       	ldd	r30, Y+1	; 0x01
    128a:	fa 81       	ldd	r31, Y+2	; 0x02
    128c:	92 8d       	ldd	r25, Z+26	; 0x1a
    128e:	e9 81       	ldd	r30, Y+1	; 0x01
    1290:	fa 81       	ldd	r31, Y+2	; 0x02
    1292:	83 8d       	ldd	r24, Z+27	; 0x1b
    1294:	98 17       	cp	r25, r24
    1296:	18 f0       	brcs	.+6      	; 0x129e <xQueueGenericSend+0x48>
    1298:	8e 85       	ldd	r24, Y+14	; 0x0e
    129a:	82 30       	cpi	r24, 0x02	; 2
    129c:	11 f5       	brne	.+68     	; 0x12e2 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    129e:	89 81       	ldd	r24, Y+1	; 0x01
    12a0:	9a 81       	ldd	r25, Y+2	; 0x02
    12a2:	2a 85       	ldd	r18, Y+10	; 0x0a
    12a4:	3b 85       	ldd	r19, Y+11	; 0x0b
    12a6:	b9 01       	movw	r22, r18
    12a8:	4e 85       	ldd	r20, Y+14	; 0x0e
    12aa:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <prvCopyDataToQueue>
    12ae:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12b0:	e9 81       	ldd	r30, Y+1	; 0x01
    12b2:	fa 81       	ldd	r31, Y+2	; 0x02
    12b4:	81 89       	ldd	r24, Z+17	; 0x11
    12b6:	88 23       	and	r24, r24
    12b8:	51 f0       	breq	.+20     	; 0x12ce <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12ba:	89 81       	ldd	r24, Y+1	; 0x01
    12bc:	9a 81       	ldd	r25, Y+2	; 0x02
    12be:	41 96       	adiw	r24, 0x11	; 17
    12c0:	0e 94 cb 14 	call	0x2996	; 0x2996 <xTaskRemoveFromEventList>
    12c4:	88 23       	and	r24, r24
    12c6:	41 f0       	breq	.+16     	; 0x12d8 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    12c8:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
    12cc:	05 c0       	rjmp	.+10     	; 0x12d8 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    12ce:	8b 81       	ldd	r24, Y+3	; 0x03
    12d0:	88 23       	and	r24, r24
    12d2:	11 f0       	breq	.+4      	; 0x12d8 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    12d4:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    12d8:	0f 90       	pop	r0
    12da:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	8f 87       	std	Y+15, r24	; 0x0f
    12e0:	5c c0       	rjmp	.+184    	; 0x139a <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    12e2:	8c 85       	ldd	r24, Y+12	; 0x0c
    12e4:	9d 85       	ldd	r25, Y+13	; 0x0d
    12e6:	00 97       	sbiw	r24, 0x00	; 0
    12e8:	21 f4       	brne	.+8      	; 0x12f2 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    12ea:	0f 90       	pop	r0
    12ec:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    12ee:	1f 86       	std	Y+15, r1	; 0x0f
    12f0:	54 c0       	rjmp	.+168    	; 0x139a <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    12f2:	8c 81       	ldd	r24, Y+4	; 0x04
    12f4:	88 23       	and	r24, r24
    12f6:	31 f4       	brne	.+12     	; 0x1304 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    12f8:	ce 01       	movw	r24, r28
    12fa:	05 96       	adiw	r24, 0x05	; 5
    12fc:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1300:	81 e0       	ldi	r24, 0x01	; 1
    1302:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1304:	0f 90       	pop	r0
    1306:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1308:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    130c:	0f b6       	in	r0, 0x3f	; 63
    130e:	f8 94       	cli
    1310:	0f 92       	push	r0
    1312:	e9 81       	ldd	r30, Y+1	; 0x01
    1314:	fa 81       	ldd	r31, Y+2	; 0x02
    1316:	85 8d       	ldd	r24, Z+29	; 0x1d
    1318:	8f 3f       	cpi	r24, 0xFF	; 255
    131a:	19 f4       	brne	.+6      	; 0x1322 <xQueueGenericSend+0xcc>
    131c:	e9 81       	ldd	r30, Y+1	; 0x01
    131e:	fa 81       	ldd	r31, Y+2	; 0x02
    1320:	15 8e       	std	Z+29, r1	; 0x1d
    1322:	e9 81       	ldd	r30, Y+1	; 0x01
    1324:	fa 81       	ldd	r31, Y+2	; 0x02
    1326:	86 8d       	ldd	r24, Z+30	; 0x1e
    1328:	8f 3f       	cpi	r24, 0xFF	; 255
    132a:	19 f4       	brne	.+6      	; 0x1332 <xQueueGenericSend+0xdc>
    132c:	e9 81       	ldd	r30, Y+1	; 0x01
    132e:	fa 81       	ldd	r31, Y+2	; 0x02
    1330:	16 8e       	std	Z+30, r1	; 0x1e
    1332:	0f 90       	pop	r0
    1334:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1336:	ce 01       	movw	r24, r28
    1338:	05 96       	adiw	r24, 0x05	; 5
    133a:	9e 01       	movw	r18, r28
    133c:	24 5f       	subi	r18, 0xF4	; 244
    133e:	3f 4f       	sbci	r19, 0xFF	; 255
    1340:	b9 01       	movw	r22, r18
    1342:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <xTaskCheckForTimeOut>
    1346:	88 23       	and	r24, r24
    1348:	09 f5       	brne	.+66     	; 0x138c <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    134a:	89 81       	ldd	r24, Y+1	; 0x01
    134c:	9a 81       	ldd	r25, Y+2	; 0x02
    134e:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <prvIsQueueFull>
    1352:	88 23       	and	r24, r24
    1354:	a1 f0       	breq	.+40     	; 0x137e <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1356:	89 81       	ldd	r24, Y+1	; 0x01
    1358:	9a 81       	ldd	r25, Y+2	; 0x02
    135a:	08 96       	adiw	r24, 0x08	; 8
    135c:	2c 85       	ldd	r18, Y+12	; 0x0c
    135e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1360:	b9 01       	movw	r22, r18
    1362:	0e 94 79 14 	call	0x28f2	; 0x28f2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1366:	89 81       	ldd	r24, Y+1	; 0x01
    1368:	9a 81       	ldd	r25, Y+2	; 0x02
    136a:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    136e:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
    1372:	88 23       	and	r24, r24
    1374:	09 f0       	breq	.+2      	; 0x1378 <xQueueGenericSend+0x122>
    1376:	85 cf       	rjmp	.-246    	; 0x1282 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1378:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
    137c:	82 cf       	rjmp	.-252    	; 0x1282 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    137e:	89 81       	ldd	r24, Y+1	; 0x01
    1380:	9a 81       	ldd	r25, Y+2	; 0x02
    1382:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1386:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
    138a:	7b cf       	rjmp	.-266    	; 0x1282 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    138c:	89 81       	ldd	r24, Y+1	; 0x01
    138e:	9a 81       	ldd	r25, Y+2	; 0x02
    1390:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1394:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1398:	1f 86       	std	Y+15, r1	; 0x0f
    139a:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    139c:	2f 96       	adiw	r28, 0x0f	; 15
    139e:	0f b6       	in	r0, 0x3f	; 63
    13a0:	f8 94       	cli
    13a2:	de bf       	out	0x3e, r29	; 62
    13a4:	0f be       	out	0x3f, r0	; 63
    13a6:	cd bf       	out	0x3d, r28	; 61
    13a8:	cf 91       	pop	r28
    13aa:	df 91       	pop	r29
    13ac:	08 95       	ret

000013ae <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    13ae:	df 93       	push	r29
    13b0:	cf 93       	push	r28
    13b2:	cd b7       	in	r28, 0x3d	; 61
    13b4:	de b7       	in	r29, 0x3e	; 62
    13b6:	2c 97       	sbiw	r28, 0x0c	; 12
    13b8:	0f b6       	in	r0, 0x3f	; 63
    13ba:	f8 94       	cli
    13bc:	de bf       	out	0x3e, r29	; 62
    13be:	0f be       	out	0x3f, r0	; 63
    13c0:	cd bf       	out	0x3d, r28	; 61
    13c2:	9f 83       	std	Y+7, r25	; 0x07
    13c4:	8e 83       	std	Y+6, r24	; 0x06
    13c6:	79 87       	std	Y+9, r23	; 0x09
    13c8:	68 87       	std	Y+8, r22	; 0x08
    13ca:	5b 87       	std	Y+11, r21	; 0x0b
    13cc:	4a 87       	std	Y+10, r20	; 0x0a
    13ce:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    13d0:	8e 81       	ldd	r24, Y+6	; 0x06
    13d2:	9f 81       	ldd	r25, Y+7	; 0x07
    13d4:	9b 83       	std	Y+3, r25	; 0x03
    13d6:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    13d8:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    13da:	ea 81       	ldd	r30, Y+2	; 0x02
    13dc:	fb 81       	ldd	r31, Y+3	; 0x03
    13de:	92 8d       	ldd	r25, Z+26	; 0x1a
    13e0:	ea 81       	ldd	r30, Y+2	; 0x02
    13e2:	fb 81       	ldd	r31, Y+3	; 0x03
    13e4:	83 8d       	ldd	r24, Z+27	; 0x1b
    13e6:	98 17       	cp	r25, r24
    13e8:	18 f0       	brcs	.+6      	; 0x13f0 <xQueueGenericSendFromISR+0x42>
    13ea:	8c 85       	ldd	r24, Y+12	; 0x0c
    13ec:	82 30       	cpi	r24, 0x02	; 2
    13ee:	61 f5       	brne	.+88     	; 0x1448 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    13f0:	ea 81       	ldd	r30, Y+2	; 0x02
    13f2:	fb 81       	ldd	r31, Y+3	; 0x03
    13f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    13f6:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13f8:	8a 81       	ldd	r24, Y+2	; 0x02
    13fa:	9b 81       	ldd	r25, Y+3	; 0x03
    13fc:	28 85       	ldd	r18, Y+8	; 0x08
    13fe:	39 85       	ldd	r19, Y+9	; 0x09
    1400:	b9 01       	movw	r22, r18
    1402:	4c 85       	ldd	r20, Y+12	; 0x0c
    1404:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1408:	89 81       	ldd	r24, Y+1	; 0x01
    140a:	8f 3f       	cpi	r24, 0xFF	; 255
    140c:	a9 f4       	brne	.+42     	; 0x1438 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    140e:	ea 81       	ldd	r30, Y+2	; 0x02
    1410:	fb 81       	ldd	r31, Y+3	; 0x03
    1412:	81 89       	ldd	r24, Z+17	; 0x11
    1414:	88 23       	and	r24, r24
    1416:	a9 f0       	breq	.+42     	; 0x1442 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1418:	8a 81       	ldd	r24, Y+2	; 0x02
    141a:	9b 81       	ldd	r25, Y+3	; 0x03
    141c:	41 96       	adiw	r24, 0x11	; 17
    141e:	0e 94 cb 14 	call	0x2996	; 0x2996 <xTaskRemoveFromEventList>
    1422:	88 23       	and	r24, r24
    1424:	71 f0       	breq	.+28     	; 0x1442 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1426:	8a 85       	ldd	r24, Y+10	; 0x0a
    1428:	9b 85       	ldd	r25, Y+11	; 0x0b
    142a:	00 97       	sbiw	r24, 0x00	; 0
    142c:	51 f0       	breq	.+20     	; 0x1442 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    142e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1430:	fb 85       	ldd	r31, Y+11	; 0x0b
    1432:	81 e0       	ldi	r24, 0x01	; 1
    1434:	80 83       	st	Z, r24
    1436:	05 c0       	rjmp	.+10     	; 0x1442 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1438:	89 81       	ldd	r24, Y+1	; 0x01
    143a:	8f 5f       	subi	r24, 0xFF	; 255
    143c:	ea 81       	ldd	r30, Y+2	; 0x02
    143e:	fb 81       	ldd	r31, Y+3	; 0x03
    1440:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	8d 83       	std	Y+5, r24	; 0x05
    1446:	01 c0       	rjmp	.+2      	; 0x144a <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1448:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    144a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    144c:	2c 96       	adiw	r28, 0x0c	; 12
    144e:	0f b6       	in	r0, 0x3f	; 63
    1450:	f8 94       	cli
    1452:	de bf       	out	0x3e, r29	; 62
    1454:	0f be       	out	0x3f, r0	; 63
    1456:	cd bf       	out	0x3d, r28	; 61
    1458:	cf 91       	pop	r28
    145a:	df 91       	pop	r29
    145c:	08 95       	ret

0000145e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    145e:	df 93       	push	r29
    1460:	cf 93       	push	r28
    1462:	cd b7       	in	r28, 0x3d	; 61
    1464:	de b7       	in	r29, 0x3e	; 62
    1466:	2a 97       	sbiw	r28, 0x0a	; 10
    1468:	0f b6       	in	r0, 0x3f	; 63
    146a:	f8 94       	cli
    146c:	de bf       	out	0x3e, r29	; 62
    146e:	0f be       	out	0x3f, r0	; 63
    1470:	cd bf       	out	0x3d, r28	; 61
    1472:	98 87       	std	Y+8, r25	; 0x08
    1474:	8f 83       	std	Y+7, r24	; 0x07
    1476:	7a 87       	std	Y+10, r23	; 0x0a
    1478:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    147a:	8f 81       	ldd	r24, Y+7	; 0x07
    147c:	98 85       	ldd	r25, Y+8	; 0x08
    147e:	9c 83       	std	Y+4, r25	; 0x04
    1480:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1482:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1484:	eb 81       	ldd	r30, Y+3	; 0x03
    1486:	fc 81       	ldd	r31, Y+4	; 0x04
    1488:	82 8d       	ldd	r24, Z+26	; 0x1a
    148a:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    148c:	eb 81       	ldd	r30, Y+3	; 0x03
    148e:	fc 81       	ldd	r31, Y+4	; 0x04
    1490:	93 8d       	ldd	r25, Z+27	; 0x1b
    1492:	8a 81       	ldd	r24, Y+2	; 0x02
    1494:	89 17       	cp	r24, r25
    1496:	48 f5       	brcc	.+82     	; 0x14ea <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1498:	eb 81       	ldd	r30, Y+3	; 0x03
    149a:	fc 81       	ldd	r31, Y+4	; 0x04
    149c:	86 8d       	ldd	r24, Z+30	; 0x1e
    149e:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    14a0:	8a 81       	ldd	r24, Y+2	; 0x02
    14a2:	8f 5f       	subi	r24, 0xFF	; 255
    14a4:	eb 81       	ldd	r30, Y+3	; 0x03
    14a6:	fc 81       	ldd	r31, Y+4	; 0x04
    14a8:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    14aa:	89 81       	ldd	r24, Y+1	; 0x01
    14ac:	8f 3f       	cpi	r24, 0xFF	; 255
    14ae:	a9 f4       	brne	.+42     	; 0x14da <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14b0:	eb 81       	ldd	r30, Y+3	; 0x03
    14b2:	fc 81       	ldd	r31, Y+4	; 0x04
    14b4:	81 89       	ldd	r24, Z+17	; 0x11
    14b6:	88 23       	and	r24, r24
    14b8:	a9 f0       	breq	.+42     	; 0x14e4 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14ba:	8b 81       	ldd	r24, Y+3	; 0x03
    14bc:	9c 81       	ldd	r25, Y+4	; 0x04
    14be:	41 96       	adiw	r24, 0x11	; 17
    14c0:	0e 94 cb 14 	call	0x2996	; 0x2996 <xTaskRemoveFromEventList>
    14c4:	88 23       	and	r24, r24
    14c6:	71 f0       	breq	.+28     	; 0x14e4 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    14c8:	89 85       	ldd	r24, Y+9	; 0x09
    14ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    14cc:	00 97       	sbiw	r24, 0x00	; 0
    14ce:	51 f0       	breq	.+20     	; 0x14e4 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    14d0:	e9 85       	ldd	r30, Y+9	; 0x09
    14d2:	fa 85       	ldd	r31, Y+10	; 0x0a
    14d4:	81 e0       	ldi	r24, 0x01	; 1
    14d6:	80 83       	st	Z, r24
    14d8:	05 c0       	rjmp	.+10     	; 0x14e4 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    14da:	89 81       	ldd	r24, Y+1	; 0x01
    14dc:	8f 5f       	subi	r24, 0xFF	; 255
    14de:	eb 81       	ldd	r30, Y+3	; 0x03
    14e0:	fc 81       	ldd	r31, Y+4	; 0x04
    14e2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    14e4:	81 e0       	ldi	r24, 0x01	; 1
    14e6:	8e 83       	std	Y+6, r24	; 0x06
    14e8:	01 c0       	rjmp	.+2      	; 0x14ec <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    14ea:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    14ec:	8e 81       	ldd	r24, Y+6	; 0x06
}
    14ee:	2a 96       	adiw	r28, 0x0a	; 10
    14f0:	0f b6       	in	r0, 0x3f	; 63
    14f2:	f8 94       	cli
    14f4:	de bf       	out	0x3e, r29	; 62
    14f6:	0f be       	out	0x3f, r0	; 63
    14f8:	cd bf       	out	0x3d, r28	; 61
    14fa:	cf 91       	pop	r28
    14fc:	df 91       	pop	r29
    14fe:	08 95       	ret

00001500 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1500:	df 93       	push	r29
    1502:	cf 93       	push	r28
    1504:	cd b7       	in	r28, 0x3d	; 61
    1506:	de b7       	in	r29, 0x3e	; 62
    1508:	2e 97       	sbiw	r28, 0x0e	; 14
    150a:	0f b6       	in	r0, 0x3f	; 63
    150c:	f8 94       	cli
    150e:	de bf       	out	0x3e, r29	; 62
    1510:	0f be       	out	0x3f, r0	; 63
    1512:	cd bf       	out	0x3d, r28	; 61
    1514:	99 87       	std	Y+9, r25	; 0x09
    1516:	88 87       	std	Y+8, r24	; 0x08
    1518:	7b 87       	std	Y+11, r23	; 0x0b
    151a:	6a 87       	std	Y+10, r22	; 0x0a
    151c:	5d 87       	std	Y+13, r21	; 0x0d
    151e:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1520:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1522:	88 85       	ldd	r24, Y+8	; 0x08
    1524:	99 85       	ldd	r25, Y+9	; 0x09
    1526:	9b 83       	std	Y+3, r25	; 0x03
    1528:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    152a:	0f b6       	in	r0, 0x3f	; 63
    152c:	f8 94       	cli
    152e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1530:	ea 81       	ldd	r30, Y+2	; 0x02
    1532:	fb 81       	ldd	r31, Y+3	; 0x03
    1534:	82 8d       	ldd	r24, Z+26	; 0x1a
    1536:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1538:	89 81       	ldd	r24, Y+1	; 0x01
    153a:	88 23       	and	r24, r24
    153c:	f9 f0       	breq	.+62     	; 0x157c <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    153e:	8a 81       	ldd	r24, Y+2	; 0x02
    1540:	9b 81       	ldd	r25, Y+3	; 0x03
    1542:	2a 85       	ldd	r18, Y+10	; 0x0a
    1544:	3b 85       	ldd	r19, Y+11	; 0x0b
    1546:	b9 01       	movw	r22, r18
    1548:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    154c:	89 81       	ldd	r24, Y+1	; 0x01
    154e:	81 50       	subi	r24, 0x01	; 1
    1550:	ea 81       	ldd	r30, Y+2	; 0x02
    1552:	fb 81       	ldd	r31, Y+3	; 0x03
    1554:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1556:	ea 81       	ldd	r30, Y+2	; 0x02
    1558:	fb 81       	ldd	r31, Y+3	; 0x03
    155a:	80 85       	ldd	r24, Z+8	; 0x08
    155c:	88 23       	and	r24, r24
    155e:	49 f0       	breq	.+18     	; 0x1572 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1560:	8a 81       	ldd	r24, Y+2	; 0x02
    1562:	9b 81       	ldd	r25, Y+3	; 0x03
    1564:	08 96       	adiw	r24, 0x08	; 8
    1566:	0e 94 cb 14 	call	0x2996	; 0x2996 <xTaskRemoveFromEventList>
    156a:	88 23       	and	r24, r24
    156c:	11 f0       	breq	.+4      	; 0x1572 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    156e:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1572:	0f 90       	pop	r0
    1574:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1576:	81 e0       	ldi	r24, 0x01	; 1
    1578:	8e 87       	std	Y+14, r24	; 0x0e
    157a:	63 c0       	rjmp	.+198    	; 0x1642 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    157c:	8c 85       	ldd	r24, Y+12	; 0x0c
    157e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1580:	00 97       	sbiw	r24, 0x00	; 0
    1582:	21 f4       	brne	.+8      	; 0x158c <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1584:	0f 90       	pop	r0
    1586:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1588:	1e 86       	std	Y+14, r1	; 0x0e
    158a:	5b c0       	rjmp	.+182    	; 0x1642 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    158c:	8c 81       	ldd	r24, Y+4	; 0x04
    158e:	88 23       	and	r24, r24
    1590:	31 f4       	brne	.+12     	; 0x159e <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1592:	ce 01       	movw	r24, r28
    1594:	05 96       	adiw	r24, 0x05	; 5
    1596:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    159a:	81 e0       	ldi	r24, 0x01	; 1
    159c:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    159e:	0f 90       	pop	r0
    15a0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15a2:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15a6:	0f b6       	in	r0, 0x3f	; 63
    15a8:	f8 94       	cli
    15aa:	0f 92       	push	r0
    15ac:	ea 81       	ldd	r30, Y+2	; 0x02
    15ae:	fb 81       	ldd	r31, Y+3	; 0x03
    15b0:	85 8d       	ldd	r24, Z+29	; 0x1d
    15b2:	8f 3f       	cpi	r24, 0xFF	; 255
    15b4:	19 f4       	brne	.+6      	; 0x15bc <xQueueReceive+0xbc>
    15b6:	ea 81       	ldd	r30, Y+2	; 0x02
    15b8:	fb 81       	ldd	r31, Y+3	; 0x03
    15ba:	15 8e       	std	Z+29, r1	; 0x1d
    15bc:	ea 81       	ldd	r30, Y+2	; 0x02
    15be:	fb 81       	ldd	r31, Y+3	; 0x03
    15c0:	86 8d       	ldd	r24, Z+30	; 0x1e
    15c2:	8f 3f       	cpi	r24, 0xFF	; 255
    15c4:	19 f4       	brne	.+6      	; 0x15cc <xQueueReceive+0xcc>
    15c6:	ea 81       	ldd	r30, Y+2	; 0x02
    15c8:	fb 81       	ldd	r31, Y+3	; 0x03
    15ca:	16 8e       	std	Z+30, r1	; 0x1e
    15cc:	0f 90       	pop	r0
    15ce:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15d0:	ce 01       	movw	r24, r28
    15d2:	05 96       	adiw	r24, 0x05	; 5
    15d4:	9e 01       	movw	r18, r28
    15d6:	24 5f       	subi	r18, 0xF4	; 244
    15d8:	3f 4f       	sbci	r19, 0xFF	; 255
    15da:	b9 01       	movw	r22, r18
    15dc:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <xTaskCheckForTimeOut>
    15e0:	88 23       	and	r24, r24
    15e2:	09 f5       	brne	.+66     	; 0x1626 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    15e4:	8a 81       	ldd	r24, Y+2	; 0x02
    15e6:	9b 81       	ldd	r25, Y+3	; 0x03
    15e8:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <prvIsQueueEmpty>
    15ec:	88 23       	and	r24, r24
    15ee:	a1 f0       	breq	.+40     	; 0x1618 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15f0:	8a 81       	ldd	r24, Y+2	; 0x02
    15f2:	9b 81       	ldd	r25, Y+3	; 0x03
    15f4:	41 96       	adiw	r24, 0x11	; 17
    15f6:	2c 85       	ldd	r18, Y+12	; 0x0c
    15f8:	3d 85       	ldd	r19, Y+13	; 0x0d
    15fa:	b9 01       	movw	r22, r18
    15fc:	0e 94 79 14 	call	0x28f2	; 0x28f2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1600:	8a 81       	ldd	r24, Y+2	; 0x02
    1602:	9b 81       	ldd	r25, Y+3	; 0x03
    1604:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1608:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
    160c:	88 23       	and	r24, r24
    160e:	09 f0       	breq	.+2      	; 0x1612 <xQueueReceive+0x112>
    1610:	8c cf       	rjmp	.-232    	; 0x152a <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1612:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
    1616:	89 cf       	rjmp	.-238    	; 0x152a <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1618:	8a 81       	ldd	r24, Y+2	; 0x02
    161a:	9b 81       	ldd	r25, Y+3	; 0x03
    161c:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1620:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
    1624:	82 cf       	rjmp	.-252    	; 0x152a <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1626:	8a 81       	ldd	r24, Y+2	; 0x02
    1628:	9b 81       	ldd	r25, Y+3	; 0x03
    162a:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    162e:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1632:	8a 81       	ldd	r24, Y+2	; 0x02
    1634:	9b 81       	ldd	r25, Y+3	; 0x03
    1636:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <prvIsQueueEmpty>
    163a:	88 23       	and	r24, r24
    163c:	09 f4       	brne	.+2      	; 0x1640 <xQueueReceive+0x140>
    163e:	75 cf       	rjmp	.-278    	; 0x152a <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1640:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1642:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1644:	2e 96       	adiw	r28, 0x0e	; 14
    1646:	0f b6       	in	r0, 0x3f	; 63
    1648:	f8 94       	cli
    164a:	de bf       	out	0x3e, r29	; 62
    164c:	0f be       	out	0x3f, r0	; 63
    164e:	cd bf       	out	0x3d, r28	; 61
    1650:	cf 91       	pop	r28
    1652:	df 91       	pop	r29
    1654:	08 95       	ret

00001656 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1656:	df 93       	push	r29
    1658:	cf 93       	push	r28
    165a:	cd b7       	in	r28, 0x3d	; 61
    165c:	de b7       	in	r29, 0x3e	; 62
    165e:	2c 97       	sbiw	r28, 0x0c	; 12
    1660:	0f b6       	in	r0, 0x3f	; 63
    1662:	f8 94       	cli
    1664:	de bf       	out	0x3e, r29	; 62
    1666:	0f be       	out	0x3f, r0	; 63
    1668:	cd bf       	out	0x3d, r28	; 61
    166a:	99 87       	std	Y+9, r25	; 0x09
    166c:	88 87       	std	Y+8, r24	; 0x08
    166e:	7b 87       	std	Y+11, r23	; 0x0b
    1670:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    1672:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1674:	88 85       	ldd	r24, Y+8	; 0x08
    1676:	99 85       	ldd	r25, Y+9	; 0x09
    1678:	9b 83       	std	Y+3, r25	; 0x03
    167a:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    167c:	0f b6       	in	r0, 0x3f	; 63
    167e:	f8 94       	cli
    1680:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1682:	ea 81       	ldd	r30, Y+2	; 0x02
    1684:	fb 81       	ldd	r31, Y+3	; 0x03
    1686:	82 8d       	ldd	r24, Z+26	; 0x1a
    1688:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    168a:	89 81       	ldd	r24, Y+1	; 0x01
    168c:	88 23       	and	r24, r24
    168e:	c1 f0       	breq	.+48     	; 0x16c0 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1690:	89 81       	ldd	r24, Y+1	; 0x01
    1692:	81 50       	subi	r24, 0x01	; 1
    1694:	ea 81       	ldd	r30, Y+2	; 0x02
    1696:	fb 81       	ldd	r31, Y+3	; 0x03
    1698:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    169a:	ea 81       	ldd	r30, Y+2	; 0x02
    169c:	fb 81       	ldd	r31, Y+3	; 0x03
    169e:	80 85       	ldd	r24, Z+8	; 0x08
    16a0:	88 23       	and	r24, r24
    16a2:	49 f0       	breq	.+18     	; 0x16b6 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16a4:	8a 81       	ldd	r24, Y+2	; 0x02
    16a6:	9b 81       	ldd	r25, Y+3	; 0x03
    16a8:	08 96       	adiw	r24, 0x08	; 8
    16aa:	0e 94 cb 14 	call	0x2996	; 0x2996 <xTaskRemoveFromEventList>
    16ae:	88 23       	and	r24, r24
    16b0:	11 f0       	breq	.+4      	; 0x16b6 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    16b2:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    16b6:	0f 90       	pop	r0
    16b8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16ba:	81 e0       	ldi	r24, 0x01	; 1
    16bc:	8c 87       	std	Y+12, r24	; 0x0c
    16be:	63 c0       	rjmp	.+198    	; 0x1786 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    16c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    16c4:	00 97       	sbiw	r24, 0x00	; 0
    16c6:	21 f4       	brne	.+8      	; 0x16d0 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    16c8:	0f 90       	pop	r0
    16ca:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    16cc:	1c 86       	std	Y+12, r1	; 0x0c
    16ce:	5b c0       	rjmp	.+182    	; 0x1786 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    16d0:	8c 81       	ldd	r24, Y+4	; 0x04
    16d2:	88 23       	and	r24, r24
    16d4:	31 f4       	brne	.+12     	; 0x16e2 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16d6:	ce 01       	movw	r24, r28
    16d8:	05 96       	adiw	r24, 0x05	; 5
    16da:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    16de:	81 e0       	ldi	r24, 0x01	; 1
    16e0:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16e2:	0f 90       	pop	r0
    16e4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    16e6:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16ea:	0f b6       	in	r0, 0x3f	; 63
    16ec:	f8 94       	cli
    16ee:	0f 92       	push	r0
    16f0:	ea 81       	ldd	r30, Y+2	; 0x02
    16f2:	fb 81       	ldd	r31, Y+3	; 0x03
    16f4:	85 8d       	ldd	r24, Z+29	; 0x1d
    16f6:	8f 3f       	cpi	r24, 0xFF	; 255
    16f8:	19 f4       	brne	.+6      	; 0x1700 <xQueueSemaphoreTake+0xaa>
    16fa:	ea 81       	ldd	r30, Y+2	; 0x02
    16fc:	fb 81       	ldd	r31, Y+3	; 0x03
    16fe:	15 8e       	std	Z+29, r1	; 0x1d
    1700:	ea 81       	ldd	r30, Y+2	; 0x02
    1702:	fb 81       	ldd	r31, Y+3	; 0x03
    1704:	86 8d       	ldd	r24, Z+30	; 0x1e
    1706:	8f 3f       	cpi	r24, 0xFF	; 255
    1708:	19 f4       	brne	.+6      	; 0x1710 <xQueueSemaphoreTake+0xba>
    170a:	ea 81       	ldd	r30, Y+2	; 0x02
    170c:	fb 81       	ldd	r31, Y+3	; 0x03
    170e:	16 8e       	std	Z+30, r1	; 0x1e
    1710:	0f 90       	pop	r0
    1712:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1714:	ce 01       	movw	r24, r28
    1716:	05 96       	adiw	r24, 0x05	; 5
    1718:	9e 01       	movw	r18, r28
    171a:	26 5f       	subi	r18, 0xF6	; 246
    171c:	3f 4f       	sbci	r19, 0xFF	; 255
    171e:	b9 01       	movw	r22, r18
    1720:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <xTaskCheckForTimeOut>
    1724:	88 23       	and	r24, r24
    1726:	09 f5       	brne	.+66     	; 0x176a <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1728:	8a 81       	ldd	r24, Y+2	; 0x02
    172a:	9b 81       	ldd	r25, Y+3	; 0x03
    172c:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <prvIsQueueEmpty>
    1730:	88 23       	and	r24, r24
    1732:	a1 f0       	breq	.+40     	; 0x175c <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1734:	8a 81       	ldd	r24, Y+2	; 0x02
    1736:	9b 81       	ldd	r25, Y+3	; 0x03
    1738:	41 96       	adiw	r24, 0x11	; 17
    173a:	2a 85       	ldd	r18, Y+10	; 0x0a
    173c:	3b 85       	ldd	r19, Y+11	; 0x0b
    173e:	b9 01       	movw	r22, r18
    1740:	0e 94 79 14 	call	0x28f2	; 0x28f2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1744:	8a 81       	ldd	r24, Y+2	; 0x02
    1746:	9b 81       	ldd	r25, Y+3	; 0x03
    1748:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    174c:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
    1750:	88 23       	and	r24, r24
    1752:	09 f0       	breq	.+2      	; 0x1756 <xQueueSemaphoreTake+0x100>
    1754:	93 cf       	rjmp	.-218    	; 0x167c <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1756:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
    175a:	90 cf       	rjmp	.-224    	; 0x167c <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    175c:	8a 81       	ldd	r24, Y+2	; 0x02
    175e:	9b 81       	ldd	r25, Y+3	; 0x03
    1760:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1764:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
    1768:	89 cf       	rjmp	.-238    	; 0x167c <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    176a:	8a 81       	ldd	r24, Y+2	; 0x02
    176c:	9b 81       	ldd	r25, Y+3	; 0x03
    176e:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1772:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1776:	8a 81       	ldd	r24, Y+2	; 0x02
    1778:	9b 81       	ldd	r25, Y+3	; 0x03
    177a:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <prvIsQueueEmpty>
    177e:	88 23       	and	r24, r24
    1780:	09 f4       	brne	.+2      	; 0x1784 <xQueueSemaphoreTake+0x12e>
    1782:	7c cf       	rjmp	.-264    	; 0x167c <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1784:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1786:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    1788:	2c 96       	adiw	r28, 0x0c	; 12
    178a:	0f b6       	in	r0, 0x3f	; 63
    178c:	f8 94       	cli
    178e:	de bf       	out	0x3e, r29	; 62
    1790:	0f be       	out	0x3f, r0	; 63
    1792:	cd bf       	out	0x3d, r28	; 61
    1794:	cf 91       	pop	r28
    1796:	df 91       	pop	r29
    1798:	08 95       	ret

0000179a <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    179a:	df 93       	push	r29
    179c:	cf 93       	push	r28
    179e:	cd b7       	in	r28, 0x3d	; 61
    17a0:	de b7       	in	r29, 0x3e	; 62
    17a2:	60 97       	sbiw	r28, 0x10	; 16
    17a4:	0f b6       	in	r0, 0x3f	; 63
    17a6:	f8 94       	cli
    17a8:	de bf       	out	0x3e, r29	; 62
    17aa:	0f be       	out	0x3f, r0	; 63
    17ac:	cd bf       	out	0x3d, r28	; 61
    17ae:	9b 87       	std	Y+11, r25	; 0x0b
    17b0:	8a 87       	std	Y+10, r24	; 0x0a
    17b2:	7d 87       	std	Y+13, r23	; 0x0d
    17b4:	6c 87       	std	Y+12, r22	; 0x0c
    17b6:	5f 87       	std	Y+15, r21	; 0x0f
    17b8:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    17ba:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    17bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    17be:	9b 85       	ldd	r25, Y+11	; 0x0b
    17c0:	9b 83       	std	Y+3, r25	; 0x03
    17c2:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	f8 94       	cli
    17c8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    17ca:	ea 81       	ldd	r30, Y+2	; 0x02
    17cc:	fb 81       	ldd	r31, Y+3	; 0x03
    17ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    17d0:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    17d2:	89 81       	ldd	r24, Y+1	; 0x01
    17d4:	88 23       	and	r24, r24
    17d6:	31 f1       	breq	.+76     	; 0x1824 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    17d8:	ea 81       	ldd	r30, Y+2	; 0x02
    17da:	fb 81       	ldd	r31, Y+3	; 0x03
    17dc:	86 81       	ldd	r24, Z+6	; 0x06
    17de:	97 81       	ldd	r25, Z+7	; 0x07
    17e0:	9d 83       	std	Y+5, r25	; 0x05
    17e2:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    17e4:	8a 81       	ldd	r24, Y+2	; 0x02
    17e6:	9b 81       	ldd	r25, Y+3	; 0x03
    17e8:	2c 85       	ldd	r18, Y+12	; 0x0c
    17ea:	3d 85       	ldd	r19, Y+13	; 0x0d
    17ec:	b9 01       	movw	r22, r18
    17ee:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    17f2:	ea 81       	ldd	r30, Y+2	; 0x02
    17f4:	fb 81       	ldd	r31, Y+3	; 0x03
    17f6:	8c 81       	ldd	r24, Y+4	; 0x04
    17f8:	9d 81       	ldd	r25, Y+5	; 0x05
    17fa:	97 83       	std	Z+7, r25	; 0x07
    17fc:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17fe:	ea 81       	ldd	r30, Y+2	; 0x02
    1800:	fb 81       	ldd	r31, Y+3	; 0x03
    1802:	81 89       	ldd	r24, Z+17	; 0x11
    1804:	88 23       	and	r24, r24
    1806:	49 f0       	breq	.+18     	; 0x181a <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1808:	8a 81       	ldd	r24, Y+2	; 0x02
    180a:	9b 81       	ldd	r25, Y+3	; 0x03
    180c:	41 96       	adiw	r24, 0x11	; 17
    180e:	0e 94 cb 14 	call	0x2996	; 0x2996 <xTaskRemoveFromEventList>
    1812:	88 23       	and	r24, r24
    1814:	11 f0       	breq	.+4      	; 0x181a <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1816:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    181a:	0f 90       	pop	r0
    181c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    181e:	81 e0       	ldi	r24, 0x01	; 1
    1820:	88 8b       	std	Y+16, r24	; 0x10
    1822:	63 c0       	rjmp	.+198    	; 0x18ea <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1824:	8e 85       	ldd	r24, Y+14	; 0x0e
    1826:	9f 85       	ldd	r25, Y+15	; 0x0f
    1828:	00 97       	sbiw	r24, 0x00	; 0
    182a:	21 f4       	brne	.+8      	; 0x1834 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    182c:	0f 90       	pop	r0
    182e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1830:	18 8a       	std	Y+16, r1	; 0x10
    1832:	5b c0       	rjmp	.+182    	; 0x18ea <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1834:	8e 81       	ldd	r24, Y+6	; 0x06
    1836:	88 23       	and	r24, r24
    1838:	31 f4       	brne	.+12     	; 0x1846 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    183a:	ce 01       	movw	r24, r28
    183c:	07 96       	adiw	r24, 0x07	; 7
    183e:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1842:	81 e0       	ldi	r24, 0x01	; 1
    1844:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1846:	0f 90       	pop	r0
    1848:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    184a:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    184e:	0f b6       	in	r0, 0x3f	; 63
    1850:	f8 94       	cli
    1852:	0f 92       	push	r0
    1854:	ea 81       	ldd	r30, Y+2	; 0x02
    1856:	fb 81       	ldd	r31, Y+3	; 0x03
    1858:	85 8d       	ldd	r24, Z+29	; 0x1d
    185a:	8f 3f       	cpi	r24, 0xFF	; 255
    185c:	19 f4       	brne	.+6      	; 0x1864 <xQueuePeek+0xca>
    185e:	ea 81       	ldd	r30, Y+2	; 0x02
    1860:	fb 81       	ldd	r31, Y+3	; 0x03
    1862:	15 8e       	std	Z+29, r1	; 0x1d
    1864:	ea 81       	ldd	r30, Y+2	; 0x02
    1866:	fb 81       	ldd	r31, Y+3	; 0x03
    1868:	86 8d       	ldd	r24, Z+30	; 0x1e
    186a:	8f 3f       	cpi	r24, 0xFF	; 255
    186c:	19 f4       	brne	.+6      	; 0x1874 <xQueuePeek+0xda>
    186e:	ea 81       	ldd	r30, Y+2	; 0x02
    1870:	fb 81       	ldd	r31, Y+3	; 0x03
    1872:	16 8e       	std	Z+30, r1	; 0x1e
    1874:	0f 90       	pop	r0
    1876:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1878:	ce 01       	movw	r24, r28
    187a:	07 96       	adiw	r24, 0x07	; 7
    187c:	9e 01       	movw	r18, r28
    187e:	22 5f       	subi	r18, 0xF2	; 242
    1880:	3f 4f       	sbci	r19, 0xFF	; 255
    1882:	b9 01       	movw	r22, r18
    1884:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <xTaskCheckForTimeOut>
    1888:	88 23       	and	r24, r24
    188a:	09 f5       	brne	.+66     	; 0x18ce <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    188c:	8a 81       	ldd	r24, Y+2	; 0x02
    188e:	9b 81       	ldd	r25, Y+3	; 0x03
    1890:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <prvIsQueueEmpty>
    1894:	88 23       	and	r24, r24
    1896:	a1 f0       	breq	.+40     	; 0x18c0 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1898:	8a 81       	ldd	r24, Y+2	; 0x02
    189a:	9b 81       	ldd	r25, Y+3	; 0x03
    189c:	41 96       	adiw	r24, 0x11	; 17
    189e:	2e 85       	ldd	r18, Y+14	; 0x0e
    18a0:	3f 85       	ldd	r19, Y+15	; 0x0f
    18a2:	b9 01       	movw	r22, r18
    18a4:	0e 94 79 14 	call	0x28f2	; 0x28f2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18a8:	8a 81       	ldd	r24, Y+2	; 0x02
    18aa:	9b 81       	ldd	r25, Y+3	; 0x03
    18ac:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18b0:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
    18b4:	88 23       	and	r24, r24
    18b6:	09 f0       	breq	.+2      	; 0x18ba <xQueuePeek+0x120>
    18b8:	85 cf       	rjmp	.-246    	; 0x17c4 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    18ba:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
    18be:	82 cf       	rjmp	.-252    	; 0x17c4 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    18c0:	8a 81       	ldd	r24, Y+2	; 0x02
    18c2:	9b 81       	ldd	r25, Y+3	; 0x03
    18c4:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18c8:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
    18cc:	7b cf       	rjmp	.-266    	; 0x17c4 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    18ce:	8a 81       	ldd	r24, Y+2	; 0x02
    18d0:	9b 81       	ldd	r25, Y+3	; 0x03
    18d2:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18d6:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18da:	8a 81       	ldd	r24, Y+2	; 0x02
    18dc:	9b 81       	ldd	r25, Y+3	; 0x03
    18de:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <prvIsQueueEmpty>
    18e2:	88 23       	and	r24, r24
    18e4:	09 f4       	brne	.+2      	; 0x18e8 <xQueuePeek+0x14e>
    18e6:	6e cf       	rjmp	.-292    	; 0x17c4 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18e8:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    18ea:	88 89       	ldd	r24, Y+16	; 0x10
}
    18ec:	60 96       	adiw	r28, 0x10	; 16
    18ee:	0f b6       	in	r0, 0x3f	; 63
    18f0:	f8 94       	cli
    18f2:	de bf       	out	0x3e, r29	; 62
    18f4:	0f be       	out	0x3f, r0	; 63
    18f6:	cd bf       	out	0x3d, r28	; 61
    18f8:	cf 91       	pop	r28
    18fa:	df 91       	pop	r29
    18fc:	08 95       	ret

000018fe <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    18fe:	df 93       	push	r29
    1900:	cf 93       	push	r28
    1902:	cd b7       	in	r28, 0x3d	; 61
    1904:	de b7       	in	r29, 0x3e	; 62
    1906:	2c 97       	sbiw	r28, 0x0c	; 12
    1908:	0f b6       	in	r0, 0x3f	; 63
    190a:	f8 94       	cli
    190c:	de bf       	out	0x3e, r29	; 62
    190e:	0f be       	out	0x3f, r0	; 63
    1910:	cd bf       	out	0x3d, r28	; 61
    1912:	98 87       	std	Y+8, r25	; 0x08
    1914:	8f 83       	std	Y+7, r24	; 0x07
    1916:	7a 87       	std	Y+10, r23	; 0x0a
    1918:	69 87       	std	Y+9, r22	; 0x09
    191a:	5c 87       	std	Y+12, r21	; 0x0c
    191c:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    191e:	8f 81       	ldd	r24, Y+7	; 0x07
    1920:	98 85       	ldd	r25, Y+8	; 0x08
    1922:	9c 83       	std	Y+4, r25	; 0x04
    1924:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1926:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1928:	eb 81       	ldd	r30, Y+3	; 0x03
    192a:	fc 81       	ldd	r31, Y+4	; 0x04
    192c:	82 8d       	ldd	r24, Z+26	; 0x1a
    192e:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1930:	8a 81       	ldd	r24, Y+2	; 0x02
    1932:	88 23       	and	r24, r24
    1934:	81 f1       	breq	.+96     	; 0x1996 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1936:	eb 81       	ldd	r30, Y+3	; 0x03
    1938:	fc 81       	ldd	r31, Y+4	; 0x04
    193a:	85 8d       	ldd	r24, Z+29	; 0x1d
    193c:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    193e:	8b 81       	ldd	r24, Y+3	; 0x03
    1940:	9c 81       	ldd	r25, Y+4	; 0x04
    1942:	29 85       	ldd	r18, Y+9	; 0x09
    1944:	3a 85       	ldd	r19, Y+10	; 0x0a
    1946:	b9 01       	movw	r22, r18
    1948:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    194c:	8a 81       	ldd	r24, Y+2	; 0x02
    194e:	81 50       	subi	r24, 0x01	; 1
    1950:	eb 81       	ldd	r30, Y+3	; 0x03
    1952:	fc 81       	ldd	r31, Y+4	; 0x04
    1954:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1956:	89 81       	ldd	r24, Y+1	; 0x01
    1958:	8f 3f       	cpi	r24, 0xFF	; 255
    195a:	a9 f4       	brne	.+42     	; 0x1986 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    195c:	eb 81       	ldd	r30, Y+3	; 0x03
    195e:	fc 81       	ldd	r31, Y+4	; 0x04
    1960:	80 85       	ldd	r24, Z+8	; 0x08
    1962:	88 23       	and	r24, r24
    1964:	a9 f0       	breq	.+42     	; 0x1990 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1966:	8b 81       	ldd	r24, Y+3	; 0x03
    1968:	9c 81       	ldd	r25, Y+4	; 0x04
    196a:	08 96       	adiw	r24, 0x08	; 8
    196c:	0e 94 cb 14 	call	0x2996	; 0x2996 <xTaskRemoveFromEventList>
    1970:	88 23       	and	r24, r24
    1972:	71 f0       	breq	.+28     	; 0x1990 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1974:	8b 85       	ldd	r24, Y+11	; 0x0b
    1976:	9c 85       	ldd	r25, Y+12	; 0x0c
    1978:	00 97       	sbiw	r24, 0x00	; 0
    197a:	51 f0       	breq	.+20     	; 0x1990 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    197c:	eb 85       	ldd	r30, Y+11	; 0x0b
    197e:	fc 85       	ldd	r31, Y+12	; 0x0c
    1980:	81 e0       	ldi	r24, 0x01	; 1
    1982:	80 83       	st	Z, r24
    1984:	05 c0       	rjmp	.+10     	; 0x1990 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1986:	89 81       	ldd	r24, Y+1	; 0x01
    1988:	8f 5f       	subi	r24, 0xFF	; 255
    198a:	eb 81       	ldd	r30, Y+3	; 0x03
    198c:	fc 81       	ldd	r31, Y+4	; 0x04
    198e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	8e 83       	std	Y+6, r24	; 0x06
    1994:	01 c0       	rjmp	.+2      	; 0x1998 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    1996:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1998:	8e 81       	ldd	r24, Y+6	; 0x06
}
    199a:	2c 96       	adiw	r28, 0x0c	; 12
    199c:	0f b6       	in	r0, 0x3f	; 63
    199e:	f8 94       	cli
    19a0:	de bf       	out	0x3e, r29	; 62
    19a2:	0f be       	out	0x3f, r0	; 63
    19a4:	cd bf       	out	0x3d, r28	; 61
    19a6:	cf 91       	pop	r28
    19a8:	df 91       	pop	r29
    19aa:	08 95       	ret

000019ac <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    19ac:	df 93       	push	r29
    19ae:	cf 93       	push	r28
    19b0:	cd b7       	in	r28, 0x3d	; 61
    19b2:	de b7       	in	r29, 0x3e	; 62
    19b4:	2a 97       	sbiw	r28, 0x0a	; 10
    19b6:	0f b6       	in	r0, 0x3f	; 63
    19b8:	f8 94       	cli
    19ba:	de bf       	out	0x3e, r29	; 62
    19bc:	0f be       	out	0x3f, r0	; 63
    19be:	cd bf       	out	0x3d, r28	; 61
    19c0:	98 87       	std	Y+8, r25	; 0x08
    19c2:	8f 83       	std	Y+7, r24	; 0x07
    19c4:	7a 87       	std	Y+10, r23	; 0x0a
    19c6:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    19c8:	8f 81       	ldd	r24, Y+7	; 0x07
    19ca:	98 85       	ldd	r25, Y+8	; 0x08
    19cc:	9a 83       	std	Y+2, r25	; 0x02
    19ce:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    19d0:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    19d2:	e9 81       	ldd	r30, Y+1	; 0x01
    19d4:	fa 81       	ldd	r31, Y+2	; 0x02
    19d6:	82 8d       	ldd	r24, Z+26	; 0x1a
    19d8:	88 23       	and	r24, r24
    19da:	b1 f0       	breq	.+44     	; 0x1a08 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    19dc:	e9 81       	ldd	r30, Y+1	; 0x01
    19de:	fa 81       	ldd	r31, Y+2	; 0x02
    19e0:	86 81       	ldd	r24, Z+6	; 0x06
    19e2:	97 81       	ldd	r25, Z+7	; 0x07
    19e4:	9c 83       	std	Y+4, r25	; 0x04
    19e6:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19e8:	89 81       	ldd	r24, Y+1	; 0x01
    19ea:	9a 81       	ldd	r25, Y+2	; 0x02
    19ec:	29 85       	ldd	r18, Y+9	; 0x09
    19ee:	3a 85       	ldd	r19, Y+10	; 0x0a
    19f0:	b9 01       	movw	r22, r18
    19f2:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    19f6:	e9 81       	ldd	r30, Y+1	; 0x01
    19f8:	fa 81       	ldd	r31, Y+2	; 0x02
    19fa:	8b 81       	ldd	r24, Y+3	; 0x03
    19fc:	9c 81       	ldd	r25, Y+4	; 0x04
    19fe:	97 83       	std	Z+7, r25	; 0x07
    1a00:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    1a02:	81 e0       	ldi	r24, 0x01	; 1
    1a04:	8e 83       	std	Y+6, r24	; 0x06
    1a06:	01 c0       	rjmp	.+2      	; 0x1a0a <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    1a08:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1a0a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1a0c:	2a 96       	adiw	r28, 0x0a	; 10
    1a0e:	0f b6       	in	r0, 0x3f	; 63
    1a10:	f8 94       	cli
    1a12:	de bf       	out	0x3e, r29	; 62
    1a14:	0f be       	out	0x3f, r0	; 63
    1a16:	cd bf       	out	0x3d, r28	; 61
    1a18:	cf 91       	pop	r28
    1a1a:	df 91       	pop	r29
    1a1c:	08 95       	ret

00001a1e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1a1e:	df 93       	push	r29
    1a20:	cf 93       	push	r28
    1a22:	00 d0       	rcall	.+0      	; 0x1a24 <uxQueueMessagesWaiting+0x6>
    1a24:	0f 92       	push	r0
    1a26:	cd b7       	in	r28, 0x3d	; 61
    1a28:	de b7       	in	r29, 0x3e	; 62
    1a2a:	9b 83       	std	Y+3, r25	; 0x03
    1a2c:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1a2e:	0f b6       	in	r0, 0x3f	; 63
    1a30:	f8 94       	cli
    1a32:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1a34:	ea 81       	ldd	r30, Y+2	; 0x02
    1a36:	fb 81       	ldd	r31, Y+3	; 0x03
    1a38:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a3a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1a3c:	0f 90       	pop	r0
    1a3e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a40:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a42:	0f 90       	pop	r0
    1a44:	0f 90       	pop	r0
    1a46:	0f 90       	pop	r0
    1a48:	cf 91       	pop	r28
    1a4a:	df 91       	pop	r29
    1a4c:	08 95       	ret

00001a4e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1a4e:	df 93       	push	r29
    1a50:	cf 93       	push	r28
    1a52:	00 d0       	rcall	.+0      	; 0x1a54 <uxQueueSpacesAvailable+0x6>
    1a54:	00 d0       	rcall	.+0      	; 0x1a56 <uxQueueSpacesAvailable+0x8>
    1a56:	0f 92       	push	r0
    1a58:	cd b7       	in	r28, 0x3d	; 61
    1a5a:	de b7       	in	r29, 0x3e	; 62
    1a5c:	9d 83       	std	Y+5, r25	; 0x05
    1a5e:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1a60:	8c 81       	ldd	r24, Y+4	; 0x04
    1a62:	9d 81       	ldd	r25, Y+5	; 0x05
    1a64:	9a 83       	std	Y+2, r25	; 0x02
    1a66:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a68:	0f b6       	in	r0, 0x3f	; 63
    1a6a:	f8 94       	cli
    1a6c:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1a6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a70:	fa 81       	ldd	r31, Y+2	; 0x02
    1a72:	93 8d       	ldd	r25, Z+27	; 0x1b
    1a74:	e9 81       	ldd	r30, Y+1	; 0x01
    1a76:	fa 81       	ldd	r31, Y+2	; 0x02
    1a78:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a7a:	29 2f       	mov	r18, r25
    1a7c:	28 1b       	sub	r18, r24
    1a7e:	82 2f       	mov	r24, r18
    1a80:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    1a82:	0f 90       	pop	r0
    1a84:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a86:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a88:	0f 90       	pop	r0
    1a8a:	0f 90       	pop	r0
    1a8c:	0f 90       	pop	r0
    1a8e:	0f 90       	pop	r0
    1a90:	0f 90       	pop	r0
    1a92:	cf 91       	pop	r28
    1a94:	df 91       	pop	r29
    1a96:	08 95       	ret

00001a98 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1a98:	df 93       	push	r29
    1a9a:	cf 93       	push	r28
    1a9c:	00 d0       	rcall	.+0      	; 0x1a9e <uxQueueMessagesWaitingFromISR+0x6>
    1a9e:	00 d0       	rcall	.+0      	; 0x1aa0 <uxQueueMessagesWaitingFromISR+0x8>
    1aa0:	0f 92       	push	r0
    1aa2:	cd b7       	in	r28, 0x3d	; 61
    1aa4:	de b7       	in	r29, 0x3e	; 62
    1aa6:	9d 83       	std	Y+5, r25	; 0x05
    1aa8:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1aaa:	8c 81       	ldd	r24, Y+4	; 0x04
    1aac:	9d 81       	ldd	r25, Y+5	; 0x05
    1aae:	9a 83       	std	Y+2, r25	; 0x02
    1ab0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ab6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ab8:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    1aba:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1abc:	0f 90       	pop	r0
    1abe:	0f 90       	pop	r0
    1ac0:	0f 90       	pop	r0
    1ac2:	0f 90       	pop	r0
    1ac4:	0f 90       	pop	r0
    1ac6:	cf 91       	pop	r28
    1ac8:	df 91       	pop	r29
    1aca:	08 95       	ret

00001acc <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1acc:	df 93       	push	r29
    1ace:	cf 93       	push	r28
    1ad0:	00 d0       	rcall	.+0      	; 0x1ad2 <vQueueDelete+0x6>
    1ad2:	00 d0       	rcall	.+0      	; 0x1ad4 <vQueueDelete+0x8>
    1ad4:	cd b7       	in	r28, 0x3d	; 61
    1ad6:	de b7       	in	r29, 0x3e	; 62
    1ad8:	9c 83       	std	Y+4, r25	; 0x04
    1ada:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    1adc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ade:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae0:	9a 83       	std	Y+2, r25	; 0x02
    1ae2:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1ae4:	89 81       	ldd	r24, Y+1	; 0x01
    1ae6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae8:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1aec:	0f 90       	pop	r0
    1aee:	0f 90       	pop	r0
    1af0:	0f 90       	pop	r0
    1af2:	0f 90       	pop	r0
    1af4:	cf 91       	pop	r28
    1af6:	df 91       	pop	r29
    1af8:	08 95       	ret

00001afa <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1afa:	df 93       	push	r29
    1afc:	cf 93       	push	r28
    1afe:	cd b7       	in	r28, 0x3d	; 61
    1b00:	de b7       	in	r29, 0x3e	; 62
    1b02:	27 97       	sbiw	r28, 0x07	; 7
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	f8 94       	cli
    1b08:	de bf       	out	0x3e, r29	; 62
    1b0a:	0f be       	out	0x3f, r0	; 63
    1b0c:	cd bf       	out	0x3d, r28	; 61
    1b0e:	9c 83       	std	Y+4, r25	; 0x04
    1b10:	8b 83       	std	Y+3, r24	; 0x03
    1b12:	7e 83       	std	Y+6, r23	; 0x06
    1b14:	6d 83       	std	Y+5, r22	; 0x05
    1b16:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    1b18:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b20:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1b22:	eb 81       	ldd	r30, Y+3	; 0x03
    1b24:	fc 81       	ldd	r31, Y+4	; 0x04
    1b26:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b28:	88 23       	and	r24, r24
    1b2a:	09 f4       	brne	.+2      	; 0x1b2e <prvCopyDataToQueue+0x34>
    1b2c:	7d c0       	rjmp	.+250    	; 0x1c28 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1b2e:	8f 81       	ldd	r24, Y+7	; 0x07
    1b30:	88 23       	and	r24, r24
    1b32:	99 f5       	brne	.+102    	; 0x1b9a <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1b34:	eb 81       	ldd	r30, Y+3	; 0x03
    1b36:	fc 81       	ldd	r31, Y+4	; 0x04
    1b38:	62 81       	ldd	r22, Z+2	; 0x02
    1b3a:	73 81       	ldd	r23, Z+3	; 0x03
    1b3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b40:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b42:	48 2f       	mov	r20, r24
    1b44:	50 e0       	ldi	r21, 0x00	; 0
    1b46:	2d 81       	ldd	r18, Y+5	; 0x05
    1b48:	3e 81       	ldd	r19, Y+6	; 0x06
    1b4a:	cb 01       	movw	r24, r22
    1b4c:	b9 01       	movw	r22, r18
    1b4e:	0e 94 9f 1d 	call	0x3b3e	; 0x3b3e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1b52:	eb 81       	ldd	r30, Y+3	; 0x03
    1b54:	fc 81       	ldd	r31, Y+4	; 0x04
    1b56:	22 81       	ldd	r18, Z+2	; 0x02
    1b58:	33 81       	ldd	r19, Z+3	; 0x03
    1b5a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b5c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b5e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b60:	88 2f       	mov	r24, r24
    1b62:	90 e0       	ldi	r25, 0x00	; 0
    1b64:	82 0f       	add	r24, r18
    1b66:	93 1f       	adc	r25, r19
    1b68:	eb 81       	ldd	r30, Y+3	; 0x03
    1b6a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b6c:	93 83       	std	Z+3, r25	; 0x03
    1b6e:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1b70:	eb 81       	ldd	r30, Y+3	; 0x03
    1b72:	fc 81       	ldd	r31, Y+4	; 0x04
    1b74:	22 81       	ldd	r18, Z+2	; 0x02
    1b76:	33 81       	ldd	r19, Z+3	; 0x03
    1b78:	eb 81       	ldd	r30, Y+3	; 0x03
    1b7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b7c:	84 81       	ldd	r24, Z+4	; 0x04
    1b7e:	95 81       	ldd	r25, Z+5	; 0x05
    1b80:	28 17       	cp	r18, r24
    1b82:	39 07       	cpc	r19, r25
    1b84:	08 f4       	brcc	.+2      	; 0x1b88 <prvCopyDataToQueue+0x8e>
    1b86:	50 c0       	rjmp	.+160    	; 0x1c28 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1b88:	eb 81       	ldd	r30, Y+3	; 0x03
    1b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b8c:	80 81       	ld	r24, Z
    1b8e:	91 81       	ldd	r25, Z+1	; 0x01
    1b90:	eb 81       	ldd	r30, Y+3	; 0x03
    1b92:	fc 81       	ldd	r31, Y+4	; 0x04
    1b94:	93 83       	std	Z+3, r25	; 0x03
    1b96:	82 83       	std	Z+2, r24	; 0x02
    1b98:	47 c0       	rjmp	.+142    	; 0x1c28 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b9e:	66 81       	ldd	r22, Z+6	; 0x06
    1ba0:	77 81       	ldd	r23, Z+7	; 0x07
    1ba2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ba4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ba6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ba8:	48 2f       	mov	r20, r24
    1baa:	50 e0       	ldi	r21, 0x00	; 0
    1bac:	2d 81       	ldd	r18, Y+5	; 0x05
    1bae:	3e 81       	ldd	r19, Y+6	; 0x06
    1bb0:	cb 01       	movw	r24, r22
    1bb2:	b9 01       	movw	r22, r18
    1bb4:	0e 94 9f 1d 	call	0x3b3e	; 0x3b3e <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1bb8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bba:	fc 81       	ldd	r31, Y+4	; 0x04
    1bbc:	26 81       	ldd	r18, Z+6	; 0x06
    1bbe:	37 81       	ldd	r19, Z+7	; 0x07
    1bc0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bc2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bc4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bc6:	88 2f       	mov	r24, r24
    1bc8:	90 e0       	ldi	r25, 0x00	; 0
    1bca:	90 95       	com	r25
    1bcc:	81 95       	neg	r24
    1bce:	9f 4f       	sbci	r25, 0xFF	; 255
    1bd0:	82 0f       	add	r24, r18
    1bd2:	93 1f       	adc	r25, r19
    1bd4:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd6:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd8:	97 83       	std	Z+7, r25	; 0x07
    1bda:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1bdc:	eb 81       	ldd	r30, Y+3	; 0x03
    1bde:	fc 81       	ldd	r31, Y+4	; 0x04
    1be0:	26 81       	ldd	r18, Z+6	; 0x06
    1be2:	37 81       	ldd	r19, Z+7	; 0x07
    1be4:	eb 81       	ldd	r30, Y+3	; 0x03
    1be6:	fc 81       	ldd	r31, Y+4	; 0x04
    1be8:	80 81       	ld	r24, Z
    1bea:	91 81       	ldd	r25, Z+1	; 0x01
    1bec:	28 17       	cp	r18, r24
    1bee:	39 07       	cpc	r19, r25
    1bf0:	90 f4       	brcc	.+36     	; 0x1c16 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1bf2:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf4:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf6:	24 81       	ldd	r18, Z+4	; 0x04
    1bf8:	35 81       	ldd	r19, Z+5	; 0x05
    1bfa:	eb 81       	ldd	r30, Y+3	; 0x03
    1bfc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bfe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c00:	88 2f       	mov	r24, r24
    1c02:	90 e0       	ldi	r25, 0x00	; 0
    1c04:	90 95       	com	r25
    1c06:	81 95       	neg	r24
    1c08:	9f 4f       	sbci	r25, 0xFF	; 255
    1c0a:	82 0f       	add	r24, r18
    1c0c:	93 1f       	adc	r25, r19
    1c0e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c10:	fc 81       	ldd	r31, Y+4	; 0x04
    1c12:	97 83       	std	Z+7, r25	; 0x07
    1c14:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1c16:	8f 81       	ldd	r24, Y+7	; 0x07
    1c18:	82 30       	cpi	r24, 0x02	; 2
    1c1a:	31 f4       	brne	.+12     	; 0x1c28 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c1c:	89 81       	ldd	r24, Y+1	; 0x01
    1c1e:	88 23       	and	r24, r24
    1c20:	19 f0       	breq	.+6      	; 0x1c28 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1c22:	89 81       	ldd	r24, Y+1	; 0x01
    1c24:	81 50       	subi	r24, 0x01	; 1
    1c26:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1c28:	89 81       	ldd	r24, Y+1	; 0x01
    1c2a:	8f 5f       	subi	r24, 0xFF	; 255
    1c2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c30:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    1c32:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1c34:	27 96       	adiw	r28, 0x07	; 7
    1c36:	0f b6       	in	r0, 0x3f	; 63
    1c38:	f8 94       	cli
    1c3a:	de bf       	out	0x3e, r29	; 62
    1c3c:	0f be       	out	0x3f, r0	; 63
    1c3e:	cd bf       	out	0x3d, r28	; 61
    1c40:	cf 91       	pop	r28
    1c42:	df 91       	pop	r29
    1c44:	08 95       	ret

00001c46 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1c46:	df 93       	push	r29
    1c48:	cf 93       	push	r28
    1c4a:	00 d0       	rcall	.+0      	; 0x1c4c <prvCopyDataFromQueue+0x6>
    1c4c:	00 d0       	rcall	.+0      	; 0x1c4e <prvCopyDataFromQueue+0x8>
    1c4e:	cd b7       	in	r28, 0x3d	; 61
    1c50:	de b7       	in	r29, 0x3e	; 62
    1c52:	9a 83       	std	Y+2, r25	; 0x02
    1c54:	89 83       	std	Y+1, r24	; 0x01
    1c56:	7c 83       	std	Y+4, r23	; 0x04
    1c58:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1c5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c5e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c60:	88 23       	and	r24, r24
    1c62:	89 f1       	breq	.+98     	; 0x1cc6 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1c64:	e9 81       	ldd	r30, Y+1	; 0x01
    1c66:	fa 81       	ldd	r31, Y+2	; 0x02
    1c68:	26 81       	ldd	r18, Z+6	; 0x06
    1c6a:	37 81       	ldd	r19, Z+7	; 0x07
    1c6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c70:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c72:	88 2f       	mov	r24, r24
    1c74:	90 e0       	ldi	r25, 0x00	; 0
    1c76:	82 0f       	add	r24, r18
    1c78:	93 1f       	adc	r25, r19
    1c7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c7e:	97 83       	std	Z+7, r25	; 0x07
    1c80:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1c82:	e9 81       	ldd	r30, Y+1	; 0x01
    1c84:	fa 81       	ldd	r31, Y+2	; 0x02
    1c86:	26 81       	ldd	r18, Z+6	; 0x06
    1c88:	37 81       	ldd	r19, Z+7	; 0x07
    1c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c8e:	84 81       	ldd	r24, Z+4	; 0x04
    1c90:	95 81       	ldd	r25, Z+5	; 0x05
    1c92:	28 17       	cp	r18, r24
    1c94:	39 07       	cpc	r19, r25
    1c96:	40 f0       	brcs	.+16     	; 0x1ca8 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1c98:	e9 81       	ldd	r30, Y+1	; 0x01
    1c9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c9c:	80 81       	ld	r24, Z
    1c9e:	91 81       	ldd	r25, Z+1	; 0x01
    1ca0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca4:	97 83       	std	Z+7, r25	; 0x07
    1ca6:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1ca8:	e9 81       	ldd	r30, Y+1	; 0x01
    1caa:	fa 81       	ldd	r31, Y+2	; 0x02
    1cac:	46 81       	ldd	r20, Z+6	; 0x06
    1cae:	57 81       	ldd	r21, Z+7	; 0x07
    1cb0:	e9 81       	ldd	r30, Y+1	; 0x01
    1cb2:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cb6:	28 2f       	mov	r18, r24
    1cb8:	30 e0       	ldi	r19, 0x00	; 0
    1cba:	8b 81       	ldd	r24, Y+3	; 0x03
    1cbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1cbe:	ba 01       	movw	r22, r20
    1cc0:	a9 01       	movw	r20, r18
    1cc2:	0e 94 9f 1d 	call	0x3b3e	; 0x3b3e <memcpy>
	}
}
    1cc6:	0f 90       	pop	r0
    1cc8:	0f 90       	pop	r0
    1cca:	0f 90       	pop	r0
    1ccc:	0f 90       	pop	r0
    1cce:	cf 91       	pop	r28
    1cd0:	df 91       	pop	r29
    1cd2:	08 95       	ret

00001cd4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1cd4:	df 93       	push	r29
    1cd6:	cf 93       	push	r28
    1cd8:	00 d0       	rcall	.+0      	; 0x1cda <prvUnlockQueue+0x6>
    1cda:	00 d0       	rcall	.+0      	; 0x1cdc <prvUnlockQueue+0x8>
    1cdc:	cd b7       	in	r28, 0x3d	; 61
    1cde:	de b7       	in	r29, 0x3e	; 62
    1ce0:	9c 83       	std	Y+4, r25	; 0x04
    1ce2:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1ce4:	0f b6       	in	r0, 0x3f	; 63
    1ce6:	f8 94       	cli
    1ce8:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1cea:	eb 81       	ldd	r30, Y+3	; 0x03
    1cec:	fc 81       	ldd	r31, Y+4	; 0x04
    1cee:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cf0:	8a 83       	std	Y+2, r24	; 0x02
    1cf2:	11 c0       	rjmp	.+34     	; 0x1d16 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1cf4:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf6:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf8:	81 89       	ldd	r24, Z+17	; 0x11
    1cfa:	88 23       	and	r24, r24
    1cfc:	79 f0       	breq	.+30     	; 0x1d1c <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    1d00:	9c 81       	ldd	r25, Y+4	; 0x04
    1d02:	41 96       	adiw	r24, 0x11	; 17
    1d04:	0e 94 cb 14 	call	0x2996	; 0x2996 <xTaskRemoveFromEventList>
    1d08:	88 23       	and	r24, r24
    1d0a:	11 f0       	breq	.+4      	; 0x1d10 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1d0c:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1d10:	8a 81       	ldd	r24, Y+2	; 0x02
    1d12:	81 50       	subi	r24, 0x01	; 1
    1d14:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1d16:	8a 81       	ldd	r24, Y+2	; 0x02
    1d18:	18 16       	cp	r1, r24
    1d1a:	64 f3       	brlt	.-40     	; 0x1cf4 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1d1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d20:	8f ef       	ldi	r24, 0xFF	; 255
    1d22:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1d24:	0f 90       	pop	r0
    1d26:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	f8 94       	cli
    1d2c:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1d2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d30:	fc 81       	ldd	r31, Y+4	; 0x04
    1d32:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d34:	89 83       	std	Y+1, r24	; 0x01
    1d36:	11 c0       	rjmp	.+34     	; 0x1d5a <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d38:	eb 81       	ldd	r30, Y+3	; 0x03
    1d3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d3c:	80 85       	ldd	r24, Z+8	; 0x08
    1d3e:	88 23       	and	r24, r24
    1d40:	79 f0       	breq	.+30     	; 0x1d60 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d42:	8b 81       	ldd	r24, Y+3	; 0x03
    1d44:	9c 81       	ldd	r25, Y+4	; 0x04
    1d46:	08 96       	adiw	r24, 0x08	; 8
    1d48:	0e 94 cb 14 	call	0x2996	; 0x2996 <xTaskRemoveFromEventList>
    1d4c:	88 23       	and	r24, r24
    1d4e:	11 f0       	breq	.+4      	; 0x1d54 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    1d50:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    1d54:	89 81       	ldd	r24, Y+1	; 0x01
    1d56:	81 50       	subi	r24, 0x01	; 1
    1d58:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1d5a:	89 81       	ldd	r24, Y+1	; 0x01
    1d5c:	18 16       	cp	r1, r24
    1d5e:	64 f3       	brlt	.-40     	; 0x1d38 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1d60:	eb 81       	ldd	r30, Y+3	; 0x03
    1d62:	fc 81       	ldd	r31, Y+4	; 0x04
    1d64:	8f ef       	ldi	r24, 0xFF	; 255
    1d66:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1d68:	0f 90       	pop	r0
    1d6a:	0f be       	out	0x3f, r0	; 63
}
    1d6c:	0f 90       	pop	r0
    1d6e:	0f 90       	pop	r0
    1d70:	0f 90       	pop	r0
    1d72:	0f 90       	pop	r0
    1d74:	cf 91       	pop	r28
    1d76:	df 91       	pop	r29
    1d78:	08 95       	ret

00001d7a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    1d7a:	df 93       	push	r29
    1d7c:	cf 93       	push	r28
    1d7e:	00 d0       	rcall	.+0      	; 0x1d80 <prvIsQueueEmpty+0x6>
    1d80:	0f 92       	push	r0
    1d82:	cd b7       	in	r28, 0x3d	; 61
    1d84:	de b7       	in	r29, 0x3e	; 62
    1d86:	9b 83       	std	Y+3, r25	; 0x03
    1d88:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1d8a:	0f b6       	in	r0, 0x3f	; 63
    1d8c:	f8 94       	cli
    1d8e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1d90:	ea 81       	ldd	r30, Y+2	; 0x02
    1d92:	fb 81       	ldd	r31, Y+3	; 0x03
    1d94:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d96:	88 23       	and	r24, r24
    1d98:	19 f4       	brne	.+6      	; 0x1da0 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    1d9a:	81 e0       	ldi	r24, 0x01	; 1
    1d9c:	89 83       	std	Y+1, r24	; 0x01
    1d9e:	01 c0       	rjmp	.+2      	; 0x1da2 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    1da0:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1da2:	0f 90       	pop	r0
    1da4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1da6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1da8:	0f 90       	pop	r0
    1daa:	0f 90       	pop	r0
    1dac:	0f 90       	pop	r0
    1dae:	cf 91       	pop	r28
    1db0:	df 91       	pop	r29
    1db2:	08 95       	ret

00001db4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1db4:	df 93       	push	r29
    1db6:	cf 93       	push	r28
    1db8:	00 d0       	rcall	.+0      	; 0x1dba <xQueueIsQueueEmptyFromISR+0x6>
    1dba:	00 d0       	rcall	.+0      	; 0x1dbc <xQueueIsQueueEmptyFromISR+0x8>
    1dbc:	0f 92       	push	r0
    1dbe:	cd b7       	in	r28, 0x3d	; 61
    1dc0:	de b7       	in	r29, 0x3e	; 62
    1dc2:	9d 83       	std	Y+5, r25	; 0x05
    1dc4:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    1dc6:	8c 81       	ldd	r24, Y+4	; 0x04
    1dc8:	9d 81       	ldd	r25, Y+5	; 0x05
    1dca:	9a 83       	std	Y+2, r25	; 0x02
    1dcc:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1dce:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd0:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dd4:	88 23       	and	r24, r24
    1dd6:	19 f4       	brne	.+6      	; 0x1dde <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    1dd8:	81 e0       	ldi	r24, 0x01	; 1
    1dda:	8b 83       	std	Y+3, r24	; 0x03
    1ddc:	01 c0       	rjmp	.+2      	; 0x1de0 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    1dde:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1de0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1de2:	0f 90       	pop	r0
    1de4:	0f 90       	pop	r0
    1de6:	0f 90       	pop	r0
    1de8:	0f 90       	pop	r0
    1dea:	0f 90       	pop	r0
    1dec:	cf 91       	pop	r28
    1dee:	df 91       	pop	r29
    1df0:	08 95       	ret

00001df2 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    1df2:	df 93       	push	r29
    1df4:	cf 93       	push	r28
    1df6:	00 d0       	rcall	.+0      	; 0x1df8 <prvIsQueueFull+0x6>
    1df8:	0f 92       	push	r0
    1dfa:	cd b7       	in	r28, 0x3d	; 61
    1dfc:	de b7       	in	r29, 0x3e	; 62
    1dfe:	9b 83       	std	Y+3, r25	; 0x03
    1e00:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1e02:	0f b6       	in	r0, 0x3f	; 63
    1e04:	f8 94       	cli
    1e06:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1e08:	ea 81       	ldd	r30, Y+2	; 0x02
    1e0a:	fb 81       	ldd	r31, Y+3	; 0x03
    1e0c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e0e:	ea 81       	ldd	r30, Y+2	; 0x02
    1e10:	fb 81       	ldd	r31, Y+3	; 0x03
    1e12:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e14:	98 17       	cp	r25, r24
    1e16:	19 f4       	brne	.+6      	; 0x1e1e <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	89 83       	std	Y+1, r24	; 0x01
    1e1c:	01 c0       	rjmp	.+2      	; 0x1e20 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    1e1e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1e20:	0f 90       	pop	r0
    1e22:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1e24:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e26:	0f 90       	pop	r0
    1e28:	0f 90       	pop	r0
    1e2a:	0f 90       	pop	r0
    1e2c:	cf 91       	pop	r28
    1e2e:	df 91       	pop	r29
    1e30:	08 95       	ret

00001e32 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1e32:	df 93       	push	r29
    1e34:	cf 93       	push	r28
    1e36:	00 d0       	rcall	.+0      	; 0x1e38 <xQueueIsQueueFullFromISR+0x6>
    1e38:	00 d0       	rcall	.+0      	; 0x1e3a <xQueueIsQueueFullFromISR+0x8>
    1e3a:	0f 92       	push	r0
    1e3c:	cd b7       	in	r28, 0x3d	; 61
    1e3e:	de b7       	in	r29, 0x3e	; 62
    1e40:	9d 83       	std	Y+5, r25	; 0x05
    1e42:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    1e44:	8c 81       	ldd	r24, Y+4	; 0x04
    1e46:	9d 81       	ldd	r25, Y+5	; 0x05
    1e48:	9a 83       	std	Y+2, r25	; 0x02
    1e4a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1e4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e50:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e52:	e9 81       	ldd	r30, Y+1	; 0x01
    1e54:	fa 81       	ldd	r31, Y+2	; 0x02
    1e56:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e58:	98 17       	cp	r25, r24
    1e5a:	19 f4       	brne	.+6      	; 0x1e62 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    1e5c:	81 e0       	ldi	r24, 0x01	; 1
    1e5e:	8b 83       	std	Y+3, r24	; 0x03
    1e60:	01 c0       	rjmp	.+2      	; 0x1e64 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    1e62:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1e64:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1e66:	0f 90       	pop	r0
    1e68:	0f 90       	pop	r0
    1e6a:	0f 90       	pop	r0
    1e6c:	0f 90       	pop	r0
    1e6e:	0f 90       	pop	r0
    1e70:	cf 91       	pop	r28
    1e72:	df 91       	pop	r29
    1e74:	08 95       	ret

00001e76 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    1e76:	8f 92       	push	r8
    1e78:	9f 92       	push	r9
    1e7a:	af 92       	push	r10
    1e7c:	bf 92       	push	r11
    1e7e:	cf 92       	push	r12
    1e80:	df 92       	push	r13
    1e82:	ef 92       	push	r14
    1e84:	ff 92       	push	r15
    1e86:	0f 93       	push	r16
    1e88:	1f 93       	push	r17
    1e8a:	df 93       	push	r29
    1e8c:	cf 93       	push	r28
    1e8e:	cd b7       	in	r28, 0x3d	; 61
    1e90:	de b7       	in	r29, 0x3e	; 62
    1e92:	60 97       	sbiw	r28, 0x10	; 16
    1e94:	0f b6       	in	r0, 0x3f	; 63
    1e96:	f8 94       	cli
    1e98:	de bf       	out	0x3e, r29	; 62
    1e9a:	0f be       	out	0x3f, r0	; 63
    1e9c:	cd bf       	out	0x3d, r28	; 61
    1e9e:	9f 83       	std	Y+7, r25	; 0x07
    1ea0:	8e 83       	std	Y+6, r24	; 0x06
    1ea2:	79 87       	std	Y+9, r23	; 0x09
    1ea4:	68 87       	std	Y+8, r22	; 0x08
    1ea6:	5b 87       	std	Y+11, r21	; 0x0b
    1ea8:	4a 87       	std	Y+10, r20	; 0x0a
    1eaa:	3d 87       	std	Y+13, r19	; 0x0d
    1eac:	2c 87       	std	Y+12, r18	; 0x0c
    1eae:	0e 87       	std	Y+14, r16	; 0x0e
    1eb0:	f8 8a       	std	Y+16, r15	; 0x10
    1eb2:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    1eb4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1eb6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1eb8:	0e 94 93 03 	call	0x726	; 0x726 <pvPortMalloc>
    1ebc:	9a 83       	std	Y+2, r25	; 0x02
    1ebe:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    1ec0:	89 81       	ldd	r24, Y+1	; 0x01
    1ec2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ec4:	00 97       	sbiw	r24, 0x00	; 0
    1ec6:	b1 f0       	breq	.+44     	; 0x1ef4 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    1ec8:	86 e2       	ldi	r24, 0x26	; 38
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	0e 94 93 03 	call	0x726	; 0x726 <pvPortMalloc>
    1ed0:	9d 83       	std	Y+5, r25	; 0x05
    1ed2:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    1ed4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ed6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ed8:	00 97       	sbiw	r24, 0x00	; 0
    1eda:	39 f0       	breq	.+14     	; 0x1eea <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1edc:	ec 81       	ldd	r30, Y+4	; 0x04
    1ede:	fd 81       	ldd	r31, Y+5	; 0x05
    1ee0:	89 81       	ldd	r24, Y+1	; 0x01
    1ee2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee4:	90 8f       	std	Z+24, r25	; 0x18
    1ee6:	87 8b       	std	Z+23, r24	; 0x17
    1ee8:	07 c0       	rjmp	.+14     	; 0x1ef8 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1eea:	89 81       	ldd	r24, Y+1	; 0x01
    1eec:	9a 81       	ldd	r25, Y+2	; 0x02
    1eee:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <vPortFree>
    1ef2:	02 c0       	rjmp	.+4      	; 0x1ef8 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    1ef4:	1d 82       	std	Y+5, r1	; 0x05
    1ef6:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    1ef8:	8c 81       	ldd	r24, Y+4	; 0x04
    1efa:	9d 81       	ldd	r25, Y+5	; 0x05
    1efc:	00 97       	sbiw	r24, 0x00	; 0
    1efe:	e9 f0       	breq	.+58     	; 0x1f3a <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    1f00:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f02:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f04:	9c 01       	movw	r18, r24
    1f06:	40 e0       	ldi	r20, 0x00	; 0
    1f08:	50 e0       	ldi	r21, 0x00	; 0
    1f0a:	8e 81       	ldd	r24, Y+6	; 0x06
    1f0c:	9f 81       	ldd	r25, Y+7	; 0x07
    1f0e:	68 85       	ldd	r22, Y+8	; 0x08
    1f10:	79 85       	ldd	r23, Y+9	; 0x09
    1f12:	ec 85       	ldd	r30, Y+12	; 0x0c
    1f14:	fd 85       	ldd	r31, Y+13	; 0x0d
    1f16:	af 85       	ldd	r26, Y+15	; 0x0f
    1f18:	b8 89       	ldd	r27, Y+16	; 0x10
    1f1a:	ac 80       	ldd	r10, Y+4	; 0x04
    1f1c:	bd 80       	ldd	r11, Y+5	; 0x05
    1f1e:	8f 01       	movw	r16, r30
    1f20:	ee 84       	ldd	r14, Y+14	; 0x0e
    1f22:	6d 01       	movw	r12, r26
    1f24:	88 24       	eor	r8, r8
    1f26:	99 24       	eor	r9, r9
    1f28:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    1f2c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f2e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f30:	0e 94 6f 10 	call	0x20de	; 0x20de <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    1f34:	81 e0       	ldi	r24, 0x01	; 1
    1f36:	8b 83       	std	Y+3, r24	; 0x03
    1f38:	02 c0       	rjmp	.+4      	; 0x1f3e <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1f3a:	8f ef       	ldi	r24, 0xFF	; 255
    1f3c:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    1f3e:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    1f40:	60 96       	adiw	r28, 0x10	; 16
    1f42:	0f b6       	in	r0, 0x3f	; 63
    1f44:	f8 94       	cli
    1f46:	de bf       	out	0x3e, r29	; 62
    1f48:	0f be       	out	0x3f, r0	; 63
    1f4a:	cd bf       	out	0x3d, r28	; 61
    1f4c:	cf 91       	pop	r28
    1f4e:	df 91       	pop	r29
    1f50:	1f 91       	pop	r17
    1f52:	0f 91       	pop	r16
    1f54:	ff 90       	pop	r15
    1f56:	ef 90       	pop	r14
    1f58:	df 90       	pop	r13
    1f5a:	cf 90       	pop	r12
    1f5c:	bf 90       	pop	r11
    1f5e:	af 90       	pop	r10
    1f60:	9f 90       	pop	r9
    1f62:	8f 90       	pop	r8
    1f64:	08 95       	ret

00001f66 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    1f66:	8f 92       	push	r8
    1f68:	9f 92       	push	r9
    1f6a:	af 92       	push	r10
    1f6c:	bf 92       	push	r11
    1f6e:	cf 92       	push	r12
    1f70:	df 92       	push	r13
    1f72:	ef 92       	push	r14
    1f74:	0f 93       	push	r16
    1f76:	1f 93       	push	r17
    1f78:	df 93       	push	r29
    1f7a:	cf 93       	push	r28
    1f7c:	cd b7       	in	r28, 0x3d	; 61
    1f7e:	de b7       	in	r29, 0x3e	; 62
    1f80:	64 97       	sbiw	r28, 0x14	; 20
    1f82:	0f b6       	in	r0, 0x3f	; 63
    1f84:	f8 94       	cli
    1f86:	de bf       	out	0x3e, r29	; 62
    1f88:	0f be       	out	0x3f, r0	; 63
    1f8a:	cd bf       	out	0x3d, r28	; 61
    1f8c:	9d 83       	std	Y+5, r25	; 0x05
    1f8e:	8c 83       	std	Y+4, r24	; 0x04
    1f90:	7f 83       	std	Y+7, r23	; 0x07
    1f92:	6e 83       	std	Y+6, r22	; 0x06
    1f94:	28 87       	std	Y+8, r18	; 0x08
    1f96:	39 87       	std	Y+9, r19	; 0x09
    1f98:	4a 87       	std	Y+10, r20	; 0x0a
    1f9a:	5b 87       	std	Y+11, r21	; 0x0b
    1f9c:	1d 87       	std	Y+13, r17	; 0x0d
    1f9e:	0c 87       	std	Y+12, r16	; 0x0c
    1fa0:	ee 86       	std	Y+14, r14	; 0x0e
    1fa2:	d8 8a       	std	Y+16, r13	; 0x10
    1fa4:	cf 86       	std	Y+15, r12	; 0x0f
    1fa6:	ba 8a       	std	Y+18, r11	; 0x12
    1fa8:	a9 8a       	std	Y+17, r10	; 0x11
    1faa:	9c 8a       	std	Y+20, r9	; 0x14
    1fac:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    1fae:	e9 89       	ldd	r30, Y+17	; 0x11
    1fb0:	fa 89       	ldd	r31, Y+18	; 0x12
    1fb2:	27 89       	ldd	r18, Z+23	; 0x17
    1fb4:	30 8d       	ldd	r19, Z+24	; 0x18
    1fb6:	88 85       	ldd	r24, Y+8	; 0x08
    1fb8:	99 85       	ldd	r25, Y+9	; 0x09
    1fba:	01 97       	sbiw	r24, 0x01	; 1
    1fbc:	82 0f       	add	r24, r18
    1fbe:	93 1f       	adc	r25, r19
    1fc0:	9b 83       	std	Y+3, r25	; 0x03
    1fc2:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    1fc4:	8e 81       	ldd	r24, Y+6	; 0x06
    1fc6:	9f 81       	ldd	r25, Y+7	; 0x07
    1fc8:	00 97       	sbiw	r24, 0x00	; 0
    1fca:	51 f1       	breq	.+84     	; 0x2020 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1fcc:	19 82       	std	Y+1, r1	; 0x01
    1fce:	21 c0       	rjmp	.+66     	; 0x2012 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1fd0:	89 81       	ldd	r24, Y+1	; 0x01
    1fd2:	48 2f       	mov	r20, r24
    1fd4:	50 e0       	ldi	r21, 0x00	; 0
    1fd6:	89 81       	ldd	r24, Y+1	; 0x01
    1fd8:	28 2f       	mov	r18, r24
    1fda:	30 e0       	ldi	r19, 0x00	; 0
    1fdc:	8e 81       	ldd	r24, Y+6	; 0x06
    1fde:	9f 81       	ldd	r25, Y+7	; 0x07
    1fe0:	fc 01       	movw	r30, r24
    1fe2:	e2 0f       	add	r30, r18
    1fe4:	f3 1f       	adc	r31, r19
    1fe6:	20 81       	ld	r18, Z
    1fe8:	89 89       	ldd	r24, Y+17	; 0x11
    1fea:	9a 89       	ldd	r25, Y+18	; 0x12
    1fec:	84 0f       	add	r24, r20
    1fee:	95 1f       	adc	r25, r21
    1ff0:	fc 01       	movw	r30, r24
    1ff2:	79 96       	adiw	r30, 0x19	; 25
    1ff4:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    1ff6:	89 81       	ldd	r24, Y+1	; 0x01
    1ff8:	28 2f       	mov	r18, r24
    1ffa:	30 e0       	ldi	r19, 0x00	; 0
    1ffc:	8e 81       	ldd	r24, Y+6	; 0x06
    1ffe:	9f 81       	ldd	r25, Y+7	; 0x07
    2000:	fc 01       	movw	r30, r24
    2002:	e2 0f       	add	r30, r18
    2004:	f3 1f       	adc	r31, r19
    2006:	80 81       	ld	r24, Z
    2008:	88 23       	and	r24, r24
    200a:	31 f0       	breq	.+12     	; 0x2018 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    200c:	89 81       	ldd	r24, Y+1	; 0x01
    200e:	8f 5f       	subi	r24, 0xFF	; 255
    2010:	89 83       	std	Y+1, r24	; 0x01
    2012:	89 81       	ldd	r24, Y+1	; 0x01
    2014:	88 30       	cpi	r24, 0x08	; 8
    2016:	e0 f2       	brcs	.-72     	; 0x1fd0 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2018:	e9 89       	ldd	r30, Y+17	; 0x11
    201a:	fa 89       	ldd	r31, Y+18	; 0x12
    201c:	10 a2       	std	Z+32, r1	; 0x20
    201e:	03 c0       	rjmp	.+6      	; 0x2026 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    2020:	e9 89       	ldd	r30, Y+17	; 0x11
    2022:	fa 89       	ldd	r31, Y+18	; 0x12
    2024:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2026:	8e 85       	ldd	r24, Y+14	; 0x0e
    2028:	84 30       	cpi	r24, 0x04	; 4
    202a:	10 f0       	brcs	.+4      	; 0x2030 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    202c:	83 e0       	ldi	r24, 0x03	; 3
    202e:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    2030:	e9 89       	ldd	r30, Y+17	; 0x11
    2032:	fa 89       	ldd	r31, Y+18	; 0x12
    2034:	8e 85       	ldd	r24, Y+14	; 0x0e
    2036:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2038:	89 89       	ldd	r24, Y+17	; 0x11
    203a:	9a 89       	ldd	r25, Y+18	; 0x12
    203c:	02 96       	adiw	r24, 0x02	; 2
    203e:	0e 94 39 04 	call	0x872	; 0x872 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    2042:	89 89       	ldd	r24, Y+17	; 0x11
    2044:	9a 89       	ldd	r25, Y+18	; 0x12
    2046:	0c 96       	adiw	r24, 0x0c	; 12
    2048:	0e 94 39 04 	call	0x872	; 0x872 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    204c:	e9 89       	ldd	r30, Y+17	; 0x11
    204e:	fa 89       	ldd	r31, Y+18	; 0x12
    2050:	89 89       	ldd	r24, Y+17	; 0x11
    2052:	9a 89       	ldd	r25, Y+18	; 0x12
    2054:	91 87       	std	Z+9, r25	; 0x09
    2056:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2058:	8e 85       	ldd	r24, Y+14	; 0x0e
    205a:	28 2f       	mov	r18, r24
    205c:	30 e0       	ldi	r19, 0x00	; 0
    205e:	84 e0       	ldi	r24, 0x04	; 4
    2060:	90 e0       	ldi	r25, 0x00	; 0
    2062:	82 1b       	sub	r24, r18
    2064:	93 0b       	sbc	r25, r19
    2066:	e9 89       	ldd	r30, Y+17	; 0x11
    2068:	fa 89       	ldd	r31, Y+18	; 0x12
    206a:	95 87       	std	Z+13, r25	; 0x0d
    206c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    206e:	e9 89       	ldd	r30, Y+17	; 0x11
    2070:	fa 89       	ldd	r31, Y+18	; 0x12
    2072:	89 89       	ldd	r24, Y+17	; 0x11
    2074:	9a 89       	ldd	r25, Y+18	; 0x12
    2076:	93 8b       	std	Z+19, r25	; 0x13
    2078:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    207a:	e9 89       	ldd	r30, Y+17	; 0x11
    207c:	fa 89       	ldd	r31, Y+18	; 0x12
    207e:	11 a2       	std	Z+33, r1	; 0x21
    2080:	12 a2       	std	Z+34, r1	; 0x22
    2082:	13 a2       	std	Z+35, r1	; 0x23
    2084:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2086:	e9 89       	ldd	r30, Y+17	; 0x11
    2088:	fa 89       	ldd	r31, Y+18	; 0x12
    208a:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    208c:	8a 81       	ldd	r24, Y+2	; 0x02
    208e:	9b 81       	ldd	r25, Y+3	; 0x03
    2090:	2c 81       	ldd	r18, Y+4	; 0x04
    2092:	3d 81       	ldd	r19, Y+5	; 0x05
    2094:	4c 85       	ldd	r20, Y+12	; 0x0c
    2096:	5d 85       	ldd	r21, Y+13	; 0x0d
    2098:	b9 01       	movw	r22, r18
    209a:	0e 94 45 05 	call	0xa8a	; 0xa8a <pxPortInitialiseStack>
    209e:	e9 89       	ldd	r30, Y+17	; 0x11
    20a0:	fa 89       	ldd	r31, Y+18	; 0x12
    20a2:	91 83       	std	Z+1, r25	; 0x01
    20a4:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    20a6:	8f 85       	ldd	r24, Y+15	; 0x0f
    20a8:	98 89       	ldd	r25, Y+16	; 0x10
    20aa:	00 97       	sbiw	r24, 0x00	; 0
    20ac:	31 f0       	breq	.+12     	; 0x20ba <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    20ae:	ef 85       	ldd	r30, Y+15	; 0x0f
    20b0:	f8 89       	ldd	r31, Y+16	; 0x10
    20b2:	89 89       	ldd	r24, Y+17	; 0x11
    20b4:	9a 89       	ldd	r25, Y+18	; 0x12
    20b6:	91 83       	std	Z+1, r25	; 0x01
    20b8:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    20ba:	64 96       	adiw	r28, 0x14	; 20
    20bc:	0f b6       	in	r0, 0x3f	; 63
    20be:	f8 94       	cli
    20c0:	de bf       	out	0x3e, r29	; 62
    20c2:	0f be       	out	0x3f, r0	; 63
    20c4:	cd bf       	out	0x3d, r28	; 61
    20c6:	cf 91       	pop	r28
    20c8:	df 91       	pop	r29
    20ca:	1f 91       	pop	r17
    20cc:	0f 91       	pop	r16
    20ce:	ef 90       	pop	r14
    20d0:	df 90       	pop	r13
    20d2:	cf 90       	pop	r12
    20d4:	bf 90       	pop	r11
    20d6:	af 90       	pop	r10
    20d8:	9f 90       	pop	r9
    20da:	8f 90       	pop	r8
    20dc:	08 95       	ret

000020de <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    20de:	df 93       	push	r29
    20e0:	cf 93       	push	r28
    20e2:	00 d0       	rcall	.+0      	; 0x20e4 <prvAddNewTaskToReadyList+0x6>
    20e4:	cd b7       	in	r28, 0x3d	; 61
    20e6:	de b7       	in	r29, 0x3e	; 62
    20e8:	9a 83       	std	Y+2, r25	; 0x02
    20ea:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    20ec:	0f b6       	in	r0, 0x3f	; 63
    20ee:	f8 94       	cli
    20f0:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    20f2:	80 91 dd 02 	lds	r24, 0x02DD
    20f6:	8f 5f       	subi	r24, 0xFF	; 255
    20f8:	80 93 dd 02 	sts	0x02DD, r24
		if( pxCurrentTCB == NULL )
    20fc:	80 91 da 02 	lds	r24, 0x02DA
    2100:	90 91 db 02 	lds	r25, 0x02DB
    2104:	00 97       	sbiw	r24, 0x00	; 0
    2106:	69 f4       	brne	.+26     	; 0x2122 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    2108:	89 81       	ldd	r24, Y+1	; 0x01
    210a:	9a 81       	ldd	r25, Y+2	; 0x02
    210c:	90 93 db 02 	sts	0x02DB, r25
    2110:	80 93 da 02 	sts	0x02DA, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2114:	80 91 dd 02 	lds	r24, 0x02DD
    2118:	81 30       	cpi	r24, 0x01	; 1
    211a:	b9 f4       	brne	.+46     	; 0x214a <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    211c:	0e 94 41 16 	call	0x2c82	; 0x2c82 <prvInitialiseTaskLists>
    2120:	14 c0       	rjmp	.+40     	; 0x214a <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    2122:	80 91 e1 02 	lds	r24, 0x02E1
    2126:	88 23       	and	r24, r24
    2128:	81 f4       	brne	.+32     	; 0x214a <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    212a:	e0 91 da 02 	lds	r30, 0x02DA
    212e:	f0 91 db 02 	lds	r31, 0x02DB
    2132:	96 89       	ldd	r25, Z+22	; 0x16
    2134:	e9 81       	ldd	r30, Y+1	; 0x01
    2136:	fa 81       	ldd	r31, Y+2	; 0x02
    2138:	86 89       	ldd	r24, Z+22	; 0x16
    213a:	89 17       	cp	r24, r25
    213c:	30 f0       	brcs	.+12     	; 0x214a <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    213e:	89 81       	ldd	r24, Y+1	; 0x01
    2140:	9a 81       	ldd	r25, Y+2	; 0x02
    2142:	90 93 db 02 	sts	0x02DB, r25
    2146:	80 93 da 02 	sts	0x02DA, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    214a:	80 91 e5 02 	lds	r24, 0x02E5
    214e:	8f 5f       	subi	r24, 0xFF	; 255
    2150:	80 93 e5 02 	sts	0x02E5, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    2154:	e9 81       	ldd	r30, Y+1	; 0x01
    2156:	fa 81       	ldd	r31, Y+2	; 0x02
    2158:	96 89       	ldd	r25, Z+22	; 0x16
    215a:	80 91 e0 02 	lds	r24, 0x02E0
    215e:	89 17       	cp	r24, r25
    2160:	28 f4       	brcc	.+10     	; 0x216c <prvAddNewTaskToReadyList+0x8e>
    2162:	e9 81       	ldd	r30, Y+1	; 0x01
    2164:	fa 81       	ldd	r31, Y+2	; 0x02
    2166:	86 89       	ldd	r24, Z+22	; 0x16
    2168:	80 93 e0 02 	sts	0x02E0, r24
    216c:	e9 81       	ldd	r30, Y+1	; 0x01
    216e:	fa 81       	ldd	r31, Y+2	; 0x02
    2170:	86 89       	ldd	r24, Z+22	; 0x16
    2172:	28 2f       	mov	r18, r24
    2174:	30 e0       	ldi	r19, 0x00	; 0
    2176:	c9 01       	movw	r24, r18
    2178:	88 0f       	add	r24, r24
    217a:	99 1f       	adc	r25, r25
    217c:	88 0f       	add	r24, r24
    217e:	99 1f       	adc	r25, r25
    2180:	88 0f       	add	r24, r24
    2182:	99 1f       	adc	r25, r25
    2184:	82 0f       	add	r24, r18
    2186:	93 1f       	adc	r25, r19
    2188:	ac 01       	movw	r20, r24
    218a:	45 51       	subi	r20, 0x15	; 21
    218c:	5d 4f       	sbci	r21, 0xFD	; 253
    218e:	89 81       	ldd	r24, Y+1	; 0x01
    2190:	9a 81       	ldd	r25, Y+2	; 0x02
    2192:	9c 01       	movw	r18, r24
    2194:	2e 5f       	subi	r18, 0xFE	; 254
    2196:	3f 4f       	sbci	r19, 0xFF	; 255
    2198:	ca 01       	movw	r24, r20
    219a:	b9 01       	movw	r22, r18
    219c:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    21a0:	0f 90       	pop	r0
    21a2:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    21a4:	80 91 e1 02 	lds	r24, 0x02E1
    21a8:	88 23       	and	r24, r24
    21aa:	61 f0       	breq	.+24     	; 0x21c4 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    21ac:	e0 91 da 02 	lds	r30, 0x02DA
    21b0:	f0 91 db 02 	lds	r31, 0x02DB
    21b4:	96 89       	ldd	r25, Z+22	; 0x16
    21b6:	e9 81       	ldd	r30, Y+1	; 0x01
    21b8:	fa 81       	ldd	r31, Y+2	; 0x02
    21ba:	86 89       	ldd	r24, Z+22	; 0x16
    21bc:	98 17       	cp	r25, r24
    21be:	10 f4       	brcc	.+4      	; 0x21c4 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    21c0:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    21c4:	0f 90       	pop	r0
    21c6:	0f 90       	pop	r0
    21c8:	cf 91       	pop	r28
    21ca:	df 91       	pop	r29
    21cc:	08 95       	ret

000021ce <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    21ce:	df 93       	push	r29
    21d0:	cf 93       	push	r28
    21d2:	00 d0       	rcall	.+0      	; 0x21d4 <vTaskDelete+0x6>
    21d4:	00 d0       	rcall	.+0      	; 0x21d6 <vTaskDelete+0x8>
    21d6:	00 d0       	rcall	.+0      	; 0x21d8 <vTaskDelete+0xa>
    21d8:	cd b7       	in	r28, 0x3d	; 61
    21da:	de b7       	in	r29, 0x3e	; 62
    21dc:	9c 83       	std	Y+4, r25	; 0x04
    21de:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    21e0:	0f b6       	in	r0, 0x3f	; 63
    21e2:	f8 94       	cli
    21e4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    21e6:	8b 81       	ldd	r24, Y+3	; 0x03
    21e8:	9c 81       	ldd	r25, Y+4	; 0x04
    21ea:	00 97       	sbiw	r24, 0x00	; 0
    21ec:	39 f4       	brne	.+14     	; 0x21fc <vTaskDelete+0x2e>
    21ee:	80 91 da 02 	lds	r24, 0x02DA
    21f2:	90 91 db 02 	lds	r25, 0x02DB
    21f6:	9e 83       	std	Y+6, r25	; 0x06
    21f8:	8d 83       	std	Y+5, r24	; 0x05
    21fa:	04 c0       	rjmp	.+8      	; 0x2204 <vTaskDelete+0x36>
    21fc:	8b 81       	ldd	r24, Y+3	; 0x03
    21fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2200:	9e 83       	std	Y+6, r25	; 0x06
    2202:	8d 83       	std	Y+5, r24	; 0x05
    2204:	8d 81       	ldd	r24, Y+5	; 0x05
    2206:	9e 81       	ldd	r25, Y+6	; 0x06
    2208:	9a 83       	std	Y+2, r25	; 0x02
    220a:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    220c:	89 81       	ldd	r24, Y+1	; 0x01
    220e:	9a 81       	ldd	r25, Y+2	; 0x02
    2210:	02 96       	adiw	r24, 0x02	; 2
    2212:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2216:	e9 81       	ldd	r30, Y+1	; 0x01
    2218:	fa 81       	ldd	r31, Y+2	; 0x02
    221a:	84 89       	ldd	r24, Z+20	; 0x14
    221c:	95 89       	ldd	r25, Z+21	; 0x15
    221e:	00 97       	sbiw	r24, 0x00	; 0
    2220:	29 f0       	breq	.+10     	; 0x222c <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2222:	89 81       	ldd	r24, Y+1	; 0x01
    2224:	9a 81       	ldd	r25, Y+2	; 0x02
    2226:	0c 96       	adiw	r24, 0x0c	; 12
    2228:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    222c:	80 91 e5 02 	lds	r24, 0x02E5
    2230:	8f 5f       	subi	r24, 0xFF	; 255
    2232:	80 93 e5 02 	sts	0x02E5, r24

			if( pxTCB == pxCurrentTCB )
    2236:	20 91 da 02 	lds	r18, 0x02DA
    223a:	30 91 db 02 	lds	r19, 0x02DB
    223e:	89 81       	ldd	r24, Y+1	; 0x01
    2240:	9a 81       	ldd	r25, Y+2	; 0x02
    2242:	82 17       	cp	r24, r18
    2244:	93 07       	cpc	r25, r19
    2246:	81 f4       	brne	.+32     	; 0x2268 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    2248:	89 81       	ldd	r24, Y+1	; 0x01
    224a:	9a 81       	ldd	r25, Y+2	; 0x02
    224c:	9c 01       	movw	r18, r24
    224e:	2e 5f       	subi	r18, 0xFE	; 254
    2250:	3f 4f       	sbci	r19, 0xFF	; 255
    2252:	8e e2       	ldi	r24, 0x2E	; 46
    2254:	93 e0       	ldi	r25, 0x03	; 3
    2256:	b9 01       	movw	r22, r18
    2258:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    225c:	80 91 dc 02 	lds	r24, 0x02DC
    2260:	8f 5f       	subi	r24, 0xFF	; 255
    2262:	80 93 dc 02 	sts	0x02DC, r24
    2266:	0b c0       	rjmp	.+22     	; 0x227e <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    2268:	80 91 dd 02 	lds	r24, 0x02DD
    226c:	81 50       	subi	r24, 0x01	; 1
    226e:	80 93 dd 02 	sts	0x02DD, r24
				prvDeleteTCB( pxTCB );
    2272:	89 81       	ldd	r24, Y+1	; 0x01
    2274:	9a 81       	ldd	r25, Y+2	; 0x02
    2276:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    227a:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    227e:	0f 90       	pop	r0
    2280:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    2282:	80 91 e1 02 	lds	r24, 0x02E1
    2286:	88 23       	and	r24, r24
    2288:	59 f0       	breq	.+22     	; 0x22a0 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    228a:	20 91 da 02 	lds	r18, 0x02DA
    228e:	30 91 db 02 	lds	r19, 0x02DB
    2292:	89 81       	ldd	r24, Y+1	; 0x01
    2294:	9a 81       	ldd	r25, Y+2	; 0x02
    2296:	82 17       	cp	r24, r18
    2298:	93 07       	cpc	r25, r19
    229a:	11 f4       	brne	.+4      	; 0x22a0 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    229c:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    22a0:	26 96       	adiw	r28, 0x06	; 6
    22a2:	0f b6       	in	r0, 0x3f	; 63
    22a4:	f8 94       	cli
    22a6:	de bf       	out	0x3e, r29	; 62
    22a8:	0f be       	out	0x3f, r0	; 63
    22aa:	cd bf       	out	0x3d, r28	; 61
    22ac:	cf 91       	pop	r28
    22ae:	df 91       	pop	r29
    22b0:	08 95       	ret

000022b2 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    22b2:	df 93       	push	r29
    22b4:	cf 93       	push	r28
    22b6:	cd b7       	in	r28, 0x3d	; 61
    22b8:	de b7       	in	r29, 0x3e	; 62
    22ba:	2a 97       	sbiw	r28, 0x0a	; 10
    22bc:	0f b6       	in	r0, 0x3f	; 63
    22be:	f8 94       	cli
    22c0:	de bf       	out	0x3e, r29	; 62
    22c2:	0f be       	out	0x3f, r0	; 63
    22c4:	cd bf       	out	0x3d, r28	; 61
    22c6:	98 87       	std	Y+8, r25	; 0x08
    22c8:	8f 83       	std	Y+7, r24	; 0x07
    22ca:	7a 87       	std	Y+10, r23	; 0x0a
    22cc:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    22ce:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    22d0:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    22d4:	80 91 de 02 	lds	r24, 0x02DE
    22d8:	90 91 df 02 	lds	r25, 0x02DF
    22dc:	9a 83       	std	Y+2, r25	; 0x02
    22de:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    22e0:	ef 81       	ldd	r30, Y+7	; 0x07
    22e2:	f8 85       	ldd	r31, Y+8	; 0x08
    22e4:	20 81       	ld	r18, Z
    22e6:	31 81       	ldd	r19, Z+1	; 0x01
    22e8:	89 85       	ldd	r24, Y+9	; 0x09
    22ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    22ec:	82 0f       	add	r24, r18
    22ee:	93 1f       	adc	r25, r19
    22f0:	9e 83       	std	Y+6, r25	; 0x06
    22f2:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    22f4:	ef 81       	ldd	r30, Y+7	; 0x07
    22f6:	f8 85       	ldd	r31, Y+8	; 0x08
    22f8:	20 81       	ld	r18, Z
    22fa:	31 81       	ldd	r19, Z+1	; 0x01
    22fc:	89 81       	ldd	r24, Y+1	; 0x01
    22fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2300:	82 17       	cp	r24, r18
    2302:	93 07       	cpc	r25, r19
    2304:	98 f4       	brcc	.+38     	; 0x232c <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2306:	ef 81       	ldd	r30, Y+7	; 0x07
    2308:	f8 85       	ldd	r31, Y+8	; 0x08
    230a:	20 81       	ld	r18, Z
    230c:	31 81       	ldd	r19, Z+1	; 0x01
    230e:	8d 81       	ldd	r24, Y+5	; 0x05
    2310:	9e 81       	ldd	r25, Y+6	; 0x06
    2312:	82 17       	cp	r24, r18
    2314:	93 07       	cpc	r25, r19
    2316:	e0 f4       	brcc	.+56     	; 0x2350 <vTaskDelayUntil+0x9e>
    2318:	2d 81       	ldd	r18, Y+5	; 0x05
    231a:	3e 81       	ldd	r19, Y+6	; 0x06
    231c:	89 81       	ldd	r24, Y+1	; 0x01
    231e:	9a 81       	ldd	r25, Y+2	; 0x02
    2320:	82 17       	cp	r24, r18
    2322:	93 07       	cpc	r25, r19
    2324:	a8 f4       	brcc	.+42     	; 0x2350 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2326:	81 e0       	ldi	r24, 0x01	; 1
    2328:	8b 83       	std	Y+3, r24	; 0x03
    232a:	12 c0       	rjmp	.+36     	; 0x2350 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    232c:	ef 81       	ldd	r30, Y+7	; 0x07
    232e:	f8 85       	ldd	r31, Y+8	; 0x08
    2330:	20 81       	ld	r18, Z
    2332:	31 81       	ldd	r19, Z+1	; 0x01
    2334:	8d 81       	ldd	r24, Y+5	; 0x05
    2336:	9e 81       	ldd	r25, Y+6	; 0x06
    2338:	82 17       	cp	r24, r18
    233a:	93 07       	cpc	r25, r19
    233c:	38 f0       	brcs	.+14     	; 0x234c <vTaskDelayUntil+0x9a>
    233e:	2d 81       	ldd	r18, Y+5	; 0x05
    2340:	3e 81       	ldd	r19, Y+6	; 0x06
    2342:	89 81       	ldd	r24, Y+1	; 0x01
    2344:	9a 81       	ldd	r25, Y+2	; 0x02
    2346:	82 17       	cp	r24, r18
    2348:	93 07       	cpc	r25, r19
    234a:	10 f4       	brcc	.+4      	; 0x2350 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    234c:	81 e0       	ldi	r24, 0x01	; 1
    234e:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2350:	ef 81       	ldd	r30, Y+7	; 0x07
    2352:	f8 85       	ldd	r31, Y+8	; 0x08
    2354:	8d 81       	ldd	r24, Y+5	; 0x05
    2356:	9e 81       	ldd	r25, Y+6	; 0x06
    2358:	91 83       	std	Z+1, r25	; 0x01
    235a:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    235c:	8b 81       	ldd	r24, Y+3	; 0x03
    235e:	88 23       	and	r24, r24
    2360:	49 f0       	breq	.+18     	; 0x2374 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2362:	8d 81       	ldd	r24, Y+5	; 0x05
    2364:	9e 81       	ldd	r25, Y+6	; 0x06
    2366:	29 81       	ldd	r18, Y+1	; 0x01
    2368:	3a 81       	ldd	r19, Y+2	; 0x02
    236a:	82 1b       	sub	r24, r18
    236c:	93 0b       	sbc	r25, r19
    236e:	60 e0       	ldi	r22, 0x00	; 0
    2370:	0e 94 bd 1a 	call	0x357a	; 0x357a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2374:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
    2378:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    237a:	8c 81       	ldd	r24, Y+4	; 0x04
    237c:	88 23       	and	r24, r24
    237e:	11 f4       	brne	.+4      	; 0x2384 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    2380:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2384:	2a 96       	adiw	r28, 0x0a	; 10
    2386:	0f b6       	in	r0, 0x3f	; 63
    2388:	f8 94       	cli
    238a:	de bf       	out	0x3e, r29	; 62
    238c:	0f be       	out	0x3f, r0	; 63
    238e:	cd bf       	out	0x3d, r28	; 61
    2390:	cf 91       	pop	r28
    2392:	df 91       	pop	r29
    2394:	08 95       	ret

00002396 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2396:	df 93       	push	r29
    2398:	cf 93       	push	r28
    239a:	00 d0       	rcall	.+0      	; 0x239c <vTaskDelay+0x6>
    239c:	0f 92       	push	r0
    239e:	cd b7       	in	r28, 0x3d	; 61
    23a0:	de b7       	in	r29, 0x3e	; 62
    23a2:	9b 83       	std	Y+3, r25	; 0x03
    23a4:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    23a6:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    23a8:	8a 81       	ldd	r24, Y+2	; 0x02
    23aa:	9b 81       	ldd	r25, Y+3	; 0x03
    23ac:	00 97       	sbiw	r24, 0x00	; 0
    23ae:	51 f0       	breq	.+20     	; 0x23c4 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    23b0:	0e 94 2b 12 	call	0x2456	; 0x2456 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    23b4:	8a 81       	ldd	r24, Y+2	; 0x02
    23b6:	9b 81       	ldd	r25, Y+3	; 0x03
    23b8:	60 e0       	ldi	r22, 0x00	; 0
    23ba:	0e 94 bd 1a 	call	0x357a	; 0x357a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    23be:	0e 94 37 12 	call	0x246e	; 0x246e <xTaskResumeAll>
    23c2:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    23c4:	89 81       	ldd	r24, Y+1	; 0x01
    23c6:	88 23       	and	r24, r24
    23c8:	11 f4       	brne	.+4      	; 0x23ce <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    23ca:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    23ce:	0f 90       	pop	r0
    23d0:	0f 90       	pop	r0
    23d2:	0f 90       	pop	r0
    23d4:	cf 91       	pop	r28
    23d6:	df 91       	pop	r29
    23d8:	08 95       	ret

000023da <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    23da:	ef 92       	push	r14
    23dc:	ff 92       	push	r15
    23de:	0f 93       	push	r16
    23e0:	df 93       	push	r29
    23e2:	cf 93       	push	r28
    23e4:	0f 92       	push	r0
    23e6:	cd b7       	in	r28, 0x3d	; 61
    23e8:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    23ea:	87 e3       	ldi	r24, 0x37	; 55
    23ec:	96 e1       	ldi	r25, 0x16	; 22
    23ee:	20 e6       	ldi	r18, 0x60	; 96
    23f0:	30 e0       	ldi	r19, 0x00	; 0
    23f2:	e8 ee       	ldi	r30, 0xE8	; 232
    23f4:	f2 e0       	ldi	r31, 0x02	; 2
    23f6:	b9 01       	movw	r22, r18
    23f8:	45 e5       	ldi	r20, 0x55	; 85
    23fa:	50 e0       	ldi	r21, 0x00	; 0
    23fc:	20 e0       	ldi	r18, 0x00	; 0
    23fe:	30 e0       	ldi	r19, 0x00	; 0
    2400:	00 e0       	ldi	r16, 0x00	; 0
    2402:	7f 01       	movw	r14, r30
    2404:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <xTaskCreate>
    2408:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    240a:	89 81       	ldd	r24, Y+1	; 0x01
    240c:	81 30       	cpi	r24, 0x01	; 1
    240e:	81 f4       	brne	.+32     	; 0x2430 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    2410:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2412:	8f ef       	ldi	r24, 0xFF	; 255
    2414:	9f ef       	ldi	r25, 0xFF	; 255
    2416:	90 93 e7 02 	sts	0x02E7, r25
    241a:	80 93 e6 02 	sts	0x02E6, r24
		xSchedulerRunning = pdTRUE;
    241e:	81 e0       	ldi	r24, 0x01	; 1
    2420:	80 93 e1 02 	sts	0x02E1, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2424:	10 92 df 02 	sts	0x02DF, r1
    2428:	10 92 de 02 	sts	0x02DE, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    242c:	0e 94 c8 06 	call	0xd90	; 0xd90 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    2430:	0f 90       	pop	r0
    2432:	cf 91       	pop	r28
    2434:	df 91       	pop	r29
    2436:	0f 91       	pop	r16
    2438:	ff 90       	pop	r15
    243a:	ef 90       	pop	r14
    243c:	08 95       	ret

0000243e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    243e:	df 93       	push	r29
    2440:	cf 93       	push	r28
    2442:	cd b7       	in	r28, 0x3d	; 61
    2444:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2446:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2448:	10 92 e1 02 	sts	0x02E1, r1
	vPortEndScheduler();
    244c:	0e 94 fd 06 	call	0xdfa	; 0xdfa <vPortEndScheduler>
}
    2450:	cf 91       	pop	r28
    2452:	df 91       	pop	r29
    2454:	08 95       	ret

00002456 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2456:	df 93       	push	r29
    2458:	cf 93       	push	r28
    245a:	cd b7       	in	r28, 0x3d	; 61
    245c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    245e:	80 91 ea 02 	lds	r24, 0x02EA
    2462:	8f 5f       	subi	r24, 0xFF	; 255
    2464:	80 93 ea 02 	sts	0x02EA, r24
	portMEMORY_BARRIER();
}
    2468:	cf 91       	pop	r28
    246a:	df 91       	pop	r29
    246c:	08 95       	ret

0000246e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    246e:	df 93       	push	r29
    2470:	cf 93       	push	r28
    2472:	00 d0       	rcall	.+0      	; 0x2474 <xTaskResumeAll+0x6>
    2474:	00 d0       	rcall	.+0      	; 0x2476 <xTaskResumeAll+0x8>
    2476:	cd b7       	in	r28, 0x3d	; 61
    2478:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    247a:	1c 82       	std	Y+4, r1	; 0x04
    247c:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    247e:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2480:	0f b6       	in	r0, 0x3f	; 63
    2482:	f8 94       	cli
    2484:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2486:	80 91 ea 02 	lds	r24, 0x02EA
    248a:	81 50       	subi	r24, 0x01	; 1
    248c:	80 93 ea 02 	sts	0x02EA, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2490:	80 91 ea 02 	lds	r24, 0x02EA
    2494:	88 23       	and	r24, r24
    2496:	09 f0       	breq	.+2      	; 0x249a <xTaskResumeAll+0x2c>
    2498:	73 c0       	rjmp	.+230    	; 0x2580 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    249a:	80 91 dd 02 	lds	r24, 0x02DD
    249e:	88 23       	and	r24, r24
    24a0:	09 f4       	brne	.+2      	; 0x24a4 <xTaskResumeAll+0x36>
    24a2:	6e c0       	rjmp	.+220    	; 0x2580 <xTaskResumeAll+0x112>
    24a4:	45 c0       	rjmp	.+138    	; 0x2530 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    24a6:	e0 91 2a 03 	lds	r30, 0x032A
    24aa:	f0 91 2b 03 	lds	r31, 0x032B
    24ae:	86 81       	ldd	r24, Z+6	; 0x06
    24b0:	97 81       	ldd	r25, Z+7	; 0x07
    24b2:	9c 83       	std	Y+4, r25	; 0x04
    24b4:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    24b6:	8b 81       	ldd	r24, Y+3	; 0x03
    24b8:	9c 81       	ldd	r25, Y+4	; 0x04
    24ba:	0c 96       	adiw	r24, 0x0c	; 12
    24bc:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    24c0:	8b 81       	ldd	r24, Y+3	; 0x03
    24c2:	9c 81       	ldd	r25, Y+4	; 0x04
    24c4:	02 96       	adiw	r24, 0x02	; 2
    24c6:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    24ca:	eb 81       	ldd	r30, Y+3	; 0x03
    24cc:	fc 81       	ldd	r31, Y+4	; 0x04
    24ce:	96 89       	ldd	r25, Z+22	; 0x16
    24d0:	80 91 e0 02 	lds	r24, 0x02E0
    24d4:	89 17       	cp	r24, r25
    24d6:	28 f4       	brcc	.+10     	; 0x24e2 <xTaskResumeAll+0x74>
    24d8:	eb 81       	ldd	r30, Y+3	; 0x03
    24da:	fc 81       	ldd	r31, Y+4	; 0x04
    24dc:	86 89       	ldd	r24, Z+22	; 0x16
    24de:	80 93 e0 02 	sts	0x02E0, r24
    24e2:	eb 81       	ldd	r30, Y+3	; 0x03
    24e4:	fc 81       	ldd	r31, Y+4	; 0x04
    24e6:	86 89       	ldd	r24, Z+22	; 0x16
    24e8:	28 2f       	mov	r18, r24
    24ea:	30 e0       	ldi	r19, 0x00	; 0
    24ec:	c9 01       	movw	r24, r18
    24ee:	88 0f       	add	r24, r24
    24f0:	99 1f       	adc	r25, r25
    24f2:	88 0f       	add	r24, r24
    24f4:	99 1f       	adc	r25, r25
    24f6:	88 0f       	add	r24, r24
    24f8:	99 1f       	adc	r25, r25
    24fa:	82 0f       	add	r24, r18
    24fc:	93 1f       	adc	r25, r19
    24fe:	ac 01       	movw	r20, r24
    2500:	45 51       	subi	r20, 0x15	; 21
    2502:	5d 4f       	sbci	r21, 0xFD	; 253
    2504:	8b 81       	ldd	r24, Y+3	; 0x03
    2506:	9c 81       	ldd	r25, Y+4	; 0x04
    2508:	9c 01       	movw	r18, r24
    250a:	2e 5f       	subi	r18, 0xFE	; 254
    250c:	3f 4f       	sbci	r19, 0xFF	; 255
    250e:	ca 01       	movw	r24, r20
    2510:	b9 01       	movw	r22, r18
    2512:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2516:	eb 81       	ldd	r30, Y+3	; 0x03
    2518:	fc 81       	ldd	r31, Y+4	; 0x04
    251a:	96 89       	ldd	r25, Z+22	; 0x16
    251c:	e0 91 da 02 	lds	r30, 0x02DA
    2520:	f0 91 db 02 	lds	r31, 0x02DB
    2524:	86 89       	ldd	r24, Z+22	; 0x16
    2526:	98 17       	cp	r25, r24
    2528:	18 f0       	brcs	.+6      	; 0x2530 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    252a:	81 e0       	ldi	r24, 0x01	; 1
    252c:	80 93 e3 02 	sts	0x02E3, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2530:	80 91 25 03 	lds	r24, 0x0325
    2534:	88 23       	and	r24, r24
    2536:	09 f0       	breq	.+2      	; 0x253a <xTaskResumeAll+0xcc>
    2538:	b6 cf       	rjmp	.-148    	; 0x24a6 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    253a:	8b 81       	ldd	r24, Y+3	; 0x03
    253c:	9c 81       	ldd	r25, Y+4	; 0x04
    253e:	00 97       	sbiw	r24, 0x00	; 0
    2540:	11 f0       	breq	.+4      	; 0x2546 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    2542:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    2546:	80 91 e2 02 	lds	r24, 0x02E2
    254a:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    254c:	89 81       	ldd	r24, Y+1	; 0x01
    254e:	88 23       	and	r24, r24
    2550:	79 f0       	breq	.+30     	; 0x2570 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    2552:	0e 94 27 13 	call	0x264e	; 0x264e <xTaskIncrementTick>
    2556:	88 23       	and	r24, r24
    2558:	19 f0       	breq	.+6      	; 0x2560 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    255a:	81 e0       	ldi	r24, 0x01	; 1
    255c:	80 93 e3 02 	sts	0x02E3, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    2560:	89 81       	ldd	r24, Y+1	; 0x01
    2562:	81 50       	subi	r24, 0x01	; 1
    2564:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    2566:	89 81       	ldd	r24, Y+1	; 0x01
    2568:	88 23       	and	r24, r24
    256a:	99 f7       	brne	.-26     	; 0x2552 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    256c:	10 92 e2 02 	sts	0x02E2, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    2570:	80 91 e3 02 	lds	r24, 0x02E3
    2574:	88 23       	and	r24, r24
    2576:	21 f0       	breq	.+8      	; 0x2580 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    2578:	81 e0       	ldi	r24, 0x01	; 1
    257a:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    257c:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2580:	0f 90       	pop	r0
    2582:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2584:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2586:	0f 90       	pop	r0
    2588:	0f 90       	pop	r0
    258a:	0f 90       	pop	r0
    258c:	0f 90       	pop	r0
    258e:	cf 91       	pop	r28
    2590:	df 91       	pop	r29
    2592:	08 95       	ret

00002594 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    2594:	df 93       	push	r29
    2596:	cf 93       	push	r28
    2598:	00 d0       	rcall	.+0      	; 0x259a <xTaskGetTickCount+0x6>
    259a:	cd b7       	in	r28, 0x3d	; 61
    259c:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    259e:	0f b6       	in	r0, 0x3f	; 63
    25a0:	f8 94       	cli
    25a2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    25a4:	80 91 de 02 	lds	r24, 0x02DE
    25a8:	90 91 df 02 	lds	r25, 0x02DF
    25ac:	9a 83       	std	Y+2, r25	; 0x02
    25ae:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    25b0:	0f 90       	pop	r0
    25b2:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    25b4:	89 81       	ldd	r24, Y+1	; 0x01
    25b6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    25b8:	0f 90       	pop	r0
    25ba:	0f 90       	pop	r0
    25bc:	cf 91       	pop	r28
    25be:	df 91       	pop	r29
    25c0:	08 95       	ret

000025c2 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    25c2:	df 93       	push	r29
    25c4:	cf 93       	push	r28
    25c6:	00 d0       	rcall	.+0      	; 0x25c8 <xTaskGetTickCountFromISR+0x6>
    25c8:	0f 92       	push	r0
    25ca:	cd b7       	in	r28, 0x3d	; 61
    25cc:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    25ce:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    25d0:	80 91 de 02 	lds	r24, 0x02DE
    25d4:	90 91 df 02 	lds	r25, 0x02DF
    25d8:	9b 83       	std	Y+3, r25	; 0x03
    25da:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    25dc:	8a 81       	ldd	r24, Y+2	; 0x02
    25de:	9b 81       	ldd	r25, Y+3	; 0x03
}
    25e0:	0f 90       	pop	r0
    25e2:	0f 90       	pop	r0
    25e4:	0f 90       	pop	r0
    25e6:	cf 91       	pop	r28
    25e8:	df 91       	pop	r29
    25ea:	08 95       	ret

000025ec <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    25ec:	df 93       	push	r29
    25ee:	cf 93       	push	r28
    25f0:	cd b7       	in	r28, 0x3d	; 61
    25f2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    25f4:	80 91 dd 02 	lds	r24, 0x02DD
}
    25f8:	cf 91       	pop	r28
    25fa:	df 91       	pop	r29
    25fc:	08 95       	ret

000025fe <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    25fe:	df 93       	push	r29
    2600:	cf 93       	push	r28
    2602:	00 d0       	rcall	.+0      	; 0x2604 <pcTaskGetName+0x6>
    2604:	00 d0       	rcall	.+0      	; 0x2606 <pcTaskGetName+0x8>
    2606:	00 d0       	rcall	.+0      	; 0x2608 <pcTaskGetName+0xa>
    2608:	cd b7       	in	r28, 0x3d	; 61
    260a:	de b7       	in	r29, 0x3e	; 62
    260c:	9c 83       	std	Y+4, r25	; 0x04
    260e:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2610:	8b 81       	ldd	r24, Y+3	; 0x03
    2612:	9c 81       	ldd	r25, Y+4	; 0x04
    2614:	00 97       	sbiw	r24, 0x00	; 0
    2616:	39 f4       	brne	.+14     	; 0x2626 <pcTaskGetName+0x28>
    2618:	80 91 da 02 	lds	r24, 0x02DA
    261c:	90 91 db 02 	lds	r25, 0x02DB
    2620:	9e 83       	std	Y+6, r25	; 0x06
    2622:	8d 83       	std	Y+5, r24	; 0x05
    2624:	04 c0       	rjmp	.+8      	; 0x262e <pcTaskGetName+0x30>
    2626:	8b 81       	ldd	r24, Y+3	; 0x03
    2628:	9c 81       	ldd	r25, Y+4	; 0x04
    262a:	9e 83       	std	Y+6, r25	; 0x06
    262c:	8d 83       	std	Y+5, r24	; 0x05
    262e:	8d 81       	ldd	r24, Y+5	; 0x05
    2630:	9e 81       	ldd	r25, Y+6	; 0x06
    2632:	9a 83       	std	Y+2, r25	; 0x02
    2634:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    2636:	89 81       	ldd	r24, Y+1	; 0x01
    2638:	9a 81       	ldd	r25, Y+2	; 0x02
    263a:	49 96       	adiw	r24, 0x19	; 25
}
    263c:	26 96       	adiw	r28, 0x06	; 6
    263e:	0f b6       	in	r0, 0x3f	; 63
    2640:	f8 94       	cli
    2642:	de bf       	out	0x3e, r29	; 62
    2644:	0f be       	out	0x3f, r0	; 63
    2646:	cd bf       	out	0x3d, r28	; 61
    2648:	cf 91       	pop	r28
    264a:	df 91       	pop	r29
    264c:	08 95       	ret

0000264e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    264e:	df 93       	push	r29
    2650:	cf 93       	push	r28
    2652:	cd b7       	in	r28, 0x3d	; 61
    2654:	de b7       	in	r29, 0x3e	; 62
    2656:	29 97       	sbiw	r28, 0x09	; 9
    2658:	0f b6       	in	r0, 0x3f	; 63
    265a:	f8 94       	cli
    265c:	de bf       	out	0x3e, r29	; 62
    265e:	0f be       	out	0x3f, r0	; 63
    2660:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2662:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2664:	80 91 ea 02 	lds	r24, 0x02EA
    2668:	88 23       	and	r24, r24
    266a:	09 f0       	breq	.+2      	; 0x266e <xTaskIncrementTick+0x20>
    266c:	c0 c0       	rjmp	.+384    	; 0x27ee <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    266e:	80 91 de 02 	lds	r24, 0x02DE
    2672:	90 91 df 02 	lds	r25, 0x02DF
    2676:	01 96       	adiw	r24, 0x01	; 1
    2678:	9c 83       	std	Y+4, r25	; 0x04
    267a:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    267c:	8b 81       	ldd	r24, Y+3	; 0x03
    267e:	9c 81       	ldd	r25, Y+4	; 0x04
    2680:	90 93 df 02 	sts	0x02DF, r25
    2684:	80 93 de 02 	sts	0x02DE, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    2688:	8b 81       	ldd	r24, Y+3	; 0x03
    268a:	9c 81       	ldd	r25, Y+4	; 0x04
    268c:	00 97       	sbiw	r24, 0x00	; 0
    268e:	d9 f4       	brne	.+54     	; 0x26c6 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    2690:	80 91 21 03 	lds	r24, 0x0321
    2694:	90 91 22 03 	lds	r25, 0x0322
    2698:	9a 83       	std	Y+2, r25	; 0x02
    269a:	89 83       	std	Y+1, r24	; 0x01
    269c:	80 91 23 03 	lds	r24, 0x0323
    26a0:	90 91 24 03 	lds	r25, 0x0324
    26a4:	90 93 22 03 	sts	0x0322, r25
    26a8:	80 93 21 03 	sts	0x0321, r24
    26ac:	89 81       	ldd	r24, Y+1	; 0x01
    26ae:	9a 81       	ldd	r25, Y+2	; 0x02
    26b0:	90 93 24 03 	sts	0x0324, r25
    26b4:	80 93 23 03 	sts	0x0323, r24
    26b8:	80 91 e4 02 	lds	r24, 0x02E4
    26bc:	8f 5f       	subi	r24, 0xFF	; 255
    26be:	80 93 e4 02 	sts	0x02E4, r24
    26c2:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    26c6:	20 91 e6 02 	lds	r18, 0x02E6
    26ca:	30 91 e7 02 	lds	r19, 0x02E7
    26ce:	8b 81       	ldd	r24, Y+3	; 0x03
    26d0:	9c 81       	ldd	r25, Y+4	; 0x04
    26d2:	82 17       	cp	r24, r18
    26d4:	93 07       	cpc	r25, r19
    26d6:	08 f4       	brcc	.+2      	; 0x26da <xTaskIncrementTick+0x8c>
    26d8:	71 c0       	rjmp	.+226    	; 0x27bc <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    26da:	e0 91 21 03 	lds	r30, 0x0321
    26de:	f0 91 22 03 	lds	r31, 0x0322
    26e2:	80 81       	ld	r24, Z
    26e4:	88 23       	and	r24, r24
    26e6:	39 f4       	brne	.+14     	; 0x26f6 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    26e8:	8f ef       	ldi	r24, 0xFF	; 255
    26ea:	9f ef       	ldi	r25, 0xFF	; 255
    26ec:	90 93 e7 02 	sts	0x02E7, r25
    26f0:	80 93 e6 02 	sts	0x02E6, r24
    26f4:	63 c0       	rjmp	.+198    	; 0x27bc <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    26f6:	e0 91 21 03 	lds	r30, 0x0321
    26fa:	f0 91 22 03 	lds	r31, 0x0322
    26fe:	05 80       	ldd	r0, Z+5	; 0x05
    2700:	f6 81       	ldd	r31, Z+6	; 0x06
    2702:	e0 2d       	mov	r30, r0
    2704:	86 81       	ldd	r24, Z+6	; 0x06
    2706:	97 81       	ldd	r25, Z+7	; 0x07
    2708:	99 87       	std	Y+9, r25	; 0x09
    270a:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    270c:	e8 85       	ldd	r30, Y+8	; 0x08
    270e:	f9 85       	ldd	r31, Y+9	; 0x09
    2710:	82 81       	ldd	r24, Z+2	; 0x02
    2712:	93 81       	ldd	r25, Z+3	; 0x03
    2714:	9f 83       	std	Y+7, r25	; 0x07
    2716:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    2718:	2b 81       	ldd	r18, Y+3	; 0x03
    271a:	3c 81       	ldd	r19, Y+4	; 0x04
    271c:	8e 81       	ldd	r24, Y+6	; 0x06
    271e:	9f 81       	ldd	r25, Y+7	; 0x07
    2720:	28 17       	cp	r18, r24
    2722:	39 07       	cpc	r19, r25
    2724:	38 f4       	brcc	.+14     	; 0x2734 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    2726:	8e 81       	ldd	r24, Y+6	; 0x06
    2728:	9f 81       	ldd	r25, Y+7	; 0x07
    272a:	90 93 e7 02 	sts	0x02E7, r25
    272e:	80 93 e6 02 	sts	0x02E6, r24
    2732:	44 c0       	rjmp	.+136    	; 0x27bc <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2734:	88 85       	ldd	r24, Y+8	; 0x08
    2736:	99 85       	ldd	r25, Y+9	; 0x09
    2738:	02 96       	adiw	r24, 0x02	; 2
    273a:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    273e:	e8 85       	ldd	r30, Y+8	; 0x08
    2740:	f9 85       	ldd	r31, Y+9	; 0x09
    2742:	84 89       	ldd	r24, Z+20	; 0x14
    2744:	95 89       	ldd	r25, Z+21	; 0x15
    2746:	00 97       	sbiw	r24, 0x00	; 0
    2748:	29 f0       	breq	.+10     	; 0x2754 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    274a:	88 85       	ldd	r24, Y+8	; 0x08
    274c:	99 85       	ldd	r25, Y+9	; 0x09
    274e:	0c 96       	adiw	r24, 0x0c	; 12
    2750:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    2754:	e8 85       	ldd	r30, Y+8	; 0x08
    2756:	f9 85       	ldd	r31, Y+9	; 0x09
    2758:	96 89       	ldd	r25, Z+22	; 0x16
    275a:	80 91 e0 02 	lds	r24, 0x02E0
    275e:	89 17       	cp	r24, r25
    2760:	28 f4       	brcc	.+10     	; 0x276c <xTaskIncrementTick+0x11e>
    2762:	e8 85       	ldd	r30, Y+8	; 0x08
    2764:	f9 85       	ldd	r31, Y+9	; 0x09
    2766:	86 89       	ldd	r24, Z+22	; 0x16
    2768:	80 93 e0 02 	sts	0x02E0, r24
    276c:	e8 85       	ldd	r30, Y+8	; 0x08
    276e:	f9 85       	ldd	r31, Y+9	; 0x09
    2770:	86 89       	ldd	r24, Z+22	; 0x16
    2772:	28 2f       	mov	r18, r24
    2774:	30 e0       	ldi	r19, 0x00	; 0
    2776:	c9 01       	movw	r24, r18
    2778:	88 0f       	add	r24, r24
    277a:	99 1f       	adc	r25, r25
    277c:	88 0f       	add	r24, r24
    277e:	99 1f       	adc	r25, r25
    2780:	88 0f       	add	r24, r24
    2782:	99 1f       	adc	r25, r25
    2784:	82 0f       	add	r24, r18
    2786:	93 1f       	adc	r25, r19
    2788:	ac 01       	movw	r20, r24
    278a:	45 51       	subi	r20, 0x15	; 21
    278c:	5d 4f       	sbci	r21, 0xFD	; 253
    278e:	88 85       	ldd	r24, Y+8	; 0x08
    2790:	99 85       	ldd	r25, Y+9	; 0x09
    2792:	9c 01       	movw	r18, r24
    2794:	2e 5f       	subi	r18, 0xFE	; 254
    2796:	3f 4f       	sbci	r19, 0xFF	; 255
    2798:	ca 01       	movw	r24, r20
    279a:	b9 01       	movw	r22, r18
    279c:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    27a0:	e8 85       	ldd	r30, Y+8	; 0x08
    27a2:	f9 85       	ldd	r31, Y+9	; 0x09
    27a4:	96 89       	ldd	r25, Z+22	; 0x16
    27a6:	e0 91 da 02 	lds	r30, 0x02DA
    27aa:	f0 91 db 02 	lds	r31, 0x02DB
    27ae:	86 89       	ldd	r24, Z+22	; 0x16
    27b0:	98 17       	cp	r25, r24
    27b2:	08 f4       	brcc	.+2      	; 0x27b6 <xTaskIncrementTick+0x168>
    27b4:	92 cf       	rjmp	.-220    	; 0x26da <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    27b6:	81 e0       	ldi	r24, 0x01	; 1
    27b8:	8d 83       	std	Y+5, r24	; 0x05
    27ba:	8f cf       	rjmp	.-226    	; 0x26da <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    27bc:	e0 91 da 02 	lds	r30, 0x02DA
    27c0:	f0 91 db 02 	lds	r31, 0x02DB
    27c4:	86 89       	ldd	r24, Z+22	; 0x16
    27c6:	28 2f       	mov	r18, r24
    27c8:	30 e0       	ldi	r19, 0x00	; 0
    27ca:	c9 01       	movw	r24, r18
    27cc:	88 0f       	add	r24, r24
    27ce:	99 1f       	adc	r25, r25
    27d0:	88 0f       	add	r24, r24
    27d2:	99 1f       	adc	r25, r25
    27d4:	88 0f       	add	r24, r24
    27d6:	99 1f       	adc	r25, r25
    27d8:	82 0f       	add	r24, r18
    27da:	93 1f       	adc	r25, r19
    27dc:	fc 01       	movw	r30, r24
    27de:	e5 51       	subi	r30, 0x15	; 21
    27e0:	fd 4f       	sbci	r31, 0xFD	; 253
    27e2:	80 81       	ld	r24, Z
    27e4:	82 30       	cpi	r24, 0x02	; 2
    27e6:	40 f0       	brcs	.+16     	; 0x27f8 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    27e8:	81 e0       	ldi	r24, 0x01	; 1
    27ea:	8d 83       	std	Y+5, r24	; 0x05
    27ec:	05 c0       	rjmp	.+10     	; 0x27f8 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    27ee:	80 91 e2 02 	lds	r24, 0x02E2
    27f2:	8f 5f       	subi	r24, 0xFF	; 255
    27f4:	80 93 e2 02 	sts	0x02E2, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    27f8:	80 91 e3 02 	lds	r24, 0x02E3
    27fc:	88 23       	and	r24, r24
    27fe:	11 f0       	breq	.+4      	; 0x2804 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    2800:	81 e0       	ldi	r24, 0x01	; 1
    2802:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2804:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2806:	29 96       	adiw	r28, 0x09	; 9
    2808:	0f b6       	in	r0, 0x3f	; 63
    280a:	f8 94       	cli
    280c:	de bf       	out	0x3e, r29	; 62
    280e:	0f be       	out	0x3f, r0	; 63
    2810:	cd bf       	out	0x3d, r28	; 61
    2812:	cf 91       	pop	r28
    2814:	df 91       	pop	r29
    2816:	08 95       	ret

00002818 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2818:	df 93       	push	r29
    281a:	cf 93       	push	r28
    281c:	00 d0       	rcall	.+0      	; 0x281e <vTaskSwitchContext+0x6>
    281e:	0f 92       	push	r0
    2820:	cd b7       	in	r28, 0x3d	; 61
    2822:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2824:	80 91 ea 02 	lds	r24, 0x02EA
    2828:	88 23       	and	r24, r24
    282a:	21 f0       	breq	.+8      	; 0x2834 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    282c:	81 e0       	ldi	r24, 0x01	; 1
    282e:	80 93 e3 02 	sts	0x02E3, r24
    2832:	59 c0       	rjmp	.+178    	; 0x28e6 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    2834:	10 92 e3 02 	sts	0x02E3, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2838:	80 91 e0 02 	lds	r24, 0x02E0
    283c:	8b 83       	std	Y+3, r24	; 0x03
    283e:	03 c0       	rjmp	.+6      	; 0x2846 <vTaskSwitchContext+0x2e>
    2840:	8b 81       	ldd	r24, Y+3	; 0x03
    2842:	81 50       	subi	r24, 0x01	; 1
    2844:	8b 83       	std	Y+3, r24	; 0x03
    2846:	8b 81       	ldd	r24, Y+3	; 0x03
    2848:	28 2f       	mov	r18, r24
    284a:	30 e0       	ldi	r19, 0x00	; 0
    284c:	c9 01       	movw	r24, r18
    284e:	88 0f       	add	r24, r24
    2850:	99 1f       	adc	r25, r25
    2852:	88 0f       	add	r24, r24
    2854:	99 1f       	adc	r25, r25
    2856:	88 0f       	add	r24, r24
    2858:	99 1f       	adc	r25, r25
    285a:	82 0f       	add	r24, r18
    285c:	93 1f       	adc	r25, r19
    285e:	fc 01       	movw	r30, r24
    2860:	e5 51       	subi	r30, 0x15	; 21
    2862:	fd 4f       	sbci	r31, 0xFD	; 253
    2864:	80 81       	ld	r24, Z
    2866:	88 23       	and	r24, r24
    2868:	59 f3       	breq	.-42     	; 0x2840 <vTaskSwitchContext+0x28>
    286a:	8b 81       	ldd	r24, Y+3	; 0x03
    286c:	28 2f       	mov	r18, r24
    286e:	30 e0       	ldi	r19, 0x00	; 0
    2870:	c9 01       	movw	r24, r18
    2872:	88 0f       	add	r24, r24
    2874:	99 1f       	adc	r25, r25
    2876:	88 0f       	add	r24, r24
    2878:	99 1f       	adc	r25, r25
    287a:	88 0f       	add	r24, r24
    287c:	99 1f       	adc	r25, r25
    287e:	82 0f       	add	r24, r18
    2880:	93 1f       	adc	r25, r19
    2882:	85 51       	subi	r24, 0x15	; 21
    2884:	9d 4f       	sbci	r25, 0xFD	; 253
    2886:	9a 83       	std	Y+2, r25	; 0x02
    2888:	89 83       	std	Y+1, r24	; 0x01
    288a:	e9 81       	ldd	r30, Y+1	; 0x01
    288c:	fa 81       	ldd	r31, Y+2	; 0x02
    288e:	01 80       	ldd	r0, Z+1	; 0x01
    2890:	f2 81       	ldd	r31, Z+2	; 0x02
    2892:	e0 2d       	mov	r30, r0
    2894:	82 81       	ldd	r24, Z+2	; 0x02
    2896:	93 81       	ldd	r25, Z+3	; 0x03
    2898:	e9 81       	ldd	r30, Y+1	; 0x01
    289a:	fa 81       	ldd	r31, Y+2	; 0x02
    289c:	92 83       	std	Z+2, r25	; 0x02
    289e:	81 83       	std	Z+1, r24	; 0x01
    28a0:	e9 81       	ldd	r30, Y+1	; 0x01
    28a2:	fa 81       	ldd	r31, Y+2	; 0x02
    28a4:	21 81       	ldd	r18, Z+1	; 0x01
    28a6:	32 81       	ldd	r19, Z+2	; 0x02
    28a8:	89 81       	ldd	r24, Y+1	; 0x01
    28aa:	9a 81       	ldd	r25, Y+2	; 0x02
    28ac:	03 96       	adiw	r24, 0x03	; 3
    28ae:	28 17       	cp	r18, r24
    28b0:	39 07       	cpc	r19, r25
    28b2:	59 f4       	brne	.+22     	; 0x28ca <vTaskSwitchContext+0xb2>
    28b4:	e9 81       	ldd	r30, Y+1	; 0x01
    28b6:	fa 81       	ldd	r31, Y+2	; 0x02
    28b8:	01 80       	ldd	r0, Z+1	; 0x01
    28ba:	f2 81       	ldd	r31, Z+2	; 0x02
    28bc:	e0 2d       	mov	r30, r0
    28be:	82 81       	ldd	r24, Z+2	; 0x02
    28c0:	93 81       	ldd	r25, Z+3	; 0x03
    28c2:	e9 81       	ldd	r30, Y+1	; 0x01
    28c4:	fa 81       	ldd	r31, Y+2	; 0x02
    28c6:	92 83       	std	Z+2, r25	; 0x02
    28c8:	81 83       	std	Z+1, r24	; 0x01
    28ca:	e9 81       	ldd	r30, Y+1	; 0x01
    28cc:	fa 81       	ldd	r31, Y+2	; 0x02
    28ce:	01 80       	ldd	r0, Z+1	; 0x01
    28d0:	f2 81       	ldd	r31, Z+2	; 0x02
    28d2:	e0 2d       	mov	r30, r0
    28d4:	86 81       	ldd	r24, Z+6	; 0x06
    28d6:	97 81       	ldd	r25, Z+7	; 0x07
    28d8:	90 93 db 02 	sts	0x02DB, r25
    28dc:	80 93 da 02 	sts	0x02DA, r24
    28e0:	8b 81       	ldd	r24, Y+3	; 0x03
    28e2:	80 93 e0 02 	sts	0x02E0, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    28e6:	0f 90       	pop	r0
    28e8:	0f 90       	pop	r0
    28ea:	0f 90       	pop	r0
    28ec:	cf 91       	pop	r28
    28ee:	df 91       	pop	r29
    28f0:	08 95       	ret

000028f2 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    28f2:	df 93       	push	r29
    28f4:	cf 93       	push	r28
    28f6:	00 d0       	rcall	.+0      	; 0x28f8 <vTaskPlaceOnEventList+0x6>
    28f8:	00 d0       	rcall	.+0      	; 0x28fa <vTaskPlaceOnEventList+0x8>
    28fa:	cd b7       	in	r28, 0x3d	; 61
    28fc:	de b7       	in	r29, 0x3e	; 62
    28fe:	9a 83       	std	Y+2, r25	; 0x02
    2900:	89 83       	std	Y+1, r24	; 0x01
    2902:	7c 83       	std	Y+4, r23	; 0x04
    2904:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2906:	80 91 da 02 	lds	r24, 0x02DA
    290a:	90 91 db 02 	lds	r25, 0x02DB
    290e:	9c 01       	movw	r18, r24
    2910:	24 5f       	subi	r18, 0xF4	; 244
    2912:	3f 4f       	sbci	r19, 0xFF	; 255
    2914:	89 81       	ldd	r24, Y+1	; 0x01
    2916:	9a 81       	ldd	r25, Y+2	; 0x02
    2918:	b9 01       	movw	r22, r18
    291a:	0e 94 8d 04 	call	0x91a	; 0x91a <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    291e:	8b 81       	ldd	r24, Y+3	; 0x03
    2920:	9c 81       	ldd	r25, Y+4	; 0x04
    2922:	61 e0       	ldi	r22, 0x01	; 1
    2924:	0e 94 bd 1a 	call	0x357a	; 0x357a <prvAddCurrentTaskToDelayedList>
}
    2928:	0f 90       	pop	r0
    292a:	0f 90       	pop	r0
    292c:	0f 90       	pop	r0
    292e:	0f 90       	pop	r0
    2930:	cf 91       	pop	r28
    2932:	df 91       	pop	r29
    2934:	08 95       	ret

00002936 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    2936:	df 93       	push	r29
    2938:	cf 93       	push	r28
    293a:	00 d0       	rcall	.+0      	; 0x293c <vTaskPlaceOnUnorderedEventList+0x6>
    293c:	00 d0       	rcall	.+0      	; 0x293e <vTaskPlaceOnUnorderedEventList+0x8>
    293e:	00 d0       	rcall	.+0      	; 0x2940 <vTaskPlaceOnUnorderedEventList+0xa>
    2940:	cd b7       	in	r28, 0x3d	; 61
    2942:	de b7       	in	r29, 0x3e	; 62
    2944:	9a 83       	std	Y+2, r25	; 0x02
    2946:	89 83       	std	Y+1, r24	; 0x01
    2948:	7c 83       	std	Y+4, r23	; 0x04
    294a:	6b 83       	std	Y+3, r22	; 0x03
    294c:	5e 83       	std	Y+6, r21	; 0x06
    294e:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2950:	e0 91 da 02 	lds	r30, 0x02DA
    2954:	f0 91 db 02 	lds	r31, 0x02DB
    2958:	8b 81       	ldd	r24, Y+3	; 0x03
    295a:	9c 81       	ldd	r25, Y+4	; 0x04
    295c:	90 68       	ori	r25, 0x80	; 128
    295e:	95 87       	std	Z+13, r25	; 0x0d
    2960:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2962:	80 91 da 02 	lds	r24, 0x02DA
    2966:	90 91 db 02 	lds	r25, 0x02DB
    296a:	9c 01       	movw	r18, r24
    296c:	24 5f       	subi	r18, 0xF4	; 244
    296e:	3f 4f       	sbci	r19, 0xFF	; 255
    2970:	89 81       	ldd	r24, Y+1	; 0x01
    2972:	9a 81       	ldd	r25, Y+2	; 0x02
    2974:	b9 01       	movw	r22, r18
    2976:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    297a:	8d 81       	ldd	r24, Y+5	; 0x05
    297c:	9e 81       	ldd	r25, Y+6	; 0x06
    297e:	61 e0       	ldi	r22, 0x01	; 1
    2980:	0e 94 bd 1a 	call	0x357a	; 0x357a <prvAddCurrentTaskToDelayedList>
}
    2984:	26 96       	adiw	r28, 0x06	; 6
    2986:	0f b6       	in	r0, 0x3f	; 63
    2988:	f8 94       	cli
    298a:	de bf       	out	0x3e, r29	; 62
    298c:	0f be       	out	0x3f, r0	; 63
    298e:	cd bf       	out	0x3d, r28	; 61
    2990:	cf 91       	pop	r28
    2992:	df 91       	pop	r29
    2994:	08 95       	ret

00002996 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2996:	df 93       	push	r29
    2998:	cf 93       	push	r28
    299a:	00 d0       	rcall	.+0      	; 0x299c <xTaskRemoveFromEventList+0x6>
    299c:	00 d0       	rcall	.+0      	; 0x299e <xTaskRemoveFromEventList+0x8>
    299e:	0f 92       	push	r0
    29a0:	cd b7       	in	r28, 0x3d	; 61
    29a2:	de b7       	in	r29, 0x3e	; 62
    29a4:	9d 83       	std	Y+5, r25	; 0x05
    29a6:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    29a8:	ec 81       	ldd	r30, Y+4	; 0x04
    29aa:	fd 81       	ldd	r31, Y+5	; 0x05
    29ac:	05 80       	ldd	r0, Z+5	; 0x05
    29ae:	f6 81       	ldd	r31, Z+6	; 0x06
    29b0:	e0 2d       	mov	r30, r0
    29b2:	86 81       	ldd	r24, Z+6	; 0x06
    29b4:	97 81       	ldd	r25, Z+7	; 0x07
    29b6:	9b 83       	std	Y+3, r25	; 0x03
    29b8:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    29ba:	8a 81       	ldd	r24, Y+2	; 0x02
    29bc:	9b 81       	ldd	r25, Y+3	; 0x03
    29be:	0c 96       	adiw	r24, 0x0c	; 12
    29c0:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    29c4:	80 91 ea 02 	lds	r24, 0x02EA
    29c8:	88 23       	and	r24, r24
    29ca:	61 f5       	brne	.+88     	; 0x2a24 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    29cc:	8a 81       	ldd	r24, Y+2	; 0x02
    29ce:	9b 81       	ldd	r25, Y+3	; 0x03
    29d0:	02 96       	adiw	r24, 0x02	; 2
    29d2:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    29d6:	ea 81       	ldd	r30, Y+2	; 0x02
    29d8:	fb 81       	ldd	r31, Y+3	; 0x03
    29da:	96 89       	ldd	r25, Z+22	; 0x16
    29dc:	80 91 e0 02 	lds	r24, 0x02E0
    29e0:	89 17       	cp	r24, r25
    29e2:	28 f4       	brcc	.+10     	; 0x29ee <xTaskRemoveFromEventList+0x58>
    29e4:	ea 81       	ldd	r30, Y+2	; 0x02
    29e6:	fb 81       	ldd	r31, Y+3	; 0x03
    29e8:	86 89       	ldd	r24, Z+22	; 0x16
    29ea:	80 93 e0 02 	sts	0x02E0, r24
    29ee:	ea 81       	ldd	r30, Y+2	; 0x02
    29f0:	fb 81       	ldd	r31, Y+3	; 0x03
    29f2:	86 89       	ldd	r24, Z+22	; 0x16
    29f4:	28 2f       	mov	r18, r24
    29f6:	30 e0       	ldi	r19, 0x00	; 0
    29f8:	c9 01       	movw	r24, r18
    29fa:	88 0f       	add	r24, r24
    29fc:	99 1f       	adc	r25, r25
    29fe:	88 0f       	add	r24, r24
    2a00:	99 1f       	adc	r25, r25
    2a02:	88 0f       	add	r24, r24
    2a04:	99 1f       	adc	r25, r25
    2a06:	82 0f       	add	r24, r18
    2a08:	93 1f       	adc	r25, r19
    2a0a:	ac 01       	movw	r20, r24
    2a0c:	45 51       	subi	r20, 0x15	; 21
    2a0e:	5d 4f       	sbci	r21, 0xFD	; 253
    2a10:	8a 81       	ldd	r24, Y+2	; 0x02
    2a12:	9b 81       	ldd	r25, Y+3	; 0x03
    2a14:	9c 01       	movw	r18, r24
    2a16:	2e 5f       	subi	r18, 0xFE	; 254
    2a18:	3f 4f       	sbci	r19, 0xFF	; 255
    2a1a:	ca 01       	movw	r24, r20
    2a1c:	b9 01       	movw	r22, r18
    2a1e:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>
    2a22:	0a c0       	rjmp	.+20     	; 0x2a38 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2a24:	8a 81       	ldd	r24, Y+2	; 0x02
    2a26:	9b 81       	ldd	r25, Y+3	; 0x03
    2a28:	9c 01       	movw	r18, r24
    2a2a:	24 5f       	subi	r18, 0xF4	; 244
    2a2c:	3f 4f       	sbci	r19, 0xFF	; 255
    2a2e:	85 e2       	ldi	r24, 0x25	; 37
    2a30:	93 e0       	ldi	r25, 0x03	; 3
    2a32:	b9 01       	movw	r22, r18
    2a34:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2a38:	ea 81       	ldd	r30, Y+2	; 0x02
    2a3a:	fb 81       	ldd	r31, Y+3	; 0x03
    2a3c:	96 89       	ldd	r25, Z+22	; 0x16
    2a3e:	e0 91 da 02 	lds	r30, 0x02DA
    2a42:	f0 91 db 02 	lds	r31, 0x02DB
    2a46:	86 89       	ldd	r24, Z+22	; 0x16
    2a48:	89 17       	cp	r24, r25
    2a4a:	30 f4       	brcc	.+12     	; 0x2a58 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    2a4c:	81 e0       	ldi	r24, 0x01	; 1
    2a4e:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2a50:	81 e0       	ldi	r24, 0x01	; 1
    2a52:	80 93 e3 02 	sts	0x02E3, r24
    2a56:	01 c0       	rjmp	.+2      	; 0x2a5a <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    2a58:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2a5a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a5c:	0f 90       	pop	r0
    2a5e:	0f 90       	pop	r0
    2a60:	0f 90       	pop	r0
    2a62:	0f 90       	pop	r0
    2a64:	0f 90       	pop	r0
    2a66:	cf 91       	pop	r28
    2a68:	df 91       	pop	r29
    2a6a:	08 95       	ret

00002a6c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    2a6c:	df 93       	push	r29
    2a6e:	cf 93       	push	r28
    2a70:	00 d0       	rcall	.+0      	; 0x2a72 <vTaskRemoveFromUnorderedEventList+0x6>
    2a72:	00 d0       	rcall	.+0      	; 0x2a74 <vTaskRemoveFromUnorderedEventList+0x8>
    2a74:	00 d0       	rcall	.+0      	; 0x2a76 <vTaskRemoveFromUnorderedEventList+0xa>
    2a76:	cd b7       	in	r28, 0x3d	; 61
    2a78:	de b7       	in	r29, 0x3e	; 62
    2a7a:	9c 83       	std	Y+4, r25	; 0x04
    2a7c:	8b 83       	std	Y+3, r24	; 0x03
    2a7e:	7e 83       	std	Y+6, r23	; 0x06
    2a80:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2a82:	8d 81       	ldd	r24, Y+5	; 0x05
    2a84:	9e 81       	ldd	r25, Y+6	; 0x06
    2a86:	90 68       	ori	r25, 0x80	; 128
    2a88:	eb 81       	ldd	r30, Y+3	; 0x03
    2a8a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a8c:	91 83       	std	Z+1, r25	; 0x01
    2a8e:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2a90:	eb 81       	ldd	r30, Y+3	; 0x03
    2a92:	fc 81       	ldd	r31, Y+4	; 0x04
    2a94:	86 81       	ldd	r24, Z+6	; 0x06
    2a96:	97 81       	ldd	r25, Z+7	; 0x07
    2a98:	9a 83       	std	Y+2, r25	; 0x02
    2a9a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa0:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2aa4:	89 81       	ldd	r24, Y+1	; 0x01
    2aa6:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa8:	02 96       	adiw	r24, 0x02	; 2
    2aaa:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2aae:	e9 81       	ldd	r30, Y+1	; 0x01
    2ab0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ab2:	96 89       	ldd	r25, Z+22	; 0x16
    2ab4:	80 91 e0 02 	lds	r24, 0x02E0
    2ab8:	89 17       	cp	r24, r25
    2aba:	28 f4       	brcc	.+10     	; 0x2ac6 <vTaskRemoveFromUnorderedEventList+0x5a>
    2abc:	e9 81       	ldd	r30, Y+1	; 0x01
    2abe:	fa 81       	ldd	r31, Y+2	; 0x02
    2ac0:	86 89       	ldd	r24, Z+22	; 0x16
    2ac2:	80 93 e0 02 	sts	0x02E0, r24
    2ac6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ac8:	fa 81       	ldd	r31, Y+2	; 0x02
    2aca:	86 89       	ldd	r24, Z+22	; 0x16
    2acc:	28 2f       	mov	r18, r24
    2ace:	30 e0       	ldi	r19, 0x00	; 0
    2ad0:	c9 01       	movw	r24, r18
    2ad2:	88 0f       	add	r24, r24
    2ad4:	99 1f       	adc	r25, r25
    2ad6:	88 0f       	add	r24, r24
    2ad8:	99 1f       	adc	r25, r25
    2ada:	88 0f       	add	r24, r24
    2adc:	99 1f       	adc	r25, r25
    2ade:	82 0f       	add	r24, r18
    2ae0:	93 1f       	adc	r25, r19
    2ae2:	ac 01       	movw	r20, r24
    2ae4:	45 51       	subi	r20, 0x15	; 21
    2ae6:	5d 4f       	sbci	r21, 0xFD	; 253
    2ae8:	89 81       	ldd	r24, Y+1	; 0x01
    2aea:	9a 81       	ldd	r25, Y+2	; 0x02
    2aec:	9c 01       	movw	r18, r24
    2aee:	2e 5f       	subi	r18, 0xFE	; 254
    2af0:	3f 4f       	sbci	r19, 0xFF	; 255
    2af2:	ca 01       	movw	r24, r20
    2af4:	b9 01       	movw	r22, r18
    2af6:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2afa:	e9 81       	ldd	r30, Y+1	; 0x01
    2afc:	fa 81       	ldd	r31, Y+2	; 0x02
    2afe:	96 89       	ldd	r25, Z+22	; 0x16
    2b00:	e0 91 da 02 	lds	r30, 0x02DA
    2b04:	f0 91 db 02 	lds	r31, 0x02DB
    2b08:	86 89       	ldd	r24, Z+22	; 0x16
    2b0a:	89 17       	cp	r24, r25
    2b0c:	18 f4       	brcc	.+6      	; 0x2b14 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    2b0e:	81 e0       	ldi	r24, 0x01	; 1
    2b10:	80 93 e3 02 	sts	0x02E3, r24
	}
}
    2b14:	26 96       	adiw	r28, 0x06	; 6
    2b16:	0f b6       	in	r0, 0x3f	; 63
    2b18:	f8 94       	cli
    2b1a:	de bf       	out	0x3e, r29	; 62
    2b1c:	0f be       	out	0x3f, r0	; 63
    2b1e:	cd bf       	out	0x3d, r28	; 61
    2b20:	cf 91       	pop	r28
    2b22:	df 91       	pop	r29
    2b24:	08 95       	ret

00002b26 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2b26:	df 93       	push	r29
    2b28:	cf 93       	push	r28
    2b2a:	00 d0       	rcall	.+0      	; 0x2b2c <vTaskSetTimeOutState+0x6>
    2b2c:	cd b7       	in	r28, 0x3d	; 61
    2b2e:	de b7       	in	r29, 0x3e	; 62
    2b30:	9a 83       	std	Y+2, r25	; 0x02
    2b32:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    2b3a:	80 91 e4 02 	lds	r24, 0x02E4
    2b3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b40:	fa 81       	ldd	r31, Y+2	; 0x02
    2b42:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    2b44:	80 91 de 02 	lds	r24, 0x02DE
    2b48:	90 91 df 02 	lds	r25, 0x02DF
    2b4c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b4e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b50:	92 83       	std	Z+2, r25	; 0x02
    2b52:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2b54:	0f 90       	pop	r0
    2b56:	0f be       	out	0x3f, r0	; 63
}
    2b58:	0f 90       	pop	r0
    2b5a:	0f 90       	pop	r0
    2b5c:	cf 91       	pop	r28
    2b5e:	df 91       	pop	r29
    2b60:	08 95       	ret

00002b62 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2b62:	df 93       	push	r29
    2b64:	cf 93       	push	r28
    2b66:	00 d0       	rcall	.+0      	; 0x2b68 <vTaskInternalSetTimeOutState+0x6>
    2b68:	cd b7       	in	r28, 0x3d	; 61
    2b6a:	de b7       	in	r29, 0x3e	; 62
    2b6c:	9a 83       	std	Y+2, r25	; 0x02
    2b6e:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2b70:	80 91 e4 02 	lds	r24, 0x02E4
    2b74:	e9 81       	ldd	r30, Y+1	; 0x01
    2b76:	fa 81       	ldd	r31, Y+2	; 0x02
    2b78:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2b7a:	80 91 de 02 	lds	r24, 0x02DE
    2b7e:	90 91 df 02 	lds	r25, 0x02DF
    2b82:	e9 81       	ldd	r30, Y+1	; 0x01
    2b84:	fa 81       	ldd	r31, Y+2	; 0x02
    2b86:	92 83       	std	Z+2, r25	; 0x02
    2b88:	81 83       	std	Z+1, r24	; 0x01
}
    2b8a:	0f 90       	pop	r0
    2b8c:	0f 90       	pop	r0
    2b8e:	cf 91       	pop	r28
    2b90:	df 91       	pop	r29
    2b92:	08 95       	ret

00002b94 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2b94:	df 93       	push	r29
    2b96:	cf 93       	push	r28
    2b98:	cd b7       	in	r28, 0x3d	; 61
    2b9a:	de b7       	in	r29, 0x3e	; 62
    2b9c:	29 97       	sbiw	r28, 0x09	; 9
    2b9e:	0f b6       	in	r0, 0x3f	; 63
    2ba0:	f8 94       	cli
    2ba2:	de bf       	out	0x3e, r29	; 62
    2ba4:	0f be       	out	0x3f, r0	; 63
    2ba6:	cd bf       	out	0x3d, r28	; 61
    2ba8:	9f 83       	std	Y+7, r25	; 0x07
    2baa:	8e 83       	std	Y+6, r24	; 0x06
    2bac:	79 87       	std	Y+9, r23	; 0x09
    2bae:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2bb0:	0f b6       	in	r0, 0x3f	; 63
    2bb2:	f8 94       	cli
    2bb4:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2bb6:	80 91 de 02 	lds	r24, 0x02DE
    2bba:	90 91 df 02 	lds	r25, 0x02DF
    2bbe:	9c 83       	std	Y+4, r25	; 0x04
    2bc0:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2bc2:	ee 81       	ldd	r30, Y+6	; 0x06
    2bc4:	ff 81       	ldd	r31, Y+7	; 0x07
    2bc6:	21 81       	ldd	r18, Z+1	; 0x01
    2bc8:	32 81       	ldd	r19, Z+2	; 0x02
    2bca:	8b 81       	ldd	r24, Y+3	; 0x03
    2bcc:	9c 81       	ldd	r25, Y+4	; 0x04
    2bce:	82 1b       	sub	r24, r18
    2bd0:	93 0b       	sbc	r25, r19
    2bd2:	9a 83       	std	Y+2, r25	; 0x02
    2bd4:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2bd6:	ee 81       	ldd	r30, Y+6	; 0x06
    2bd8:	ff 81       	ldd	r31, Y+7	; 0x07
    2bda:	90 81       	ld	r25, Z
    2bdc:	80 91 e4 02 	lds	r24, 0x02E4
    2be0:	98 17       	cp	r25, r24
    2be2:	61 f0       	breq	.+24     	; 0x2bfc <xTaskCheckForTimeOut+0x68>
    2be4:	ee 81       	ldd	r30, Y+6	; 0x06
    2be6:	ff 81       	ldd	r31, Y+7	; 0x07
    2be8:	21 81       	ldd	r18, Z+1	; 0x01
    2bea:	32 81       	ldd	r19, Z+2	; 0x02
    2bec:	8b 81       	ldd	r24, Y+3	; 0x03
    2bee:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf0:	82 17       	cp	r24, r18
    2bf2:	93 07       	cpc	r25, r19
    2bf4:	18 f0       	brcs	.+6      	; 0x2bfc <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2bf6:	81 e0       	ldi	r24, 0x01	; 1
    2bf8:	8d 83       	std	Y+5, r24	; 0x05
    2bfa:	23 c0       	rjmp	.+70     	; 0x2c42 <xTaskCheckForTimeOut+0xae>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    2bfc:	e8 85       	ldd	r30, Y+8	; 0x08
    2bfe:	f9 85       	ldd	r31, Y+9	; 0x09
    2c00:	20 81       	ld	r18, Z
    2c02:	31 81       	ldd	r19, Z+1	; 0x01
    2c04:	89 81       	ldd	r24, Y+1	; 0x01
    2c06:	9a 81       	ldd	r25, Y+2	; 0x02
    2c08:	82 17       	cp	r24, r18
    2c0a:	93 07       	cpc	r25, r19
    2c0c:	a0 f4       	brcc	.+40     	; 0x2c36 <xTaskCheckForTimeOut+0xa2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    2c0e:	e8 85       	ldd	r30, Y+8	; 0x08
    2c10:	f9 85       	ldd	r31, Y+9	; 0x09
    2c12:	20 81       	ld	r18, Z
    2c14:	31 81       	ldd	r19, Z+1	; 0x01
    2c16:	89 81       	ldd	r24, Y+1	; 0x01
    2c18:	9a 81       	ldd	r25, Y+2	; 0x02
    2c1a:	a9 01       	movw	r20, r18
    2c1c:	48 1b       	sub	r20, r24
    2c1e:	59 0b       	sbc	r21, r25
    2c20:	ca 01       	movw	r24, r20
    2c22:	e8 85       	ldd	r30, Y+8	; 0x08
    2c24:	f9 85       	ldd	r31, Y+9	; 0x09
    2c26:	91 83       	std	Z+1, r25	; 0x01
    2c28:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    2c2a:	8e 81       	ldd	r24, Y+6	; 0x06
    2c2c:	9f 81       	ldd	r25, Y+7	; 0x07
    2c2e:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    2c32:	1d 82       	std	Y+5, r1	; 0x05
    2c34:	06 c0       	rjmp	.+12     	; 0x2c42 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			*pxTicksToWait = 0;
    2c36:	e8 85       	ldd	r30, Y+8	; 0x08
    2c38:	f9 85       	ldd	r31, Y+9	; 0x09
    2c3a:	11 82       	std	Z+1, r1	; 0x01
    2c3c:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    2c3e:	81 e0       	ldi	r24, 0x01	; 1
    2c40:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    2c42:	0f 90       	pop	r0
    2c44:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2c46:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2c48:	29 96       	adiw	r28, 0x09	; 9
    2c4a:	0f b6       	in	r0, 0x3f	; 63
    2c4c:	f8 94       	cli
    2c4e:	de bf       	out	0x3e, r29	; 62
    2c50:	0f be       	out	0x3f, r0	; 63
    2c52:	cd bf       	out	0x3d, r28	; 61
    2c54:	cf 91       	pop	r28
    2c56:	df 91       	pop	r29
    2c58:	08 95       	ret

00002c5a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2c5a:	df 93       	push	r29
    2c5c:	cf 93       	push	r28
    2c5e:	cd b7       	in	r28, 0x3d	; 61
    2c60:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    2c62:	81 e0       	ldi	r24, 0x01	; 1
    2c64:	80 93 e3 02 	sts	0x02E3, r24
}
    2c68:	cf 91       	pop	r28
    2c6a:	df 91       	pop	r29
    2c6c:	08 95       	ret

00002c6e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2c6e:	df 93       	push	r29
    2c70:	cf 93       	push	r28
    2c72:	00 d0       	rcall	.+0      	; 0x2c74 <prvIdleTask+0x6>
    2c74:	cd b7       	in	r28, 0x3d	; 61
    2c76:	de b7       	in	r29, 0x3e	; 62
    2c78:	9a 83       	std	Y+2, r25	; 0x02
    2c7a:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    2c7c:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <prvCheckTasksWaitingTermination>
    2c80:	fd cf       	rjmp	.-6      	; 0x2c7c <prvIdleTask+0xe>

00002c82 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    2c82:	df 93       	push	r29
    2c84:	cf 93       	push	r28
    2c86:	0f 92       	push	r0
    2c88:	cd b7       	in	r28, 0x3d	; 61
    2c8a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2c8c:	19 82       	std	Y+1, r1	; 0x01
    2c8e:	13 c0       	rjmp	.+38     	; 0x2cb6 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    2c90:	89 81       	ldd	r24, Y+1	; 0x01
    2c92:	28 2f       	mov	r18, r24
    2c94:	30 e0       	ldi	r19, 0x00	; 0
    2c96:	c9 01       	movw	r24, r18
    2c98:	88 0f       	add	r24, r24
    2c9a:	99 1f       	adc	r25, r25
    2c9c:	88 0f       	add	r24, r24
    2c9e:	99 1f       	adc	r25, r25
    2ca0:	88 0f       	add	r24, r24
    2ca2:	99 1f       	adc	r25, r25
    2ca4:	82 0f       	add	r24, r18
    2ca6:	93 1f       	adc	r25, r19
    2ca8:	85 51       	subi	r24, 0x15	; 21
    2caa:	9d 4f       	sbci	r25, 0xFD	; 253
    2cac:	0e 94 0f 04 	call	0x81e	; 0x81e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2cb0:	89 81       	ldd	r24, Y+1	; 0x01
    2cb2:	8f 5f       	subi	r24, 0xFF	; 255
    2cb4:	89 83       	std	Y+1, r24	; 0x01
    2cb6:	89 81       	ldd	r24, Y+1	; 0x01
    2cb8:	84 30       	cpi	r24, 0x04	; 4
    2cba:	50 f3       	brcs	.-44     	; 0x2c90 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    2cbc:	8f e0       	ldi	r24, 0x0F	; 15
    2cbe:	93 e0       	ldi	r25, 0x03	; 3
    2cc0:	0e 94 0f 04 	call	0x81e	; 0x81e <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    2cc4:	88 e1       	ldi	r24, 0x18	; 24
    2cc6:	93 e0       	ldi	r25, 0x03	; 3
    2cc8:	0e 94 0f 04 	call	0x81e	; 0x81e <vListInitialise>
	vListInitialise( &xPendingReadyList );
    2ccc:	85 e2       	ldi	r24, 0x25	; 37
    2cce:	93 e0       	ldi	r25, 0x03	; 3
    2cd0:	0e 94 0f 04 	call	0x81e	; 0x81e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    2cd4:	8e e2       	ldi	r24, 0x2E	; 46
    2cd6:	93 e0       	ldi	r25, 0x03	; 3
    2cd8:	0e 94 0f 04 	call	0x81e	; 0x81e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2cdc:	8f e0       	ldi	r24, 0x0F	; 15
    2cde:	93 e0       	ldi	r25, 0x03	; 3
    2ce0:	90 93 22 03 	sts	0x0322, r25
    2ce4:	80 93 21 03 	sts	0x0321, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2ce8:	88 e1       	ldi	r24, 0x18	; 24
    2cea:	93 e0       	ldi	r25, 0x03	; 3
    2cec:	90 93 24 03 	sts	0x0324, r25
    2cf0:	80 93 23 03 	sts	0x0323, r24
}
    2cf4:	0f 90       	pop	r0
    2cf6:	cf 91       	pop	r28
    2cf8:	df 91       	pop	r29
    2cfa:	08 95       	ret

00002cfc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2cfc:	df 93       	push	r29
    2cfe:	cf 93       	push	r28
    2d00:	00 d0       	rcall	.+0      	; 0x2d02 <prvCheckTasksWaitingTermination+0x6>
    2d02:	cd b7       	in	r28, 0x3d	; 61
    2d04:	de b7       	in	r29, 0x3e	; 62
    2d06:	20 c0       	rjmp	.+64     	; 0x2d48 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    2d08:	0f b6       	in	r0, 0x3f	; 63
    2d0a:	f8 94       	cli
    2d0c:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2d0e:	e0 91 33 03 	lds	r30, 0x0333
    2d12:	f0 91 34 03 	lds	r31, 0x0334
    2d16:	86 81       	ldd	r24, Z+6	; 0x06
    2d18:	97 81       	ldd	r25, Z+7	; 0x07
    2d1a:	9a 83       	std	Y+2, r25	; 0x02
    2d1c:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2d1e:	89 81       	ldd	r24, Y+1	; 0x01
    2d20:	9a 81       	ldd	r25, Y+2	; 0x02
    2d22:	02 96       	adiw	r24, 0x02	; 2
    2d24:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
				--uxCurrentNumberOfTasks;
    2d28:	80 91 dd 02 	lds	r24, 0x02DD
    2d2c:	81 50       	subi	r24, 0x01	; 1
    2d2e:	80 93 dd 02 	sts	0x02DD, r24
				--uxDeletedTasksWaitingCleanUp;
    2d32:	80 91 dc 02 	lds	r24, 0x02DC
    2d36:	81 50       	subi	r24, 0x01	; 1
    2d38:	80 93 dc 02 	sts	0x02DC, r24
			}
			taskEXIT_CRITICAL();
    2d3c:	0f 90       	pop	r0
    2d3e:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    2d40:	89 81       	ldd	r24, Y+1	; 0x01
    2d42:	9a 81       	ldd	r25, Y+2	; 0x02
    2d44:	0e 94 ad 16 	call	0x2d5a	; 0x2d5a <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    2d48:	80 91 dc 02 	lds	r24, 0x02DC
    2d4c:	88 23       	and	r24, r24
    2d4e:	e1 f6       	brne	.-72     	; 0x2d08 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    2d50:	0f 90       	pop	r0
    2d52:	0f 90       	pop	r0
    2d54:	cf 91       	pop	r28
    2d56:	df 91       	pop	r29
    2d58:	08 95       	ret

00002d5a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    2d5a:	df 93       	push	r29
    2d5c:	cf 93       	push	r28
    2d5e:	00 d0       	rcall	.+0      	; 0x2d60 <prvDeleteTCB+0x6>
    2d60:	cd b7       	in	r28, 0x3d	; 61
    2d62:	de b7       	in	r29, 0x3e	; 62
    2d64:	9a 83       	std	Y+2, r25	; 0x02
    2d66:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    2d68:	e9 81       	ldd	r30, Y+1	; 0x01
    2d6a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d6c:	87 89       	ldd	r24, Z+23	; 0x17
    2d6e:	90 8d       	ldd	r25, Z+24	; 0x18
    2d70:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <vPortFree>
			vPortFree( pxTCB );
    2d74:	89 81       	ldd	r24, Y+1	; 0x01
    2d76:	9a 81       	ldd	r25, Y+2	; 0x02
    2d78:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    2d7c:	0f 90       	pop	r0
    2d7e:	0f 90       	pop	r0
    2d80:	cf 91       	pop	r28
    2d82:	df 91       	pop	r29
    2d84:	08 95       	ret

00002d86 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    2d86:	df 93       	push	r29
    2d88:	cf 93       	push	r28
    2d8a:	00 d0       	rcall	.+0      	; 0x2d8c <prvResetNextTaskUnblockTime+0x6>
    2d8c:	cd b7       	in	r28, 0x3d	; 61
    2d8e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2d90:	e0 91 21 03 	lds	r30, 0x0321
    2d94:	f0 91 22 03 	lds	r31, 0x0322
    2d98:	80 81       	ld	r24, Z
    2d9a:	88 23       	and	r24, r24
    2d9c:	39 f4       	brne	.+14     	; 0x2dac <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    2d9e:	8f ef       	ldi	r24, 0xFF	; 255
    2da0:	9f ef       	ldi	r25, 0xFF	; 255
    2da2:	90 93 e7 02 	sts	0x02E7, r25
    2da6:	80 93 e6 02 	sts	0x02E6, r24
    2daa:	13 c0       	rjmp	.+38     	; 0x2dd2 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2dac:	e0 91 21 03 	lds	r30, 0x0321
    2db0:	f0 91 22 03 	lds	r31, 0x0322
    2db4:	05 80       	ldd	r0, Z+5	; 0x05
    2db6:	f6 81       	ldd	r31, Z+6	; 0x06
    2db8:	e0 2d       	mov	r30, r0
    2dba:	86 81       	ldd	r24, Z+6	; 0x06
    2dbc:	97 81       	ldd	r25, Z+7	; 0x07
    2dbe:	9a 83       	std	Y+2, r25	; 0x02
    2dc0:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    2dc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc6:	82 81       	ldd	r24, Z+2	; 0x02
    2dc8:	93 81       	ldd	r25, Z+3	; 0x03
    2dca:	90 93 e7 02 	sts	0x02E7, r25
    2dce:	80 93 e6 02 	sts	0x02E6, r24
	}
}
    2dd2:	0f 90       	pop	r0
    2dd4:	0f 90       	pop	r0
    2dd6:	cf 91       	pop	r28
    2dd8:	df 91       	pop	r29
    2dda:	08 95       	ret

00002ddc <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    2ddc:	df 93       	push	r29
    2dde:	cf 93       	push	r28
    2de0:	00 d0       	rcall	.+0      	; 0x2de2 <uxTaskResetEventItemValue+0x6>
    2de2:	cd b7       	in	r28, 0x3d	; 61
    2de4:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2de6:	e0 91 da 02 	lds	r30, 0x02DA
    2dea:	f0 91 db 02 	lds	r31, 0x02DB
    2dee:	84 85       	ldd	r24, Z+12	; 0x0c
    2df0:	95 85       	ldd	r25, Z+13	; 0x0d
    2df2:	9a 83       	std	Y+2, r25	; 0x02
    2df4:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2df6:	a0 91 da 02 	lds	r26, 0x02DA
    2dfa:	b0 91 db 02 	lds	r27, 0x02DB
    2dfe:	e0 91 da 02 	lds	r30, 0x02DA
    2e02:	f0 91 db 02 	lds	r31, 0x02DB
    2e06:	86 89       	ldd	r24, Z+22	; 0x16
    2e08:	28 2f       	mov	r18, r24
    2e0a:	30 e0       	ldi	r19, 0x00	; 0
    2e0c:	84 e0       	ldi	r24, 0x04	; 4
    2e0e:	90 e0       	ldi	r25, 0x00	; 0
    2e10:	82 1b       	sub	r24, r18
    2e12:	93 0b       	sbc	r25, r19
    2e14:	1d 96       	adiw	r26, 0x0d	; 13
    2e16:	9c 93       	st	X, r25
    2e18:	8e 93       	st	-X, r24
    2e1a:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    2e1c:	89 81       	ldd	r24, Y+1	; 0x01
    2e1e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2e20:	0f 90       	pop	r0
    2e22:	0f 90       	pop	r0
    2e24:	cf 91       	pop	r28
    2e26:	df 91       	pop	r29
    2e28:	08 95       	ret

00002e2a <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    2e2a:	df 93       	push	r29
    2e2c:	cf 93       	push	r28
    2e2e:	cd b7       	in	r28, 0x3d	; 61
    2e30:	de b7       	in	r29, 0x3e	; 62
    2e32:	27 97       	sbiw	r28, 0x07	; 7
    2e34:	0f b6       	in	r0, 0x3f	; 63
    2e36:	f8 94       	cli
    2e38:	de bf       	out	0x3e, r29	; 62
    2e3a:	0f be       	out	0x3f, r0	; 63
    2e3c:	cd bf       	out	0x3d, r28	; 61
    2e3e:	8d 83       	std	Y+5, r24	; 0x05
    2e40:	7f 83       	std	Y+7, r23	; 0x07
    2e42:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    2e44:	0f b6       	in	r0, 0x3f	; 63
    2e46:	f8 94       	cli
    2e48:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    2e4a:	e0 91 da 02 	lds	r30, 0x02DA
    2e4e:	f0 91 db 02 	lds	r31, 0x02DB
    2e52:	81 a1       	ldd	r24, Z+33	; 0x21
    2e54:	92 a1       	ldd	r25, Z+34	; 0x22
    2e56:	a3 a1       	ldd	r26, Z+35	; 0x23
    2e58:	b4 a1       	ldd	r27, Z+36	; 0x24
    2e5a:	00 97       	sbiw	r24, 0x00	; 0
    2e5c:	a1 05       	cpc	r26, r1
    2e5e:	b1 05       	cpc	r27, r1
    2e60:	89 f4       	brne	.+34     	; 0x2e84 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2e62:	e0 91 da 02 	lds	r30, 0x02DA
    2e66:	f0 91 db 02 	lds	r31, 0x02DB
    2e6a:	81 e0       	ldi	r24, 0x01	; 1
    2e6c:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    2e6e:	8e 81       	ldd	r24, Y+6	; 0x06
    2e70:	9f 81       	ldd	r25, Y+7	; 0x07
    2e72:	00 97       	sbiw	r24, 0x00	; 0
    2e74:	39 f0       	breq	.+14     	; 0x2e84 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2e76:	8e 81       	ldd	r24, Y+6	; 0x06
    2e78:	9f 81       	ldd	r25, Y+7	; 0x07
    2e7a:	61 e0       	ldi	r22, 0x01	; 1
    2e7c:	0e 94 bd 1a 	call	0x357a	; 0x357a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2e80:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2e84:	0f 90       	pop	r0
    2e86:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2e88:	0f b6       	in	r0, 0x3f	; 63
    2e8a:	f8 94       	cli
    2e8c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    2e8e:	e0 91 da 02 	lds	r30, 0x02DA
    2e92:	f0 91 db 02 	lds	r31, 0x02DB
    2e96:	81 a1       	ldd	r24, Z+33	; 0x21
    2e98:	92 a1       	ldd	r25, Z+34	; 0x22
    2e9a:	a3 a1       	ldd	r26, Z+35	; 0x23
    2e9c:	b4 a1       	ldd	r27, Z+36	; 0x24
    2e9e:	89 83       	std	Y+1, r24	; 0x01
    2ea0:	9a 83       	std	Y+2, r25	; 0x02
    2ea2:	ab 83       	std	Y+3, r26	; 0x03
    2ea4:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    2ea6:	89 81       	ldd	r24, Y+1	; 0x01
    2ea8:	9a 81       	ldd	r25, Y+2	; 0x02
    2eaa:	ab 81       	ldd	r26, Y+3	; 0x03
    2eac:	bc 81       	ldd	r27, Y+4	; 0x04
    2eae:	00 97       	sbiw	r24, 0x00	; 0
    2eb0:	a1 05       	cpc	r26, r1
    2eb2:	b1 05       	cpc	r27, r1
    2eb4:	d9 f0       	breq	.+54     	; 0x2eec <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    2eb6:	8d 81       	ldd	r24, Y+5	; 0x05
    2eb8:	88 23       	and	r24, r24
    2eba:	49 f0       	breq	.+18     	; 0x2ece <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    2ebc:	e0 91 da 02 	lds	r30, 0x02DA
    2ec0:	f0 91 db 02 	lds	r31, 0x02DB
    2ec4:	11 a2       	std	Z+33, r1	; 0x21
    2ec6:	12 a2       	std	Z+34, r1	; 0x22
    2ec8:	13 a2       	std	Z+35, r1	; 0x23
    2eca:	14 a2       	std	Z+36, r1	; 0x24
    2ecc:	0f c0       	rjmp	.+30     	; 0x2eec <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    2ece:	e0 91 da 02 	lds	r30, 0x02DA
    2ed2:	f0 91 db 02 	lds	r31, 0x02DB
    2ed6:	89 81       	ldd	r24, Y+1	; 0x01
    2ed8:	9a 81       	ldd	r25, Y+2	; 0x02
    2eda:	ab 81       	ldd	r26, Y+3	; 0x03
    2edc:	bc 81       	ldd	r27, Y+4	; 0x04
    2ede:	01 97       	sbiw	r24, 0x01	; 1
    2ee0:	a1 09       	sbc	r26, r1
    2ee2:	b1 09       	sbc	r27, r1
    2ee4:	81 a3       	std	Z+33, r24	; 0x21
    2ee6:	92 a3       	std	Z+34, r25	; 0x22
    2ee8:	a3 a3       	std	Z+35, r26	; 0x23
    2eea:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2eec:	e0 91 da 02 	lds	r30, 0x02DA
    2ef0:	f0 91 db 02 	lds	r31, 0x02DB
    2ef4:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    2ef6:	0f 90       	pop	r0
    2ef8:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    2efa:	89 81       	ldd	r24, Y+1	; 0x01
    2efc:	9a 81       	ldd	r25, Y+2	; 0x02
    2efe:	ab 81       	ldd	r26, Y+3	; 0x03
    2f00:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    2f02:	bc 01       	movw	r22, r24
    2f04:	cd 01       	movw	r24, r26
    2f06:	27 96       	adiw	r28, 0x07	; 7
    2f08:	0f b6       	in	r0, 0x3f	; 63
    2f0a:	f8 94       	cli
    2f0c:	de bf       	out	0x3e, r29	; 62
    2f0e:	0f be       	out	0x3f, r0	; 63
    2f10:	cd bf       	out	0x3d, r28	; 61
    2f12:	cf 91       	pop	r28
    2f14:	df 91       	pop	r29
    2f16:	08 95       	ret

00002f18 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    2f18:	ef 92       	push	r14
    2f1a:	ff 92       	push	r15
    2f1c:	0f 93       	push	r16
    2f1e:	1f 93       	push	r17
    2f20:	df 93       	push	r29
    2f22:	cf 93       	push	r28
    2f24:	cd b7       	in	r28, 0x3d	; 61
    2f26:	de b7       	in	r29, 0x3e	; 62
    2f28:	2d 97       	sbiw	r28, 0x0d	; 13
    2f2a:	0f b6       	in	r0, 0x3f	; 63
    2f2c:	f8 94       	cli
    2f2e:	de bf       	out	0x3e, r29	; 62
    2f30:	0f be       	out	0x3f, r0	; 63
    2f32:	cd bf       	out	0x3d, r28	; 61
    2f34:	6a 83       	std	Y+2, r22	; 0x02
    2f36:	7b 83       	std	Y+3, r23	; 0x03
    2f38:	8c 83       	std	Y+4, r24	; 0x04
    2f3a:	9d 83       	std	Y+5, r25	; 0x05
    2f3c:	2e 83       	std	Y+6, r18	; 0x06
    2f3e:	3f 83       	std	Y+7, r19	; 0x07
    2f40:	48 87       	std	Y+8, r20	; 0x08
    2f42:	59 87       	std	Y+9, r21	; 0x09
    2f44:	1b 87       	std	Y+11, r17	; 0x0b
    2f46:	0a 87       	std	Y+10, r16	; 0x0a
    2f48:	fd 86       	std	Y+13, r15	; 0x0d
    2f4a:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    2f4c:	0f b6       	in	r0, 0x3f	; 63
    2f4e:	f8 94       	cli
    2f50:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    2f52:	e0 91 da 02 	lds	r30, 0x02DA
    2f56:	f0 91 db 02 	lds	r31, 0x02DB
    2f5a:	85 a1       	ldd	r24, Z+37	; 0x25
    2f5c:	82 30       	cpi	r24, 0x02	; 2
    2f5e:	49 f1       	breq	.+82     	; 0x2fb2 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    2f60:	e0 91 da 02 	lds	r30, 0x02DA
    2f64:	f0 91 db 02 	lds	r31, 0x02DB
    2f68:	21 a1       	ldd	r18, Z+33	; 0x21
    2f6a:	32 a1       	ldd	r19, Z+34	; 0x22
    2f6c:	43 a1       	ldd	r20, Z+35	; 0x23
    2f6e:	54 a1       	ldd	r21, Z+36	; 0x24
    2f70:	8a 81       	ldd	r24, Y+2	; 0x02
    2f72:	9b 81       	ldd	r25, Y+3	; 0x03
    2f74:	ac 81       	ldd	r26, Y+4	; 0x04
    2f76:	bd 81       	ldd	r27, Y+5	; 0x05
    2f78:	80 95       	com	r24
    2f7a:	90 95       	com	r25
    2f7c:	a0 95       	com	r26
    2f7e:	b0 95       	com	r27
    2f80:	82 23       	and	r24, r18
    2f82:	93 23       	and	r25, r19
    2f84:	a4 23       	and	r26, r20
    2f86:	b5 23       	and	r27, r21
    2f88:	81 a3       	std	Z+33, r24	; 0x21
    2f8a:	92 a3       	std	Z+34, r25	; 0x22
    2f8c:	a3 a3       	std	Z+35, r26	; 0x23
    2f8e:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2f90:	e0 91 da 02 	lds	r30, 0x02DA
    2f94:	f0 91 db 02 	lds	r31, 0x02DB
    2f98:	81 e0       	ldi	r24, 0x01	; 1
    2f9a:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    2f9c:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f9e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2fa0:	00 97       	sbiw	r24, 0x00	; 0
    2fa2:	39 f0       	breq	.+14     	; 0x2fb2 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2fa4:	8c 85       	ldd	r24, Y+12	; 0x0c
    2fa6:	9d 85       	ldd	r25, Y+13	; 0x0d
    2fa8:	61 e0       	ldi	r22, 0x01	; 1
    2faa:	0e 94 bd 1a 	call	0x357a	; 0x357a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2fae:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2fb2:	0f 90       	pop	r0
    2fb4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2fb6:	0f b6       	in	r0, 0x3f	; 63
    2fb8:	f8 94       	cli
    2fba:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    2fbc:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fbe:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fc0:	00 97       	sbiw	r24, 0x00	; 0
    2fc2:	71 f0       	breq	.+28     	; 0x2fe0 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    2fc4:	e0 91 da 02 	lds	r30, 0x02DA
    2fc8:	f0 91 db 02 	lds	r31, 0x02DB
    2fcc:	81 a1       	ldd	r24, Z+33	; 0x21
    2fce:	92 a1       	ldd	r25, Z+34	; 0x22
    2fd0:	a3 a1       	ldd	r26, Z+35	; 0x23
    2fd2:	b4 a1       	ldd	r27, Z+36	; 0x24
    2fd4:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fd6:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fd8:	80 83       	st	Z, r24
    2fda:	91 83       	std	Z+1, r25	; 0x01
    2fdc:	a2 83       	std	Z+2, r26	; 0x02
    2fde:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    2fe0:	e0 91 da 02 	lds	r30, 0x02DA
    2fe4:	f0 91 db 02 	lds	r31, 0x02DB
    2fe8:	85 a1       	ldd	r24, Z+37	; 0x25
    2fea:	82 30       	cpi	r24, 0x02	; 2
    2fec:	11 f0       	breq	.+4      	; 0x2ff2 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2fee:	19 82       	std	Y+1, r1	; 0x01
    2ff0:	1a c0       	rjmp	.+52     	; 0x3026 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    2ff2:	e0 91 da 02 	lds	r30, 0x02DA
    2ff6:	f0 91 db 02 	lds	r31, 0x02DB
    2ffa:	21 a1       	ldd	r18, Z+33	; 0x21
    2ffc:	32 a1       	ldd	r19, Z+34	; 0x22
    2ffe:	43 a1       	ldd	r20, Z+35	; 0x23
    3000:	54 a1       	ldd	r21, Z+36	; 0x24
    3002:	8e 81       	ldd	r24, Y+6	; 0x06
    3004:	9f 81       	ldd	r25, Y+7	; 0x07
    3006:	a8 85       	ldd	r26, Y+8	; 0x08
    3008:	b9 85       	ldd	r27, Y+9	; 0x09
    300a:	80 95       	com	r24
    300c:	90 95       	com	r25
    300e:	a0 95       	com	r26
    3010:	b0 95       	com	r27
    3012:	82 23       	and	r24, r18
    3014:	93 23       	and	r25, r19
    3016:	a4 23       	and	r26, r20
    3018:	b5 23       	and	r27, r21
    301a:	81 a3       	std	Z+33, r24	; 0x21
    301c:	92 a3       	std	Z+34, r25	; 0x22
    301e:	a3 a3       	std	Z+35, r26	; 0x23
    3020:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    3022:	81 e0       	ldi	r24, 0x01	; 1
    3024:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3026:	e0 91 da 02 	lds	r30, 0x02DA
    302a:	f0 91 db 02 	lds	r31, 0x02DB
    302e:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3030:	0f 90       	pop	r0
    3032:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3034:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3036:	2d 96       	adiw	r28, 0x0d	; 13
    3038:	0f b6       	in	r0, 0x3f	; 63
    303a:	f8 94       	cli
    303c:	de bf       	out	0x3e, r29	; 62
    303e:	0f be       	out	0x3f, r0	; 63
    3040:	cd bf       	out	0x3d, r28	; 61
    3042:	cf 91       	pop	r28
    3044:	df 91       	pop	r29
    3046:	1f 91       	pop	r17
    3048:	0f 91       	pop	r16
    304a:	ff 90       	pop	r15
    304c:	ef 90       	pop	r14
    304e:	08 95       	ret

00003050 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    3050:	0f 93       	push	r16
    3052:	1f 93       	push	r17
    3054:	df 93       	push	r29
    3056:	cf 93       	push	r28
    3058:	cd b7       	in	r28, 0x3d	; 61
    305a:	de b7       	in	r29, 0x3e	; 62
    305c:	2f 97       	sbiw	r28, 0x0f	; 15
    305e:	0f b6       	in	r0, 0x3f	; 63
    3060:	f8 94       	cli
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	0f be       	out	0x3f, r0	; 63
    3066:	cd bf       	out	0x3d, r28	; 61
    3068:	9e 83       	std	Y+6, r25	; 0x06
    306a:	8d 83       	std	Y+5, r24	; 0x05
    306c:	4f 83       	std	Y+7, r20	; 0x07
    306e:	58 87       	std	Y+8, r21	; 0x08
    3070:	69 87       	std	Y+9, r22	; 0x09
    3072:	7a 87       	std	Y+10, r23	; 0x0a
    3074:	2b 87       	std	Y+11, r18	; 0x0b
    3076:	1d 87       	std	Y+13, r17	; 0x0d
    3078:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    307a:	81 e0       	ldi	r24, 0x01	; 1
    307c:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    307e:	8d 81       	ldd	r24, Y+5	; 0x05
    3080:	9e 81       	ldd	r25, Y+6	; 0x06
    3082:	9c 83       	std	Y+4, r25	; 0x04
    3084:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    3086:	0f b6       	in	r0, 0x3f	; 63
    3088:	f8 94       	cli
    308a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    308c:	8c 85       	ldd	r24, Y+12	; 0x0c
    308e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3090:	00 97       	sbiw	r24, 0x00	; 0
    3092:	61 f0       	breq	.+24     	; 0x30ac <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3094:	eb 81       	ldd	r30, Y+3	; 0x03
    3096:	fc 81       	ldd	r31, Y+4	; 0x04
    3098:	81 a1       	ldd	r24, Z+33	; 0x21
    309a:	92 a1       	ldd	r25, Z+34	; 0x22
    309c:	a3 a1       	ldd	r26, Z+35	; 0x23
    309e:	b4 a1       	ldd	r27, Z+36	; 0x24
    30a0:	ec 85       	ldd	r30, Y+12	; 0x0c
    30a2:	fd 85       	ldd	r31, Y+13	; 0x0d
    30a4:	80 83       	st	Z, r24
    30a6:	91 83       	std	Z+1, r25	; 0x01
    30a8:	a2 83       	std	Z+2, r26	; 0x02
    30aa:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    30ac:	eb 81       	ldd	r30, Y+3	; 0x03
    30ae:	fc 81       	ldd	r31, Y+4	; 0x04
    30b0:	85 a1       	ldd	r24, Z+37	; 0x25
    30b2:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    30b4:	eb 81       	ldd	r30, Y+3	; 0x03
    30b6:	fc 81       	ldd	r31, Y+4	; 0x04
    30b8:	82 e0       	ldi	r24, 0x02	; 2
    30ba:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    30bc:	8b 85       	ldd	r24, Y+11	; 0x0b
    30be:	28 2f       	mov	r18, r24
    30c0:	30 e0       	ldi	r19, 0x00	; 0
    30c2:	3f 87       	std	Y+15, r19	; 0x0f
    30c4:	2e 87       	std	Y+14, r18	; 0x0e
    30c6:	8e 85       	ldd	r24, Y+14	; 0x0e
    30c8:	9f 85       	ldd	r25, Y+15	; 0x0f
    30ca:	82 30       	cpi	r24, 0x02	; 2
    30cc:	91 05       	cpc	r25, r1
    30ce:	59 f1       	breq	.+86     	; 0x3126 <xTaskGenericNotify+0xd6>
    30d0:	2e 85       	ldd	r18, Y+14	; 0x0e
    30d2:	3f 85       	ldd	r19, Y+15	; 0x0f
    30d4:	23 30       	cpi	r18, 0x03	; 3
    30d6:	31 05       	cpc	r19, r1
    30d8:	34 f4       	brge	.+12     	; 0x30e6 <xTaskGenericNotify+0x96>
    30da:	8e 85       	ldd	r24, Y+14	; 0x0e
    30dc:	9f 85       	ldd	r25, Y+15	; 0x0f
    30de:	81 30       	cpi	r24, 0x01	; 1
    30e0:	91 05       	cpc	r25, r1
    30e2:	61 f0       	breq	.+24     	; 0x30fc <xTaskGenericNotify+0xac>
    30e4:	4a c0       	rjmp	.+148    	; 0x317a <xTaskGenericNotify+0x12a>
    30e6:	2e 85       	ldd	r18, Y+14	; 0x0e
    30e8:	3f 85       	ldd	r19, Y+15	; 0x0f
    30ea:	23 30       	cpi	r18, 0x03	; 3
    30ec:	31 05       	cpc	r19, r1
    30ee:	59 f1       	breq	.+86     	; 0x3146 <xTaskGenericNotify+0xf6>
    30f0:	8e 85       	ldd	r24, Y+14	; 0x0e
    30f2:	9f 85       	ldd	r25, Y+15	; 0x0f
    30f4:	84 30       	cpi	r24, 0x04	; 4
    30f6:	91 05       	cpc	r25, r1
    30f8:	89 f1       	breq	.+98     	; 0x315c <xTaskGenericNotify+0x10c>
    30fa:	3f c0       	rjmp	.+126    	; 0x317a <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    30fc:	eb 81       	ldd	r30, Y+3	; 0x03
    30fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3100:	21 a1       	ldd	r18, Z+33	; 0x21
    3102:	32 a1       	ldd	r19, Z+34	; 0x22
    3104:	43 a1       	ldd	r20, Z+35	; 0x23
    3106:	54 a1       	ldd	r21, Z+36	; 0x24
    3108:	8f 81       	ldd	r24, Y+7	; 0x07
    310a:	98 85       	ldd	r25, Y+8	; 0x08
    310c:	a9 85       	ldd	r26, Y+9	; 0x09
    310e:	ba 85       	ldd	r27, Y+10	; 0x0a
    3110:	82 2b       	or	r24, r18
    3112:	93 2b       	or	r25, r19
    3114:	a4 2b       	or	r26, r20
    3116:	b5 2b       	or	r27, r21
    3118:	eb 81       	ldd	r30, Y+3	; 0x03
    311a:	fc 81       	ldd	r31, Y+4	; 0x04
    311c:	81 a3       	std	Z+33, r24	; 0x21
    311e:	92 a3       	std	Z+34, r25	; 0x22
    3120:	a3 a3       	std	Z+35, r26	; 0x23
    3122:	b4 a3       	std	Z+36, r27	; 0x24
    3124:	2a c0       	rjmp	.+84     	; 0x317a <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3126:	eb 81       	ldd	r30, Y+3	; 0x03
    3128:	fc 81       	ldd	r31, Y+4	; 0x04
    312a:	81 a1       	ldd	r24, Z+33	; 0x21
    312c:	92 a1       	ldd	r25, Z+34	; 0x22
    312e:	a3 a1       	ldd	r26, Z+35	; 0x23
    3130:	b4 a1       	ldd	r27, Z+36	; 0x24
    3132:	01 96       	adiw	r24, 0x01	; 1
    3134:	a1 1d       	adc	r26, r1
    3136:	b1 1d       	adc	r27, r1
    3138:	eb 81       	ldd	r30, Y+3	; 0x03
    313a:	fc 81       	ldd	r31, Y+4	; 0x04
    313c:	81 a3       	std	Z+33, r24	; 0x21
    313e:	92 a3       	std	Z+34, r25	; 0x22
    3140:	a3 a3       	std	Z+35, r26	; 0x23
    3142:	b4 a3       	std	Z+36, r27	; 0x24
    3144:	1a c0       	rjmp	.+52     	; 0x317a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3146:	eb 81       	ldd	r30, Y+3	; 0x03
    3148:	fc 81       	ldd	r31, Y+4	; 0x04
    314a:	8f 81       	ldd	r24, Y+7	; 0x07
    314c:	98 85       	ldd	r25, Y+8	; 0x08
    314e:	a9 85       	ldd	r26, Y+9	; 0x09
    3150:	ba 85       	ldd	r27, Y+10	; 0x0a
    3152:	81 a3       	std	Z+33, r24	; 0x21
    3154:	92 a3       	std	Z+34, r25	; 0x22
    3156:	a3 a3       	std	Z+35, r26	; 0x23
    3158:	b4 a3       	std	Z+36, r27	; 0x24
    315a:	0f c0       	rjmp	.+30     	; 0x317a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    315c:	89 81       	ldd	r24, Y+1	; 0x01
    315e:	82 30       	cpi	r24, 0x02	; 2
    3160:	59 f0       	breq	.+22     	; 0x3178 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3162:	eb 81       	ldd	r30, Y+3	; 0x03
    3164:	fc 81       	ldd	r31, Y+4	; 0x04
    3166:	8f 81       	ldd	r24, Y+7	; 0x07
    3168:	98 85       	ldd	r25, Y+8	; 0x08
    316a:	a9 85       	ldd	r26, Y+9	; 0x09
    316c:	ba 85       	ldd	r27, Y+10	; 0x0a
    316e:	81 a3       	std	Z+33, r24	; 0x21
    3170:	92 a3       	std	Z+34, r25	; 0x22
    3172:	a3 a3       	std	Z+35, r26	; 0x23
    3174:	b4 a3       	std	Z+36, r27	; 0x24
    3176:	01 c0       	rjmp	.+2      	; 0x317a <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3178:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    317a:	89 81       	ldd	r24, Y+1	; 0x01
    317c:	81 30       	cpi	r24, 0x01	; 1
    317e:	b9 f5       	brne	.+110    	; 0x31ee <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3180:	8b 81       	ldd	r24, Y+3	; 0x03
    3182:	9c 81       	ldd	r25, Y+4	; 0x04
    3184:	02 96       	adiw	r24, 0x02	; 2
    3186:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    318a:	eb 81       	ldd	r30, Y+3	; 0x03
    318c:	fc 81       	ldd	r31, Y+4	; 0x04
    318e:	96 89       	ldd	r25, Z+22	; 0x16
    3190:	80 91 e0 02 	lds	r24, 0x02E0
    3194:	89 17       	cp	r24, r25
    3196:	28 f4       	brcc	.+10     	; 0x31a2 <xTaskGenericNotify+0x152>
    3198:	eb 81       	ldd	r30, Y+3	; 0x03
    319a:	fc 81       	ldd	r31, Y+4	; 0x04
    319c:	86 89       	ldd	r24, Z+22	; 0x16
    319e:	80 93 e0 02 	sts	0x02E0, r24
    31a2:	eb 81       	ldd	r30, Y+3	; 0x03
    31a4:	fc 81       	ldd	r31, Y+4	; 0x04
    31a6:	86 89       	ldd	r24, Z+22	; 0x16
    31a8:	28 2f       	mov	r18, r24
    31aa:	30 e0       	ldi	r19, 0x00	; 0
    31ac:	c9 01       	movw	r24, r18
    31ae:	88 0f       	add	r24, r24
    31b0:	99 1f       	adc	r25, r25
    31b2:	88 0f       	add	r24, r24
    31b4:	99 1f       	adc	r25, r25
    31b6:	88 0f       	add	r24, r24
    31b8:	99 1f       	adc	r25, r25
    31ba:	82 0f       	add	r24, r18
    31bc:	93 1f       	adc	r25, r19
    31be:	ac 01       	movw	r20, r24
    31c0:	45 51       	subi	r20, 0x15	; 21
    31c2:	5d 4f       	sbci	r21, 0xFD	; 253
    31c4:	8b 81       	ldd	r24, Y+3	; 0x03
    31c6:	9c 81       	ldd	r25, Y+4	; 0x04
    31c8:	9c 01       	movw	r18, r24
    31ca:	2e 5f       	subi	r18, 0xFE	; 254
    31cc:	3f 4f       	sbci	r19, 0xFF	; 255
    31ce:	ca 01       	movw	r24, r20
    31d0:	b9 01       	movw	r22, r18
    31d2:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    31d6:	eb 81       	ldd	r30, Y+3	; 0x03
    31d8:	fc 81       	ldd	r31, Y+4	; 0x04
    31da:	96 89       	ldd	r25, Z+22	; 0x16
    31dc:	e0 91 da 02 	lds	r30, 0x02DA
    31e0:	f0 91 db 02 	lds	r31, 0x02DB
    31e4:	86 89       	ldd	r24, Z+22	; 0x16
    31e6:	89 17       	cp	r24, r25
    31e8:	10 f4       	brcc	.+4      	; 0x31ee <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    31ea:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    31ee:	0f 90       	pop	r0
    31f0:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    31f2:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    31f4:	2f 96       	adiw	r28, 0x0f	; 15
    31f6:	0f b6       	in	r0, 0x3f	; 63
    31f8:	f8 94       	cli
    31fa:	de bf       	out	0x3e, r29	; 62
    31fc:	0f be       	out	0x3f, r0	; 63
    31fe:	cd bf       	out	0x3d, r28	; 61
    3200:	cf 91       	pop	r28
    3202:	df 91       	pop	r29
    3204:	1f 91       	pop	r17
    3206:	0f 91       	pop	r16
    3208:	08 95       	ret

0000320a <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    320a:	ef 92       	push	r14
    320c:	ff 92       	push	r15
    320e:	0f 93       	push	r16
    3210:	1f 93       	push	r17
    3212:	df 93       	push	r29
    3214:	cf 93       	push	r28
    3216:	cd b7       	in	r28, 0x3d	; 61
    3218:	de b7       	in	r29, 0x3e	; 62
    321a:	62 97       	sbiw	r28, 0x12	; 18
    321c:	0f b6       	in	r0, 0x3f	; 63
    321e:	f8 94       	cli
    3220:	de bf       	out	0x3e, r29	; 62
    3222:	0f be       	out	0x3f, r0	; 63
    3224:	cd bf       	out	0x3d, r28	; 61
    3226:	9f 83       	std	Y+7, r25	; 0x07
    3228:	8e 83       	std	Y+6, r24	; 0x06
    322a:	48 87       	std	Y+8, r20	; 0x08
    322c:	59 87       	std	Y+9, r21	; 0x09
    322e:	6a 87       	std	Y+10, r22	; 0x0a
    3230:	7b 87       	std	Y+11, r23	; 0x0b
    3232:	2c 87       	std	Y+12, r18	; 0x0c
    3234:	1e 87       	std	Y+14, r17	; 0x0e
    3236:	0d 87       	std	Y+13, r16	; 0x0d
    3238:	f8 8a       	std	Y+16, r15	; 0x10
    323a:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    323c:	81 e0       	ldi	r24, 0x01	; 1
    323e:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3240:	8e 81       	ldd	r24, Y+6	; 0x06
    3242:	9f 81       	ldd	r25, Y+7	; 0x07
    3244:	9d 83       	std	Y+5, r25	; 0x05
    3246:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3248:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    324a:	8d 85       	ldd	r24, Y+13	; 0x0d
    324c:	9e 85       	ldd	r25, Y+14	; 0x0e
    324e:	00 97       	sbiw	r24, 0x00	; 0
    3250:	61 f0       	breq	.+24     	; 0x326a <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3252:	ec 81       	ldd	r30, Y+4	; 0x04
    3254:	fd 81       	ldd	r31, Y+5	; 0x05
    3256:	81 a1       	ldd	r24, Z+33	; 0x21
    3258:	92 a1       	ldd	r25, Z+34	; 0x22
    325a:	a3 a1       	ldd	r26, Z+35	; 0x23
    325c:	b4 a1       	ldd	r27, Z+36	; 0x24
    325e:	ed 85       	ldd	r30, Y+13	; 0x0d
    3260:	fe 85       	ldd	r31, Y+14	; 0x0e
    3262:	80 83       	st	Z, r24
    3264:	91 83       	std	Z+1, r25	; 0x01
    3266:	a2 83       	std	Z+2, r26	; 0x02
    3268:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    326a:	ec 81       	ldd	r30, Y+4	; 0x04
    326c:	fd 81       	ldd	r31, Y+5	; 0x05
    326e:	85 a1       	ldd	r24, Z+37	; 0x25
    3270:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3272:	ec 81       	ldd	r30, Y+4	; 0x04
    3274:	fd 81       	ldd	r31, Y+5	; 0x05
    3276:	82 e0       	ldi	r24, 0x02	; 2
    3278:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    327a:	8c 85       	ldd	r24, Y+12	; 0x0c
    327c:	28 2f       	mov	r18, r24
    327e:	30 e0       	ldi	r19, 0x00	; 0
    3280:	3a 8b       	std	Y+18, r19	; 0x12
    3282:	29 8b       	std	Y+17, r18	; 0x11
    3284:	89 89       	ldd	r24, Y+17	; 0x11
    3286:	9a 89       	ldd	r25, Y+18	; 0x12
    3288:	82 30       	cpi	r24, 0x02	; 2
    328a:	91 05       	cpc	r25, r1
    328c:	59 f1       	breq	.+86     	; 0x32e4 <xTaskGenericNotifyFromISR+0xda>
    328e:	29 89       	ldd	r18, Y+17	; 0x11
    3290:	3a 89       	ldd	r19, Y+18	; 0x12
    3292:	23 30       	cpi	r18, 0x03	; 3
    3294:	31 05       	cpc	r19, r1
    3296:	34 f4       	brge	.+12     	; 0x32a4 <xTaskGenericNotifyFromISR+0x9a>
    3298:	89 89       	ldd	r24, Y+17	; 0x11
    329a:	9a 89       	ldd	r25, Y+18	; 0x12
    329c:	81 30       	cpi	r24, 0x01	; 1
    329e:	91 05       	cpc	r25, r1
    32a0:	61 f0       	breq	.+24     	; 0x32ba <xTaskGenericNotifyFromISR+0xb0>
    32a2:	4a c0       	rjmp	.+148    	; 0x3338 <xTaskGenericNotifyFromISR+0x12e>
    32a4:	29 89       	ldd	r18, Y+17	; 0x11
    32a6:	3a 89       	ldd	r19, Y+18	; 0x12
    32a8:	23 30       	cpi	r18, 0x03	; 3
    32aa:	31 05       	cpc	r19, r1
    32ac:	59 f1       	breq	.+86     	; 0x3304 <xTaskGenericNotifyFromISR+0xfa>
    32ae:	89 89       	ldd	r24, Y+17	; 0x11
    32b0:	9a 89       	ldd	r25, Y+18	; 0x12
    32b2:	84 30       	cpi	r24, 0x04	; 4
    32b4:	91 05       	cpc	r25, r1
    32b6:	89 f1       	breq	.+98     	; 0x331a <xTaskGenericNotifyFromISR+0x110>
    32b8:	3f c0       	rjmp	.+126    	; 0x3338 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    32ba:	ec 81       	ldd	r30, Y+4	; 0x04
    32bc:	fd 81       	ldd	r31, Y+5	; 0x05
    32be:	21 a1       	ldd	r18, Z+33	; 0x21
    32c0:	32 a1       	ldd	r19, Z+34	; 0x22
    32c2:	43 a1       	ldd	r20, Z+35	; 0x23
    32c4:	54 a1       	ldd	r21, Z+36	; 0x24
    32c6:	88 85       	ldd	r24, Y+8	; 0x08
    32c8:	99 85       	ldd	r25, Y+9	; 0x09
    32ca:	aa 85       	ldd	r26, Y+10	; 0x0a
    32cc:	bb 85       	ldd	r27, Y+11	; 0x0b
    32ce:	82 2b       	or	r24, r18
    32d0:	93 2b       	or	r25, r19
    32d2:	a4 2b       	or	r26, r20
    32d4:	b5 2b       	or	r27, r21
    32d6:	ec 81       	ldd	r30, Y+4	; 0x04
    32d8:	fd 81       	ldd	r31, Y+5	; 0x05
    32da:	81 a3       	std	Z+33, r24	; 0x21
    32dc:	92 a3       	std	Z+34, r25	; 0x22
    32de:	a3 a3       	std	Z+35, r26	; 0x23
    32e0:	b4 a3       	std	Z+36, r27	; 0x24
    32e2:	2a c0       	rjmp	.+84     	; 0x3338 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    32e4:	ec 81       	ldd	r30, Y+4	; 0x04
    32e6:	fd 81       	ldd	r31, Y+5	; 0x05
    32e8:	81 a1       	ldd	r24, Z+33	; 0x21
    32ea:	92 a1       	ldd	r25, Z+34	; 0x22
    32ec:	a3 a1       	ldd	r26, Z+35	; 0x23
    32ee:	b4 a1       	ldd	r27, Z+36	; 0x24
    32f0:	01 96       	adiw	r24, 0x01	; 1
    32f2:	a1 1d       	adc	r26, r1
    32f4:	b1 1d       	adc	r27, r1
    32f6:	ec 81       	ldd	r30, Y+4	; 0x04
    32f8:	fd 81       	ldd	r31, Y+5	; 0x05
    32fa:	81 a3       	std	Z+33, r24	; 0x21
    32fc:	92 a3       	std	Z+34, r25	; 0x22
    32fe:	a3 a3       	std	Z+35, r26	; 0x23
    3300:	b4 a3       	std	Z+36, r27	; 0x24
    3302:	1a c0       	rjmp	.+52     	; 0x3338 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3304:	ec 81       	ldd	r30, Y+4	; 0x04
    3306:	fd 81       	ldd	r31, Y+5	; 0x05
    3308:	88 85       	ldd	r24, Y+8	; 0x08
    330a:	99 85       	ldd	r25, Y+9	; 0x09
    330c:	aa 85       	ldd	r26, Y+10	; 0x0a
    330e:	bb 85       	ldd	r27, Y+11	; 0x0b
    3310:	81 a3       	std	Z+33, r24	; 0x21
    3312:	92 a3       	std	Z+34, r25	; 0x22
    3314:	a3 a3       	std	Z+35, r26	; 0x23
    3316:	b4 a3       	std	Z+36, r27	; 0x24
    3318:	0f c0       	rjmp	.+30     	; 0x3338 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    331a:	8b 81       	ldd	r24, Y+3	; 0x03
    331c:	82 30       	cpi	r24, 0x02	; 2
    331e:	59 f0       	breq	.+22     	; 0x3336 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3320:	ec 81       	ldd	r30, Y+4	; 0x04
    3322:	fd 81       	ldd	r31, Y+5	; 0x05
    3324:	88 85       	ldd	r24, Y+8	; 0x08
    3326:	99 85       	ldd	r25, Y+9	; 0x09
    3328:	aa 85       	ldd	r26, Y+10	; 0x0a
    332a:	bb 85       	ldd	r27, Y+11	; 0x0b
    332c:	81 a3       	std	Z+33, r24	; 0x21
    332e:	92 a3       	std	Z+34, r25	; 0x22
    3330:	a3 a3       	std	Z+35, r26	; 0x23
    3332:	b4 a3       	std	Z+36, r27	; 0x24
    3334:	01 c0       	rjmp	.+2      	; 0x3338 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3336:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3338:	8b 81       	ldd	r24, Y+3	; 0x03
    333a:	81 30       	cpi	r24, 0x01	; 1
    333c:	09 f0       	breq	.+2      	; 0x3340 <xTaskGenericNotifyFromISR+0x136>
    333e:	4f c0       	rjmp	.+158    	; 0x33de <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3340:	80 91 ea 02 	lds	r24, 0x02EA
    3344:	88 23       	and	r24, r24
    3346:	61 f5       	brne	.+88     	; 0x33a0 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3348:	8c 81       	ldd	r24, Y+4	; 0x04
    334a:	9d 81       	ldd	r25, Y+5	; 0x05
    334c:	02 96       	adiw	r24, 0x02	; 2
    334e:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3352:	ec 81       	ldd	r30, Y+4	; 0x04
    3354:	fd 81       	ldd	r31, Y+5	; 0x05
    3356:	96 89       	ldd	r25, Z+22	; 0x16
    3358:	80 91 e0 02 	lds	r24, 0x02E0
    335c:	89 17       	cp	r24, r25
    335e:	28 f4       	brcc	.+10     	; 0x336a <xTaskGenericNotifyFromISR+0x160>
    3360:	ec 81       	ldd	r30, Y+4	; 0x04
    3362:	fd 81       	ldd	r31, Y+5	; 0x05
    3364:	86 89       	ldd	r24, Z+22	; 0x16
    3366:	80 93 e0 02 	sts	0x02E0, r24
    336a:	ec 81       	ldd	r30, Y+4	; 0x04
    336c:	fd 81       	ldd	r31, Y+5	; 0x05
    336e:	86 89       	ldd	r24, Z+22	; 0x16
    3370:	28 2f       	mov	r18, r24
    3372:	30 e0       	ldi	r19, 0x00	; 0
    3374:	c9 01       	movw	r24, r18
    3376:	88 0f       	add	r24, r24
    3378:	99 1f       	adc	r25, r25
    337a:	88 0f       	add	r24, r24
    337c:	99 1f       	adc	r25, r25
    337e:	88 0f       	add	r24, r24
    3380:	99 1f       	adc	r25, r25
    3382:	82 0f       	add	r24, r18
    3384:	93 1f       	adc	r25, r19
    3386:	ac 01       	movw	r20, r24
    3388:	45 51       	subi	r20, 0x15	; 21
    338a:	5d 4f       	sbci	r21, 0xFD	; 253
    338c:	8c 81       	ldd	r24, Y+4	; 0x04
    338e:	9d 81       	ldd	r25, Y+5	; 0x05
    3390:	9c 01       	movw	r18, r24
    3392:	2e 5f       	subi	r18, 0xFE	; 254
    3394:	3f 4f       	sbci	r19, 0xFF	; 255
    3396:	ca 01       	movw	r24, r20
    3398:	b9 01       	movw	r22, r18
    339a:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>
    339e:	0a c0       	rjmp	.+20     	; 0x33b4 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    33a0:	8c 81       	ldd	r24, Y+4	; 0x04
    33a2:	9d 81       	ldd	r25, Y+5	; 0x05
    33a4:	9c 01       	movw	r18, r24
    33a6:	24 5f       	subi	r18, 0xF4	; 244
    33a8:	3f 4f       	sbci	r19, 0xFF	; 255
    33aa:	85 e2       	ldi	r24, 0x25	; 37
    33ac:	93 e0       	ldi	r25, 0x03	; 3
    33ae:	b9 01       	movw	r22, r18
    33b0:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    33b4:	ec 81       	ldd	r30, Y+4	; 0x04
    33b6:	fd 81       	ldd	r31, Y+5	; 0x05
    33b8:	96 89       	ldd	r25, Z+22	; 0x16
    33ba:	e0 91 da 02 	lds	r30, 0x02DA
    33be:	f0 91 db 02 	lds	r31, 0x02DB
    33c2:	86 89       	ldd	r24, Z+22	; 0x16
    33c4:	89 17       	cp	r24, r25
    33c6:	58 f4       	brcc	.+22     	; 0x33de <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    33c8:	8f 85       	ldd	r24, Y+15	; 0x0f
    33ca:	98 89       	ldd	r25, Y+16	; 0x10
    33cc:	00 97       	sbiw	r24, 0x00	; 0
    33ce:	21 f0       	breq	.+8      	; 0x33d8 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    33d0:	ef 85       	ldd	r30, Y+15	; 0x0f
    33d2:	f8 89       	ldd	r31, Y+16	; 0x10
    33d4:	81 e0       	ldi	r24, 0x01	; 1
    33d6:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    33d8:	81 e0       	ldi	r24, 0x01	; 1
    33da:	80 93 e3 02 	sts	0x02E3, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    33de:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    33e0:	62 96       	adiw	r28, 0x12	; 18
    33e2:	0f b6       	in	r0, 0x3f	; 63
    33e4:	f8 94       	cli
    33e6:	de bf       	out	0x3e, r29	; 62
    33e8:	0f be       	out	0x3f, r0	; 63
    33ea:	cd bf       	out	0x3d, r28	; 61
    33ec:	cf 91       	pop	r28
    33ee:	df 91       	pop	r29
    33f0:	1f 91       	pop	r17
    33f2:	0f 91       	pop	r16
    33f4:	ff 90       	pop	r15
    33f6:	ef 90       	pop	r14
    33f8:	08 95       	ret

000033fa <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    33fa:	df 93       	push	r29
    33fc:	cf 93       	push	r28
    33fe:	cd b7       	in	r28, 0x3d	; 61
    3400:	de b7       	in	r29, 0x3e	; 62
    3402:	28 97       	sbiw	r28, 0x08	; 8
    3404:	0f b6       	in	r0, 0x3f	; 63
    3406:	f8 94       	cli
    3408:	de bf       	out	0x3e, r29	; 62
    340a:	0f be       	out	0x3f, r0	; 63
    340c:	cd bf       	out	0x3d, r28	; 61
    340e:	9e 83       	std	Y+6, r25	; 0x06
    3410:	8d 83       	std	Y+5, r24	; 0x05
    3412:	78 87       	std	Y+8, r23	; 0x08
    3414:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3416:	8d 81       	ldd	r24, Y+5	; 0x05
    3418:	9e 81       	ldd	r25, Y+6	; 0x06
    341a:	9c 83       	std	Y+4, r25	; 0x04
    341c:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    341e:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3420:	eb 81       	ldd	r30, Y+3	; 0x03
    3422:	fc 81       	ldd	r31, Y+4	; 0x04
    3424:	85 a1       	ldd	r24, Z+37	; 0x25
    3426:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3428:	eb 81       	ldd	r30, Y+3	; 0x03
    342a:	fc 81       	ldd	r31, Y+4	; 0x04
    342c:	82 e0       	ldi	r24, 0x02	; 2
    342e:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    3430:	eb 81       	ldd	r30, Y+3	; 0x03
    3432:	fc 81       	ldd	r31, Y+4	; 0x04
    3434:	81 a1       	ldd	r24, Z+33	; 0x21
    3436:	92 a1       	ldd	r25, Z+34	; 0x22
    3438:	a3 a1       	ldd	r26, Z+35	; 0x23
    343a:	b4 a1       	ldd	r27, Z+36	; 0x24
    343c:	01 96       	adiw	r24, 0x01	; 1
    343e:	a1 1d       	adc	r26, r1
    3440:	b1 1d       	adc	r27, r1
    3442:	eb 81       	ldd	r30, Y+3	; 0x03
    3444:	fc 81       	ldd	r31, Y+4	; 0x04
    3446:	81 a3       	std	Z+33, r24	; 0x21
    3448:	92 a3       	std	Z+34, r25	; 0x22
    344a:	a3 a3       	std	Z+35, r26	; 0x23
    344c:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    344e:	8a 81       	ldd	r24, Y+2	; 0x02
    3450:	81 30       	cpi	r24, 0x01	; 1
    3452:	09 f0       	breq	.+2      	; 0x3456 <vTaskNotifyGiveFromISR+0x5c>
    3454:	4f c0       	rjmp	.+158    	; 0x34f4 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3456:	80 91 ea 02 	lds	r24, 0x02EA
    345a:	88 23       	and	r24, r24
    345c:	61 f5       	brne	.+88     	; 0x34b6 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    345e:	8b 81       	ldd	r24, Y+3	; 0x03
    3460:	9c 81       	ldd	r25, Y+4	; 0x04
    3462:	02 96       	adiw	r24, 0x02	; 2
    3464:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3468:	eb 81       	ldd	r30, Y+3	; 0x03
    346a:	fc 81       	ldd	r31, Y+4	; 0x04
    346c:	96 89       	ldd	r25, Z+22	; 0x16
    346e:	80 91 e0 02 	lds	r24, 0x02E0
    3472:	89 17       	cp	r24, r25
    3474:	28 f4       	brcc	.+10     	; 0x3480 <vTaskNotifyGiveFromISR+0x86>
    3476:	eb 81       	ldd	r30, Y+3	; 0x03
    3478:	fc 81       	ldd	r31, Y+4	; 0x04
    347a:	86 89       	ldd	r24, Z+22	; 0x16
    347c:	80 93 e0 02 	sts	0x02E0, r24
    3480:	eb 81       	ldd	r30, Y+3	; 0x03
    3482:	fc 81       	ldd	r31, Y+4	; 0x04
    3484:	86 89       	ldd	r24, Z+22	; 0x16
    3486:	28 2f       	mov	r18, r24
    3488:	30 e0       	ldi	r19, 0x00	; 0
    348a:	c9 01       	movw	r24, r18
    348c:	88 0f       	add	r24, r24
    348e:	99 1f       	adc	r25, r25
    3490:	88 0f       	add	r24, r24
    3492:	99 1f       	adc	r25, r25
    3494:	88 0f       	add	r24, r24
    3496:	99 1f       	adc	r25, r25
    3498:	82 0f       	add	r24, r18
    349a:	93 1f       	adc	r25, r19
    349c:	ac 01       	movw	r20, r24
    349e:	45 51       	subi	r20, 0x15	; 21
    34a0:	5d 4f       	sbci	r21, 0xFD	; 253
    34a2:	8b 81       	ldd	r24, Y+3	; 0x03
    34a4:	9c 81       	ldd	r25, Y+4	; 0x04
    34a6:	9c 01       	movw	r18, r24
    34a8:	2e 5f       	subi	r18, 0xFE	; 254
    34aa:	3f 4f       	sbci	r19, 0xFF	; 255
    34ac:	ca 01       	movw	r24, r20
    34ae:	b9 01       	movw	r22, r18
    34b0:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>
    34b4:	0a c0       	rjmp	.+20     	; 0x34ca <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    34b6:	8b 81       	ldd	r24, Y+3	; 0x03
    34b8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ba:	9c 01       	movw	r18, r24
    34bc:	24 5f       	subi	r18, 0xF4	; 244
    34be:	3f 4f       	sbci	r19, 0xFF	; 255
    34c0:	85 e2       	ldi	r24, 0x25	; 37
    34c2:	93 e0       	ldi	r25, 0x03	; 3
    34c4:	b9 01       	movw	r22, r18
    34c6:	0e 94 49 04 	call	0x892	; 0x892 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    34ca:	eb 81       	ldd	r30, Y+3	; 0x03
    34cc:	fc 81       	ldd	r31, Y+4	; 0x04
    34ce:	96 89       	ldd	r25, Z+22	; 0x16
    34d0:	e0 91 da 02 	lds	r30, 0x02DA
    34d4:	f0 91 db 02 	lds	r31, 0x02DB
    34d8:	86 89       	ldd	r24, Z+22	; 0x16
    34da:	89 17       	cp	r24, r25
    34dc:	58 f4       	brcc	.+22     	; 0x34f4 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    34de:	8f 81       	ldd	r24, Y+7	; 0x07
    34e0:	98 85       	ldd	r25, Y+8	; 0x08
    34e2:	00 97       	sbiw	r24, 0x00	; 0
    34e4:	21 f0       	breq	.+8      	; 0x34ee <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    34e6:	ef 81       	ldd	r30, Y+7	; 0x07
    34e8:	f8 85       	ldd	r31, Y+8	; 0x08
    34ea:	81 e0       	ldi	r24, 0x01	; 1
    34ec:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    34ee:	81 e0       	ldi	r24, 0x01	; 1
    34f0:	80 93 e3 02 	sts	0x02E3, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    34f4:	28 96       	adiw	r28, 0x08	; 8
    34f6:	0f b6       	in	r0, 0x3f	; 63
    34f8:	f8 94       	cli
    34fa:	de bf       	out	0x3e, r29	; 62
    34fc:	0f be       	out	0x3f, r0	; 63
    34fe:	cd bf       	out	0x3d, r28	; 61
    3500:	cf 91       	pop	r28
    3502:	df 91       	pop	r29
    3504:	08 95       	ret

00003506 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    3506:	df 93       	push	r29
    3508:	cf 93       	push	r28
    350a:	cd b7       	in	r28, 0x3d	; 61
    350c:	de b7       	in	r29, 0x3e	; 62
    350e:	27 97       	sbiw	r28, 0x07	; 7
    3510:	0f b6       	in	r0, 0x3f	; 63
    3512:	f8 94       	cli
    3514:	de bf       	out	0x3e, r29	; 62
    3516:	0f be       	out	0x3f, r0	; 63
    3518:	cd bf       	out	0x3d, r28	; 61
    351a:	9d 83       	std	Y+5, r25	; 0x05
    351c:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    351e:	8c 81       	ldd	r24, Y+4	; 0x04
    3520:	9d 81       	ldd	r25, Y+5	; 0x05
    3522:	00 97       	sbiw	r24, 0x00	; 0
    3524:	39 f4       	brne	.+14     	; 0x3534 <xTaskNotifyStateClear+0x2e>
    3526:	80 91 da 02 	lds	r24, 0x02DA
    352a:	90 91 db 02 	lds	r25, 0x02DB
    352e:	9f 83       	std	Y+7, r25	; 0x07
    3530:	8e 83       	std	Y+6, r24	; 0x06
    3532:	04 c0       	rjmp	.+8      	; 0x353c <xTaskNotifyStateClear+0x36>
    3534:	8c 81       	ldd	r24, Y+4	; 0x04
    3536:	9d 81       	ldd	r25, Y+5	; 0x05
    3538:	9f 83       	std	Y+7, r25	; 0x07
    353a:	8e 83       	std	Y+6, r24	; 0x06
    353c:	8e 81       	ldd	r24, Y+6	; 0x06
    353e:	9f 81       	ldd	r25, Y+7	; 0x07
    3540:	9b 83       	std	Y+3, r25	; 0x03
    3542:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    3544:	0f b6       	in	r0, 0x3f	; 63
    3546:	f8 94       	cli
    3548:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    354a:	ea 81       	ldd	r30, Y+2	; 0x02
    354c:	fb 81       	ldd	r31, Y+3	; 0x03
    354e:	85 a1       	ldd	r24, Z+37	; 0x25
    3550:	82 30       	cpi	r24, 0x02	; 2
    3552:	31 f4       	brne	.+12     	; 0x3560 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3554:	ea 81       	ldd	r30, Y+2	; 0x02
    3556:	fb 81       	ldd	r31, Y+3	; 0x03
    3558:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    355a:	81 e0       	ldi	r24, 0x01	; 1
    355c:	89 83       	std	Y+1, r24	; 0x01
    355e:	01 c0       	rjmp	.+2      	; 0x3562 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    3560:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    3562:	0f 90       	pop	r0
    3564:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3566:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3568:	27 96       	adiw	r28, 0x07	; 7
    356a:	0f b6       	in	r0, 0x3f	; 63
    356c:	f8 94       	cli
    356e:	de bf       	out	0x3e, r29	; 62
    3570:	0f be       	out	0x3f, r0	; 63
    3572:	cd bf       	out	0x3d, r28	; 61
    3574:	cf 91       	pop	r28
    3576:	df 91       	pop	r29
    3578:	08 95       	ret

0000357a <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    357a:	df 93       	push	r29
    357c:	cf 93       	push	r28
    357e:	cd b7       	in	r28, 0x3d	; 61
    3580:	de b7       	in	r29, 0x3e	; 62
    3582:	27 97       	sbiw	r28, 0x07	; 7
    3584:	0f b6       	in	r0, 0x3f	; 63
    3586:	f8 94       	cli
    3588:	de bf       	out	0x3e, r29	; 62
    358a:	0f be       	out	0x3f, r0	; 63
    358c:	cd bf       	out	0x3d, r28	; 61
    358e:	9e 83       	std	Y+6, r25	; 0x06
    3590:	8d 83       	std	Y+5, r24	; 0x05
    3592:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    3594:	80 91 de 02 	lds	r24, 0x02DE
    3598:	90 91 df 02 	lds	r25, 0x02DF
    359c:	9a 83       	std	Y+2, r25	; 0x02
    359e:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    35a0:	80 91 da 02 	lds	r24, 0x02DA
    35a4:	90 91 db 02 	lds	r25, 0x02DB
    35a8:	02 96       	adiw	r24, 0x02	; 2
    35aa:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    35ae:	29 81       	ldd	r18, Y+1	; 0x01
    35b0:	3a 81       	ldd	r19, Y+2	; 0x02
    35b2:	8d 81       	ldd	r24, Y+5	; 0x05
    35b4:	9e 81       	ldd	r25, Y+6	; 0x06
    35b6:	82 0f       	add	r24, r18
    35b8:	93 1f       	adc	r25, r19
    35ba:	9c 83       	std	Y+4, r25	; 0x04
    35bc:	8b 83       	std	Y+3, r24	; 0x03

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    35be:	e0 91 da 02 	lds	r30, 0x02DA
    35c2:	f0 91 db 02 	lds	r31, 0x02DB
    35c6:	8b 81       	ldd	r24, Y+3	; 0x03
    35c8:	9c 81       	ldd	r25, Y+4	; 0x04
    35ca:	93 83       	std	Z+3, r25	; 0x03
    35cc:	82 83       	std	Z+2, r24	; 0x02

		if( xTimeToWake < xConstTickCount )
    35ce:	2b 81       	ldd	r18, Y+3	; 0x03
    35d0:	3c 81       	ldd	r19, Y+4	; 0x04
    35d2:	89 81       	ldd	r24, Y+1	; 0x01
    35d4:	9a 81       	ldd	r25, Y+2	; 0x02
    35d6:	28 17       	cp	r18, r24
    35d8:	39 07       	cpc	r19, r25
    35da:	70 f4       	brcc	.+28     	; 0x35f8 <prvAddCurrentTaskToDelayedList+0x7e>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    35dc:	80 91 23 03 	lds	r24, 0x0323
    35e0:	90 91 24 03 	lds	r25, 0x0324
    35e4:	20 91 da 02 	lds	r18, 0x02DA
    35e8:	30 91 db 02 	lds	r19, 0x02DB
    35ec:	2e 5f       	subi	r18, 0xFE	; 254
    35ee:	3f 4f       	sbci	r19, 0xFF	; 255
    35f0:	b9 01       	movw	r22, r18
    35f2:	0e 94 8d 04 	call	0x91a	; 0x91a <vListInsert>
    35f6:	1e c0       	rjmp	.+60     	; 0x3634 <prvAddCurrentTaskToDelayedList+0xba>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    35f8:	40 91 21 03 	lds	r20, 0x0321
    35fc:	50 91 22 03 	lds	r21, 0x0322
    3600:	80 91 da 02 	lds	r24, 0x02DA
    3604:	90 91 db 02 	lds	r25, 0x02DB
    3608:	9c 01       	movw	r18, r24
    360a:	2e 5f       	subi	r18, 0xFE	; 254
    360c:	3f 4f       	sbci	r19, 0xFF	; 255
    360e:	ca 01       	movw	r24, r20
    3610:	b9 01       	movw	r22, r18
    3612:	0e 94 8d 04 	call	0x91a	; 0x91a <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    3616:	20 91 e6 02 	lds	r18, 0x02E6
    361a:	30 91 e7 02 	lds	r19, 0x02E7
    361e:	8b 81       	ldd	r24, Y+3	; 0x03
    3620:	9c 81       	ldd	r25, Y+4	; 0x04
    3622:	82 17       	cp	r24, r18
    3624:	93 07       	cpc	r25, r19
    3626:	30 f4       	brcc	.+12     	; 0x3634 <prvAddCurrentTaskToDelayedList+0xba>
			{
				xNextTaskUnblockTime = xTimeToWake;
    3628:	8b 81       	ldd	r24, Y+3	; 0x03
    362a:	9c 81       	ldd	r25, Y+4	; 0x04
    362c:	90 93 e7 02 	sts	0x02E7, r25
    3630:	80 93 e6 02 	sts	0x02E6, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3634:	27 96       	adiw	r28, 0x07	; 7
    3636:	0f b6       	in	r0, 0x3f	; 63
    3638:	f8 94       	cli
    363a:	de bf       	out	0x3e, r29	; 62
    363c:	0f be       	out	0x3f, r0	; 63
    363e:	cd bf       	out	0x3d, r28	; 61
    3640:	cf 91       	pop	r28
    3642:	df 91       	pop	r29
    3644:	08 95       	ret

00003646 <DIO_void_set_port_dir>:


/* Implementing of the driver functions */
/* Set direction of PORTx functions */
void DIO_void_set_port_dir(u8 copy_u8_port_id, u8 port_dir_copy)
{
    3646:	df 93       	push	r29
    3648:	cf 93       	push	r28
    364a:	00 d0       	rcall	.+0      	; 0x364c <DIO_void_set_port_dir+0x6>
    364c:	cd b7       	in	r28, 0x3d	; 61
    364e:	de b7       	in	r29, 0x3e	; 62
    3650:	89 83       	std	Y+1, r24	; 0x01
    3652:	6a 83       	std	Y+2, r22	; 0x02
	 *						1: for output pin
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT Direction Register DDRx
	 */
	*(DIO_DDRx_REF[copy_u8_port_id]) = port_dir_copy;
    3654:	89 81       	ldd	r24, Y+1	; 0x01
    3656:	88 2f       	mov	r24, r24
    3658:	90 e0       	ldi	r25, 0x00	; 0
    365a:	88 0f       	add	r24, r24
    365c:	99 1f       	adc	r25, r25
    365e:	fc 01       	movw	r30, r24
    3660:	e3 59       	subi	r30, 0x93	; 147
    3662:	ff 4f       	sbci	r31, 0xFF	; 255
    3664:	01 90       	ld	r0, Z+
    3666:	f0 81       	ld	r31, Z
    3668:	e0 2d       	mov	r30, r0
    366a:	8a 81       	ldd	r24, Y+2	; 0x02
    366c:	80 83       	st	Z, r24
}
    366e:	0f 90       	pop	r0
    3670:	0f 90       	pop	r0
    3672:	cf 91       	pop	r28
    3674:	df 91       	pop	r29
    3676:	08 95       	ret

00003678 <DIO_void_set_port_in_pullUp>:


void DIO_void_set_port_in_pullUp(u8 copy_u8_port_id)
{
    3678:	df 93       	push	r29
    367a:	cf 93       	push	r28
    367c:	0f 92       	push	r0
    367e:	cd b7       	in	r28, 0x3d	; 61
    3680:	de b7       	in	r29, 0x3e	; 62
    3682:	89 83       	std	Y+1, r24	; 0x01
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT Direction Register DDRx
	 */
	*(DIO_DDRx_REF[copy_u8_port_id]) = INPUT;
    3684:	89 81       	ldd	r24, Y+1	; 0x01
    3686:	88 2f       	mov	r24, r24
    3688:	90 e0       	ldi	r25, 0x00	; 0
    368a:	88 0f       	add	r24, r24
    368c:	99 1f       	adc	r25, r25
    368e:	fc 01       	movw	r30, r24
    3690:	e3 59       	subi	r30, 0x93	; 147
    3692:	ff 4f       	sbci	r31, 0xFF	; 255
    3694:	01 90       	ld	r0, Z+
    3696:	f0 81       	ld	r31, Z
    3698:	e0 2d       	mov	r30, r0
    369a:	10 82       	st	Z, r1
	*(DIO_PORTx_REF[copy_u8_port_id]) = PORT_MAX;
    369c:	89 81       	ldd	r24, Y+1	; 0x01
    369e:	88 2f       	mov	r24, r24
    36a0:	90 e0       	ldi	r25, 0x00	; 0
    36a2:	88 0f       	add	r24, r24
    36a4:	99 1f       	adc	r25, r25
    36a6:	fc 01       	movw	r30, r24
    36a8:	eb 58       	subi	r30, 0x8B	; 139
    36aa:	ff 4f       	sbci	r31, 0xFF	; 255
    36ac:	01 90       	ld	r0, Z+
    36ae:	f0 81       	ld	r31, Z
    36b0:	e0 2d       	mov	r30, r0
    36b2:	8f ef       	ldi	r24, 0xFF	; 255
    36b4:	80 83       	st	Z, r24
}
    36b6:	0f 90       	pop	r0
    36b8:	cf 91       	pop	r28
    36ba:	df 91       	pop	r29
    36bc:	08 95       	ret

000036be <DIO_void_set_pin_dir>:


/* Set direction of PINx functions */
void DIO_void_set_pin_dir(u8 copy_u8_port_id, u8 copy_u8_pin_num, u8 pin_dir_copy)
{
    36be:	df 93       	push	r29
    36c0:	cf 93       	push	r28
    36c2:	00 d0       	rcall	.+0      	; 0x36c4 <DIO_void_set_pin_dir+0x6>
    36c4:	0f 92       	push	r0
    36c6:	cd b7       	in	r28, 0x3d	; 61
    36c8:	de b7       	in	r29, 0x3e	; 62
    36ca:	89 83       	std	Y+1, r24	; 0x01
    36cc:	6a 83       	std	Y+2, r22	; 0x02
    36ce:	4b 83       	std	Y+3, r20	; 0x03
	 *				   1: for output pin
	 *
	 * Function does not return any output, yet it affects the 
	 * pin in the PORT Direction Register DDRx
	 */	
	agn_bit(*(DIO_DDRx_REF[copy_u8_port_id]), copy_u8_pin_num, pin_dir_copy);
    36d0:	8b 81       	ldd	r24, Y+3	; 0x03
    36d2:	88 23       	and	r24, r24
    36d4:	29 f1       	breq	.+74     	; 0x3720 <DIO_void_set_pin_dir+0x62>
    36d6:	89 81       	ldd	r24, Y+1	; 0x01
    36d8:	88 2f       	mov	r24, r24
    36da:	90 e0       	ldi	r25, 0x00	; 0
    36dc:	88 0f       	add	r24, r24
    36de:	99 1f       	adc	r25, r25
    36e0:	fc 01       	movw	r30, r24
    36e2:	e3 59       	subi	r30, 0x93	; 147
    36e4:	ff 4f       	sbci	r31, 0xFF	; 255
    36e6:	a0 81       	ld	r26, Z
    36e8:	b1 81       	ldd	r27, Z+1	; 0x01
    36ea:	89 81       	ldd	r24, Y+1	; 0x01
    36ec:	88 2f       	mov	r24, r24
    36ee:	90 e0       	ldi	r25, 0x00	; 0
    36f0:	88 0f       	add	r24, r24
    36f2:	99 1f       	adc	r25, r25
    36f4:	fc 01       	movw	r30, r24
    36f6:	e3 59       	subi	r30, 0x93	; 147
    36f8:	ff 4f       	sbci	r31, 0xFF	; 255
    36fa:	01 90       	ld	r0, Z+
    36fc:	f0 81       	ld	r31, Z
    36fe:	e0 2d       	mov	r30, r0
    3700:	80 81       	ld	r24, Z
    3702:	48 2f       	mov	r20, r24
    3704:	8a 81       	ldd	r24, Y+2	; 0x02
    3706:	28 2f       	mov	r18, r24
    3708:	30 e0       	ldi	r19, 0x00	; 0
    370a:	81 e0       	ldi	r24, 0x01	; 1
    370c:	90 e0       	ldi	r25, 0x00	; 0
    370e:	02 2e       	mov	r0, r18
    3710:	02 c0       	rjmp	.+4      	; 0x3716 <DIO_void_set_pin_dir+0x58>
    3712:	88 0f       	add	r24, r24
    3714:	99 1f       	adc	r25, r25
    3716:	0a 94       	dec	r0
    3718:	e2 f7       	brpl	.-8      	; 0x3712 <DIO_void_set_pin_dir+0x54>
    371a:	84 2b       	or	r24, r20
    371c:	8c 93       	st	X, r24
    371e:	25 c0       	rjmp	.+74     	; 0x376a <DIO_void_set_pin_dir+0xac>
    3720:	89 81       	ldd	r24, Y+1	; 0x01
    3722:	88 2f       	mov	r24, r24
    3724:	90 e0       	ldi	r25, 0x00	; 0
    3726:	88 0f       	add	r24, r24
    3728:	99 1f       	adc	r25, r25
    372a:	fc 01       	movw	r30, r24
    372c:	e3 59       	subi	r30, 0x93	; 147
    372e:	ff 4f       	sbci	r31, 0xFF	; 255
    3730:	a0 81       	ld	r26, Z
    3732:	b1 81       	ldd	r27, Z+1	; 0x01
    3734:	89 81       	ldd	r24, Y+1	; 0x01
    3736:	88 2f       	mov	r24, r24
    3738:	90 e0       	ldi	r25, 0x00	; 0
    373a:	88 0f       	add	r24, r24
    373c:	99 1f       	adc	r25, r25
    373e:	fc 01       	movw	r30, r24
    3740:	e3 59       	subi	r30, 0x93	; 147
    3742:	ff 4f       	sbci	r31, 0xFF	; 255
    3744:	01 90       	ld	r0, Z+
    3746:	f0 81       	ld	r31, Z
    3748:	e0 2d       	mov	r30, r0
    374a:	80 81       	ld	r24, Z
    374c:	48 2f       	mov	r20, r24
    374e:	8a 81       	ldd	r24, Y+2	; 0x02
    3750:	28 2f       	mov	r18, r24
    3752:	30 e0       	ldi	r19, 0x00	; 0
    3754:	81 e0       	ldi	r24, 0x01	; 1
    3756:	90 e0       	ldi	r25, 0x00	; 0
    3758:	02 2e       	mov	r0, r18
    375a:	02 c0       	rjmp	.+4      	; 0x3760 <DIO_void_set_pin_dir+0xa2>
    375c:	88 0f       	add	r24, r24
    375e:	99 1f       	adc	r25, r25
    3760:	0a 94       	dec	r0
    3762:	e2 f7       	brpl	.-8      	; 0x375c <DIO_void_set_pin_dir+0x9e>
    3764:	80 95       	com	r24
    3766:	84 23       	and	r24, r20
    3768:	8c 93       	st	X, r24
}
    376a:	0f 90       	pop	r0
    376c:	0f 90       	pop	r0
    376e:	0f 90       	pop	r0
    3770:	cf 91       	pop	r28
    3772:	df 91       	pop	r29
    3774:	08 95       	ret

00003776 <DIO_void_set_pin_in_pullUP>:


void DIO_void_set_pin_in_pullUP(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    3776:	df 93       	push	r29
    3778:	cf 93       	push	r28
    377a:	00 d0       	rcall	.+0      	; 0x377c <DIO_void_set_pin_in_pullUP+0x6>
    377c:	cd b7       	in	r28, 0x3d	; 61
    377e:	de b7       	in	r29, 0x3e	; 62
    3780:	89 83       	std	Y+1, r24	; 0x01
    3782:	6a 83       	std	Y+2, r22	; 0x02
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	pin in the PORT Direction Register DDRx					  
	 */
	clr_bit(*(DIO_DDRx_REF[copy_u8_port_id]), copy_u8_pin_num);
    3784:	89 81       	ldd	r24, Y+1	; 0x01
    3786:	88 2f       	mov	r24, r24
    3788:	90 e0       	ldi	r25, 0x00	; 0
    378a:	88 0f       	add	r24, r24
    378c:	99 1f       	adc	r25, r25
    378e:	fc 01       	movw	r30, r24
    3790:	e3 59       	subi	r30, 0x93	; 147
    3792:	ff 4f       	sbci	r31, 0xFF	; 255
    3794:	a0 81       	ld	r26, Z
    3796:	b1 81       	ldd	r27, Z+1	; 0x01
    3798:	89 81       	ldd	r24, Y+1	; 0x01
    379a:	88 2f       	mov	r24, r24
    379c:	90 e0       	ldi	r25, 0x00	; 0
    379e:	88 0f       	add	r24, r24
    37a0:	99 1f       	adc	r25, r25
    37a2:	fc 01       	movw	r30, r24
    37a4:	e3 59       	subi	r30, 0x93	; 147
    37a6:	ff 4f       	sbci	r31, 0xFF	; 255
    37a8:	01 90       	ld	r0, Z+
    37aa:	f0 81       	ld	r31, Z
    37ac:	e0 2d       	mov	r30, r0
    37ae:	80 81       	ld	r24, Z
    37b0:	48 2f       	mov	r20, r24
    37b2:	8a 81       	ldd	r24, Y+2	; 0x02
    37b4:	28 2f       	mov	r18, r24
    37b6:	30 e0       	ldi	r19, 0x00	; 0
    37b8:	81 e0       	ldi	r24, 0x01	; 1
    37ba:	90 e0       	ldi	r25, 0x00	; 0
    37bc:	02 c0       	rjmp	.+4      	; 0x37c2 <DIO_void_set_pin_in_pullUP+0x4c>
    37be:	88 0f       	add	r24, r24
    37c0:	99 1f       	adc	r25, r25
    37c2:	2a 95       	dec	r18
    37c4:	e2 f7       	brpl	.-8      	; 0x37be <DIO_void_set_pin_in_pullUP+0x48>
    37c6:	80 95       	com	r24
    37c8:	84 23       	and	r24, r20
    37ca:	8c 93       	st	X, r24
	set_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    37cc:	89 81       	ldd	r24, Y+1	; 0x01
    37ce:	88 2f       	mov	r24, r24
    37d0:	90 e0       	ldi	r25, 0x00	; 0
    37d2:	88 0f       	add	r24, r24
    37d4:	99 1f       	adc	r25, r25
    37d6:	fc 01       	movw	r30, r24
    37d8:	eb 58       	subi	r30, 0x8B	; 139
    37da:	ff 4f       	sbci	r31, 0xFF	; 255
    37dc:	a0 81       	ld	r26, Z
    37de:	b1 81       	ldd	r27, Z+1	; 0x01
    37e0:	89 81       	ldd	r24, Y+1	; 0x01
    37e2:	88 2f       	mov	r24, r24
    37e4:	90 e0       	ldi	r25, 0x00	; 0
    37e6:	88 0f       	add	r24, r24
    37e8:	99 1f       	adc	r25, r25
    37ea:	fc 01       	movw	r30, r24
    37ec:	eb 58       	subi	r30, 0x8B	; 139
    37ee:	ff 4f       	sbci	r31, 0xFF	; 255
    37f0:	01 90       	ld	r0, Z+
    37f2:	f0 81       	ld	r31, Z
    37f4:	e0 2d       	mov	r30, r0
    37f6:	80 81       	ld	r24, Z
    37f8:	48 2f       	mov	r20, r24
    37fa:	8a 81       	ldd	r24, Y+2	; 0x02
    37fc:	28 2f       	mov	r18, r24
    37fe:	30 e0       	ldi	r19, 0x00	; 0
    3800:	81 e0       	ldi	r24, 0x01	; 1
    3802:	90 e0       	ldi	r25, 0x00	; 0
    3804:	02 2e       	mov	r0, r18
    3806:	02 c0       	rjmp	.+4      	; 0x380c <DIO_void_set_pin_in_pullUP+0x96>
    3808:	88 0f       	add	r24, r24
    380a:	99 1f       	adc	r25, r25
    380c:	0a 94       	dec	r0
    380e:	e2 f7       	brpl	.-8      	; 0x3808 <DIO_void_set_pin_in_pullUP+0x92>
    3810:	84 2b       	or	r24, r20
    3812:	8c 93       	st	X, r24
}
    3814:	0f 90       	pop	r0
    3816:	0f 90       	pop	r0
    3818:	cf 91       	pop	r28
    381a:	df 91       	pop	r29
    381c:	08 95       	ret

0000381e <DIO_void_set_port>:


/* Assign Value to output PORTx functions */
void DIO_void_set_port(u8 copy_u8_port_id)
{
    381e:	df 93       	push	r29
    3820:	cf 93       	push	r28
    3822:	0f 92       	push	r0
    3824:	cd b7       	in	r28, 0x3d	; 61
    3826:	de b7       	in	r29, 0x3e	; 62
    3828:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = PORT_MAX;
    382a:	89 81       	ldd	r24, Y+1	; 0x01
    382c:	88 2f       	mov	r24, r24
    382e:	90 e0       	ldi	r25, 0x00	; 0
    3830:	88 0f       	add	r24, r24
    3832:	99 1f       	adc	r25, r25
    3834:	fc 01       	movw	r30, r24
    3836:	eb 58       	subi	r30, 0x8B	; 139
    3838:	ff 4f       	sbci	r31, 0xFF	; 255
    383a:	01 90       	ld	r0, Z+
    383c:	f0 81       	ld	r31, Z
    383e:	e0 2d       	mov	r30, r0
    3840:	8f ef       	ldi	r24, 0xFF	; 255
    3842:	80 83       	st	Z, r24
}
    3844:	0f 90       	pop	r0
    3846:	cf 91       	pop	r28
    3848:	df 91       	pop	r29
    384a:	08 95       	ret

0000384c <DIO_void_clear_port>:


void DIO_void_clear_port(u8 copy_u8_port_id)
{
    384c:	df 93       	push	r29
    384e:	cf 93       	push	r28
    3850:	0f 92       	push	r0
    3852:	cd b7       	in	r28, 0x3d	; 61
    3854:	de b7       	in	r29, 0x3e	; 62
    3856:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = LOW;
    3858:	89 81       	ldd	r24, Y+1	; 0x01
    385a:	88 2f       	mov	r24, r24
    385c:	90 e0       	ldi	r25, 0x00	; 0
    385e:	88 0f       	add	r24, r24
    3860:	99 1f       	adc	r25, r25
    3862:	fc 01       	movw	r30, r24
    3864:	eb 58       	subi	r30, 0x8B	; 139
    3866:	ff 4f       	sbci	r31, 0xFF	; 255
    3868:	01 90       	ld	r0, Z+
    386a:	f0 81       	ld	r31, Z
    386c:	e0 2d       	mov	r30, r0
    386e:	10 82       	st	Z, r1
}
    3870:	0f 90       	pop	r0
    3872:	cf 91       	pop	r28
    3874:	df 91       	pop	r29
    3876:	08 95       	ret

00003878 <DIO_void_toggle_port>:


void DIO_void_toggle_port(u8 copy_u8_port_id)
{
    3878:	df 93       	push	r29
    387a:	cf 93       	push	r28
    387c:	0f 92       	push	r0
    387e:	cd b7       	in	r28, 0x3d	; 61
    3880:	de b7       	in	r29, 0x3e	; 62
    3882:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) ^= PORT_MAX;
    3884:	89 81       	ldd	r24, Y+1	; 0x01
    3886:	88 2f       	mov	r24, r24
    3888:	90 e0       	ldi	r25, 0x00	; 0
    388a:	88 0f       	add	r24, r24
    388c:	99 1f       	adc	r25, r25
    388e:	fc 01       	movw	r30, r24
    3890:	eb 58       	subi	r30, 0x8B	; 139
    3892:	ff 4f       	sbci	r31, 0xFF	; 255
    3894:	a0 81       	ld	r26, Z
    3896:	b1 81       	ldd	r27, Z+1	; 0x01
    3898:	89 81       	ldd	r24, Y+1	; 0x01
    389a:	88 2f       	mov	r24, r24
    389c:	90 e0       	ldi	r25, 0x00	; 0
    389e:	88 0f       	add	r24, r24
    38a0:	99 1f       	adc	r25, r25
    38a2:	fc 01       	movw	r30, r24
    38a4:	eb 58       	subi	r30, 0x8B	; 139
    38a6:	ff 4f       	sbci	r31, 0xFF	; 255
    38a8:	01 90       	ld	r0, Z+
    38aa:	f0 81       	ld	r31, Z
    38ac:	e0 2d       	mov	r30, r0
    38ae:	80 81       	ld	r24, Z
    38b0:	80 95       	com	r24
    38b2:	8c 93       	st	X, r24
}
    38b4:	0f 90       	pop	r0
    38b6:	cf 91       	pop	r28
    38b8:	df 91       	pop	r29
    38ba:	08 95       	ret

000038bc <DIO_void_assign_port>:


void DIO_void_assign_port(u8 copy_u8_port_id, u8 port_val)
{
    38bc:	df 93       	push	r29
    38be:	cf 93       	push	r28
    38c0:	00 d0       	rcall	.+0      	; 0x38c2 <DIO_void_assign_port+0x6>
    38c2:	cd b7       	in	r28, 0x3d	; 61
    38c4:	de b7       	in	r29, 0x3e	; 62
    38c6:	89 83       	std	Y+1, r24	; 0x01
    38c8:	6a 83       	std	Y+2, r22	; 0x02
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = port_val;
    38ca:	89 81       	ldd	r24, Y+1	; 0x01
    38cc:	88 2f       	mov	r24, r24
    38ce:	90 e0       	ldi	r25, 0x00	; 0
    38d0:	88 0f       	add	r24, r24
    38d2:	99 1f       	adc	r25, r25
    38d4:	fc 01       	movw	r30, r24
    38d6:	eb 58       	subi	r30, 0x8B	; 139
    38d8:	ff 4f       	sbci	r31, 0xFF	; 255
    38da:	01 90       	ld	r0, Z+
    38dc:	f0 81       	ld	r31, Z
    38de:	e0 2d       	mov	r30, r0
    38e0:	8a 81       	ldd	r24, Y+2	; 0x02
    38e2:	80 83       	st	Z, r24
}
    38e4:	0f 90       	pop	r0
    38e6:	0f 90       	pop	r0
    38e8:	cf 91       	pop	r28
    38ea:	df 91       	pop	r29
    38ec:	08 95       	ret

000038ee <DIO_void_set_pin>:


/* Assign Value to output PINx functions */
void DIO_void_set_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    38ee:	df 93       	push	r29
    38f0:	cf 93       	push	r28
    38f2:	00 d0       	rcall	.+0      	; 0x38f4 <DIO_void_set_pin+0x6>
    38f4:	cd b7       	in	r28, 0x3d	; 61
    38f6:	de b7       	in	r29, 0x3e	; 62
    38f8:	89 83       	std	Y+1, r24	; 0x01
    38fa:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	set_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    38fc:	89 81       	ldd	r24, Y+1	; 0x01
    38fe:	88 2f       	mov	r24, r24
    3900:	90 e0       	ldi	r25, 0x00	; 0
    3902:	88 0f       	add	r24, r24
    3904:	99 1f       	adc	r25, r25
    3906:	fc 01       	movw	r30, r24
    3908:	eb 58       	subi	r30, 0x8B	; 139
    390a:	ff 4f       	sbci	r31, 0xFF	; 255
    390c:	a0 81       	ld	r26, Z
    390e:	b1 81       	ldd	r27, Z+1	; 0x01
    3910:	89 81       	ldd	r24, Y+1	; 0x01
    3912:	88 2f       	mov	r24, r24
    3914:	90 e0       	ldi	r25, 0x00	; 0
    3916:	88 0f       	add	r24, r24
    3918:	99 1f       	adc	r25, r25
    391a:	fc 01       	movw	r30, r24
    391c:	eb 58       	subi	r30, 0x8B	; 139
    391e:	ff 4f       	sbci	r31, 0xFF	; 255
    3920:	01 90       	ld	r0, Z+
    3922:	f0 81       	ld	r31, Z
    3924:	e0 2d       	mov	r30, r0
    3926:	80 81       	ld	r24, Z
    3928:	48 2f       	mov	r20, r24
    392a:	8a 81       	ldd	r24, Y+2	; 0x02
    392c:	28 2f       	mov	r18, r24
    392e:	30 e0       	ldi	r19, 0x00	; 0
    3930:	81 e0       	ldi	r24, 0x01	; 1
    3932:	90 e0       	ldi	r25, 0x00	; 0
    3934:	02 2e       	mov	r0, r18
    3936:	02 c0       	rjmp	.+4      	; 0x393c <DIO_void_set_pin+0x4e>
    3938:	88 0f       	add	r24, r24
    393a:	99 1f       	adc	r25, r25
    393c:	0a 94       	dec	r0
    393e:	e2 f7       	brpl	.-8      	; 0x3938 <DIO_void_set_pin+0x4a>
    3940:	84 2b       	or	r24, r20
    3942:	8c 93       	st	X, r24
}
    3944:	0f 90       	pop	r0
    3946:	0f 90       	pop	r0
    3948:	cf 91       	pop	r28
    394a:	df 91       	pop	r29
    394c:	08 95       	ret

0000394e <DIO_void_clear_pin>:


void DIO_void_clear_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    394e:	df 93       	push	r29
    3950:	cf 93       	push	r28
    3952:	00 d0       	rcall	.+0      	; 0x3954 <DIO_void_clear_pin+0x6>
    3954:	cd b7       	in	r28, 0x3d	; 61
    3956:	de b7       	in	r29, 0x3e	; 62
    3958:	89 83       	std	Y+1, r24	; 0x01
    395a:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	clr_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    395c:	89 81       	ldd	r24, Y+1	; 0x01
    395e:	88 2f       	mov	r24, r24
    3960:	90 e0       	ldi	r25, 0x00	; 0
    3962:	88 0f       	add	r24, r24
    3964:	99 1f       	adc	r25, r25
    3966:	fc 01       	movw	r30, r24
    3968:	eb 58       	subi	r30, 0x8B	; 139
    396a:	ff 4f       	sbci	r31, 0xFF	; 255
    396c:	a0 81       	ld	r26, Z
    396e:	b1 81       	ldd	r27, Z+1	; 0x01
    3970:	89 81       	ldd	r24, Y+1	; 0x01
    3972:	88 2f       	mov	r24, r24
    3974:	90 e0       	ldi	r25, 0x00	; 0
    3976:	88 0f       	add	r24, r24
    3978:	99 1f       	adc	r25, r25
    397a:	fc 01       	movw	r30, r24
    397c:	eb 58       	subi	r30, 0x8B	; 139
    397e:	ff 4f       	sbci	r31, 0xFF	; 255
    3980:	01 90       	ld	r0, Z+
    3982:	f0 81       	ld	r31, Z
    3984:	e0 2d       	mov	r30, r0
    3986:	80 81       	ld	r24, Z
    3988:	48 2f       	mov	r20, r24
    398a:	8a 81       	ldd	r24, Y+2	; 0x02
    398c:	28 2f       	mov	r18, r24
    398e:	30 e0       	ldi	r19, 0x00	; 0
    3990:	81 e0       	ldi	r24, 0x01	; 1
    3992:	90 e0       	ldi	r25, 0x00	; 0
    3994:	02 2e       	mov	r0, r18
    3996:	02 c0       	rjmp	.+4      	; 0x399c <DIO_void_clear_pin+0x4e>
    3998:	88 0f       	add	r24, r24
    399a:	99 1f       	adc	r25, r25
    399c:	0a 94       	dec	r0
    399e:	e2 f7       	brpl	.-8      	; 0x3998 <DIO_void_clear_pin+0x4a>
    39a0:	80 95       	com	r24
    39a2:	84 23       	and	r24, r20
    39a4:	8c 93       	st	X, r24
}
    39a6:	0f 90       	pop	r0
    39a8:	0f 90       	pop	r0
    39aa:	cf 91       	pop	r28
    39ac:	df 91       	pop	r29
    39ae:	08 95       	ret

000039b0 <DIO_void_toggle_pin>:


void DIO_void_toggle_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    39b0:	df 93       	push	r29
    39b2:	cf 93       	push	r28
    39b4:	00 d0       	rcall	.+0      	; 0x39b6 <DIO_void_toggle_pin+0x6>
    39b6:	cd b7       	in	r28, 0x3d	; 61
    39b8:	de b7       	in	r29, 0x3e	; 62
    39ba:	89 83       	std	Y+1, r24	; 0x01
    39bc:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	tgl_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    39be:	89 81       	ldd	r24, Y+1	; 0x01
    39c0:	88 2f       	mov	r24, r24
    39c2:	90 e0       	ldi	r25, 0x00	; 0
    39c4:	88 0f       	add	r24, r24
    39c6:	99 1f       	adc	r25, r25
    39c8:	fc 01       	movw	r30, r24
    39ca:	eb 58       	subi	r30, 0x8B	; 139
    39cc:	ff 4f       	sbci	r31, 0xFF	; 255
    39ce:	a0 81       	ld	r26, Z
    39d0:	b1 81       	ldd	r27, Z+1	; 0x01
    39d2:	89 81       	ldd	r24, Y+1	; 0x01
    39d4:	88 2f       	mov	r24, r24
    39d6:	90 e0       	ldi	r25, 0x00	; 0
    39d8:	88 0f       	add	r24, r24
    39da:	99 1f       	adc	r25, r25
    39dc:	fc 01       	movw	r30, r24
    39de:	eb 58       	subi	r30, 0x8B	; 139
    39e0:	ff 4f       	sbci	r31, 0xFF	; 255
    39e2:	01 90       	ld	r0, Z+
    39e4:	f0 81       	ld	r31, Z
    39e6:	e0 2d       	mov	r30, r0
    39e8:	80 81       	ld	r24, Z
    39ea:	48 2f       	mov	r20, r24
    39ec:	8a 81       	ldd	r24, Y+2	; 0x02
    39ee:	28 2f       	mov	r18, r24
    39f0:	30 e0       	ldi	r19, 0x00	; 0
    39f2:	81 e0       	ldi	r24, 0x01	; 1
    39f4:	90 e0       	ldi	r25, 0x00	; 0
    39f6:	02 2e       	mov	r0, r18
    39f8:	02 c0       	rjmp	.+4      	; 0x39fe <DIO_void_toggle_pin+0x4e>
    39fa:	88 0f       	add	r24, r24
    39fc:	99 1f       	adc	r25, r25
    39fe:	0a 94       	dec	r0
    3a00:	e2 f7       	brpl	.-8      	; 0x39fa <DIO_void_toggle_pin+0x4a>
    3a02:	84 27       	eor	r24, r20
    3a04:	8c 93       	st	X, r24
}
    3a06:	0f 90       	pop	r0
    3a08:	0f 90       	pop	r0
    3a0a:	cf 91       	pop	r28
    3a0c:	df 91       	pop	r29
    3a0e:	08 95       	ret

00003a10 <DIO_void_assign_pin>:


void DIO_void_assign_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num, u8 pin_val)
{
    3a10:	df 93       	push	r29
    3a12:	cf 93       	push	r28
    3a14:	00 d0       	rcall	.+0      	; 0x3a16 <DIO_void_assign_pin+0x6>
    3a16:	0f 92       	push	r0
    3a18:	cd b7       	in	r28, 0x3d	; 61
    3a1a:	de b7       	in	r29, 0x3e	; 62
    3a1c:	89 83       	std	Y+1, r24	; 0x01
    3a1e:	6a 83       	std	Y+2, r22	; 0x02
    3a20:	4b 83       	std	Y+3, r20	; 0x03
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	agn_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num, pin_val);
    3a22:	8b 81       	ldd	r24, Y+3	; 0x03
    3a24:	88 23       	and	r24, r24
    3a26:	29 f1       	breq	.+74     	; 0x3a72 <DIO_void_assign_pin+0x62>
    3a28:	89 81       	ldd	r24, Y+1	; 0x01
    3a2a:	88 2f       	mov	r24, r24
    3a2c:	90 e0       	ldi	r25, 0x00	; 0
    3a2e:	88 0f       	add	r24, r24
    3a30:	99 1f       	adc	r25, r25
    3a32:	fc 01       	movw	r30, r24
    3a34:	eb 58       	subi	r30, 0x8B	; 139
    3a36:	ff 4f       	sbci	r31, 0xFF	; 255
    3a38:	a0 81       	ld	r26, Z
    3a3a:	b1 81       	ldd	r27, Z+1	; 0x01
    3a3c:	89 81       	ldd	r24, Y+1	; 0x01
    3a3e:	88 2f       	mov	r24, r24
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	88 0f       	add	r24, r24
    3a44:	99 1f       	adc	r25, r25
    3a46:	fc 01       	movw	r30, r24
    3a48:	eb 58       	subi	r30, 0x8B	; 139
    3a4a:	ff 4f       	sbci	r31, 0xFF	; 255
    3a4c:	01 90       	ld	r0, Z+
    3a4e:	f0 81       	ld	r31, Z
    3a50:	e0 2d       	mov	r30, r0
    3a52:	80 81       	ld	r24, Z
    3a54:	48 2f       	mov	r20, r24
    3a56:	8a 81       	ldd	r24, Y+2	; 0x02
    3a58:	28 2f       	mov	r18, r24
    3a5a:	30 e0       	ldi	r19, 0x00	; 0
    3a5c:	81 e0       	ldi	r24, 0x01	; 1
    3a5e:	90 e0       	ldi	r25, 0x00	; 0
    3a60:	02 2e       	mov	r0, r18
    3a62:	02 c0       	rjmp	.+4      	; 0x3a68 <DIO_void_assign_pin+0x58>
    3a64:	88 0f       	add	r24, r24
    3a66:	99 1f       	adc	r25, r25
    3a68:	0a 94       	dec	r0
    3a6a:	e2 f7       	brpl	.-8      	; 0x3a64 <DIO_void_assign_pin+0x54>
    3a6c:	84 2b       	or	r24, r20
    3a6e:	8c 93       	st	X, r24
    3a70:	25 c0       	rjmp	.+74     	; 0x3abc <DIO_void_assign_pin+0xac>
    3a72:	89 81       	ldd	r24, Y+1	; 0x01
    3a74:	88 2f       	mov	r24, r24
    3a76:	90 e0       	ldi	r25, 0x00	; 0
    3a78:	88 0f       	add	r24, r24
    3a7a:	99 1f       	adc	r25, r25
    3a7c:	fc 01       	movw	r30, r24
    3a7e:	eb 58       	subi	r30, 0x8B	; 139
    3a80:	ff 4f       	sbci	r31, 0xFF	; 255
    3a82:	a0 81       	ld	r26, Z
    3a84:	b1 81       	ldd	r27, Z+1	; 0x01
    3a86:	89 81       	ldd	r24, Y+1	; 0x01
    3a88:	88 2f       	mov	r24, r24
    3a8a:	90 e0       	ldi	r25, 0x00	; 0
    3a8c:	88 0f       	add	r24, r24
    3a8e:	99 1f       	adc	r25, r25
    3a90:	fc 01       	movw	r30, r24
    3a92:	eb 58       	subi	r30, 0x8B	; 139
    3a94:	ff 4f       	sbci	r31, 0xFF	; 255
    3a96:	01 90       	ld	r0, Z+
    3a98:	f0 81       	ld	r31, Z
    3a9a:	e0 2d       	mov	r30, r0
    3a9c:	80 81       	ld	r24, Z
    3a9e:	48 2f       	mov	r20, r24
    3aa0:	8a 81       	ldd	r24, Y+2	; 0x02
    3aa2:	28 2f       	mov	r18, r24
    3aa4:	30 e0       	ldi	r19, 0x00	; 0
    3aa6:	81 e0       	ldi	r24, 0x01	; 1
    3aa8:	90 e0       	ldi	r25, 0x00	; 0
    3aaa:	02 2e       	mov	r0, r18
    3aac:	02 c0       	rjmp	.+4      	; 0x3ab2 <DIO_void_assign_pin+0xa2>
    3aae:	88 0f       	add	r24, r24
    3ab0:	99 1f       	adc	r25, r25
    3ab2:	0a 94       	dec	r0
    3ab4:	e2 f7       	brpl	.-8      	; 0x3aae <DIO_void_assign_pin+0x9e>
    3ab6:	80 95       	com	r24
    3ab8:	84 23       	and	r24, r20
    3aba:	8c 93       	st	X, r24
}
    3abc:	0f 90       	pop	r0
    3abe:	0f 90       	pop	r0
    3ac0:	0f 90       	pop	r0
    3ac2:	cf 91       	pop	r28
    3ac4:	df 91       	pop	r29
    3ac6:	08 95       	ret

00003ac8 <DIO_u8_get_port>:


/* Get value from input PORTx functions */
u8 DIO_u8_get_port(u8 copy_u8_port_id)
{
    3ac8:	df 93       	push	r29
    3aca:	cf 93       	push	r28
    3acc:	0f 92       	push	r0
    3ace:	cd b7       	in	r28, 0x3d	; 61
    3ad0:	de b7       	in	r29, 0x3e	; 62
    3ad2:	89 83       	std	Y+1, r24	; 0x01
	 *	
	 *	Function does not affect any regester it only gets
	 *	from the value in the input regester PINx of the 
	 *	given port                                                 
	 */
	return *(DIO_PINx_REF[copy_u8_port_id]);
    3ad4:	89 81       	ldd	r24, Y+1	; 0x01
    3ad6:	88 2f       	mov	r24, r24
    3ad8:	90 e0       	ldi	r25, 0x00	; 0
    3ada:	88 0f       	add	r24, r24
    3adc:	99 1f       	adc	r25, r25
    3ade:	fc 01       	movw	r30, r24
    3ae0:	eb 59       	subi	r30, 0x9B	; 155
    3ae2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ae4:	01 90       	ld	r0, Z+
    3ae6:	f0 81       	ld	r31, Z
    3ae8:	e0 2d       	mov	r30, r0
    3aea:	80 81       	ld	r24, Z
}
    3aec:	0f 90       	pop	r0
    3aee:	cf 91       	pop	r28
    3af0:	df 91       	pop	r29
    3af2:	08 95       	ret

00003af4 <DIO_u8_get_pin>:


/* Get value from input PINx functions */
u8 DIO_u8_get_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    3af4:	df 93       	push	r29
    3af6:	cf 93       	push	r28
    3af8:	00 d0       	rcall	.+0      	; 0x3afa <DIO_u8_get_pin+0x6>
    3afa:	cd b7       	in	r28, 0x3d	; 61
    3afc:	de b7       	in	r29, 0x3e	; 62
    3afe:	89 83       	std	Y+1, r24	; 0x01
    3b00:	6a 83       	std	Y+2, r22	; 0x02
	 *	
	 *	Function does not affect any regester it only gets the pin
	 *	value from the value in the input regester PINx of the 
	 *	given port                                                 
	 */
	return get_bit(*(DIO_PINx_REF[copy_u8_port_id]), copy_u8_pin_num);
    3b02:	89 81       	ldd	r24, Y+1	; 0x01
    3b04:	88 2f       	mov	r24, r24
    3b06:	90 e0       	ldi	r25, 0x00	; 0
    3b08:	88 0f       	add	r24, r24
    3b0a:	99 1f       	adc	r25, r25
    3b0c:	fc 01       	movw	r30, r24
    3b0e:	eb 59       	subi	r30, 0x9B	; 155
    3b10:	ff 4f       	sbci	r31, 0xFF	; 255
    3b12:	01 90       	ld	r0, Z+
    3b14:	f0 81       	ld	r31, Z
    3b16:	e0 2d       	mov	r30, r0
    3b18:	80 81       	ld	r24, Z
    3b1a:	28 2f       	mov	r18, r24
    3b1c:	30 e0       	ldi	r19, 0x00	; 0
    3b1e:	8a 81       	ldd	r24, Y+2	; 0x02
    3b20:	88 2f       	mov	r24, r24
    3b22:	90 e0       	ldi	r25, 0x00	; 0
    3b24:	a9 01       	movw	r20, r18
    3b26:	02 c0       	rjmp	.+4      	; 0x3b2c <DIO_u8_get_pin+0x38>
    3b28:	55 95       	asr	r21
    3b2a:	47 95       	ror	r20
    3b2c:	8a 95       	dec	r24
    3b2e:	e2 f7       	brpl	.-8      	; 0x3b28 <DIO_u8_get_pin+0x34>
    3b30:	ca 01       	movw	r24, r20
    3b32:	81 70       	andi	r24, 0x01	; 1
}
    3b34:	0f 90       	pop	r0
    3b36:	0f 90       	pop	r0
    3b38:	cf 91       	pop	r28
    3b3a:	df 91       	pop	r29
    3b3c:	08 95       	ret

00003b3e <memcpy>:
    3b3e:	fb 01       	movw	r30, r22
    3b40:	dc 01       	movw	r26, r24
    3b42:	02 c0       	rjmp	.+4      	; 0x3b48 <memcpy+0xa>
    3b44:	01 90       	ld	r0, Z+
    3b46:	0d 92       	st	X+, r0
    3b48:	41 50       	subi	r20, 0x01	; 1
    3b4a:	50 40       	sbci	r21, 0x00	; 0
    3b4c:	d8 f7       	brcc	.-10     	; 0x3b44 <memcpy+0x6>
    3b4e:	08 95       	ret

00003b50 <_exit>:
    3b50:	f8 94       	cli

00003b52 <__stop_program>:
    3b52:	ff cf       	rjmp	.-2      	; 0x3b52 <__stop_program>
