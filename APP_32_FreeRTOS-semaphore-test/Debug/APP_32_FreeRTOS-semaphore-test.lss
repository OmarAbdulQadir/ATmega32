
APP_32_FreeRTOS-semaphore-test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003c66  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000028  00800060  00003c66  00003cfa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002bb  00800088  00800088  00003d22  2**0
                  ALLOC
  3 .stab         00006b88  00000000  00000000  00003d24  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00005302  00000000  00000000  0000a8ac  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9f 08 	jmp	0x113e	; 0x113e <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e6       	ldi	r30, 0x66	; 102
      68:	fc e3       	ldi	r31, 0x3C	; 60
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 38       	cpi	r26, 0x88	; 136
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 e8       	ldi	r26, 0x88	; 136
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 34       	cpi	r26, 0x43	; 67
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 31 1e 	jmp	0x3c62	; 0x3c62 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	df 93       	push	r29
      9a:	cf 93       	push	r28
      9c:	cd b7       	in	r28, 0x3d	; 61
      9e:	de b7       	in	r29, 0x3e	; 62
      a0:	81 e0       	ldi	r24, 0x01	; 1
      a2:	60 e0       	ldi	r22, 0x00	; 0
      a4:	43 e0       	ldi	r20, 0x03	; 3
      a6:	0e 94 28 09 	call	0x1250	; 0x1250 <xQueueGenericCreate>
      aa:	90 93 42 03 	sts	0x0342, r25
      ae:	80 93 41 03 	sts	0x0341, r24
      b2:	80 91 41 03 	lds	r24, 0x0341
      b6:	90 91 42 03 	lds	r25, 0x0342
      ba:	00 97       	sbiw	r24, 0x00	; 0
      bc:	59 f0       	breq	.+22     	; 0xd4 <main+0x42>
      be:	80 91 41 03 	lds	r24, 0x0341
      c2:	90 91 42 03 	lds	r25, 0x0342
      c6:	60 e0       	ldi	r22, 0x00	; 0
      c8:	70 e0       	ldi	r23, 0x00	; 0
      ca:	40 e0       	ldi	r20, 0x00	; 0
      cc:	50 e0       	ldi	r21, 0x00	; 0
      ce:	20 e0       	ldi	r18, 0x00	; 0
      d0:	0e 94 b4 09 	call	0x1368	; 0x1368 <xQueueGenericSend>
      d4:	89 e8       	ldi	r24, 0x89	; 137
      d6:	90 e0       	ldi	r25, 0x00	; 0
      d8:	20 e6       	ldi	r18, 0x60	; 96
      da:	30 e0       	ldi	r19, 0x00	; 0
      dc:	b9 01       	movw	r22, r18
      de:	45 e5       	ldi	r20, 0x55	; 85
      e0:	50 e0       	ldi	r21, 0x00	; 0
      e2:	20 e0       	ldi	r18, 0x00	; 0
      e4:	30 e0       	ldi	r19, 0x00	; 0
      e6:	02 e0       	ldi	r16, 0x02	; 2
      e8:	ee 24       	eor	r14, r14
      ea:	ff 24       	eor	r15, r15
      ec:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <xTaskCreate>
      f0:	88 eb       	ldi	r24, 0xB8	; 184
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	27 e6       	ldi	r18, 0x67	; 103
      f6:	30 e0       	ldi	r19, 0x00	; 0
      f8:	b9 01       	movw	r22, r18
      fa:	45 e5       	ldi	r20, 0x55	; 85
      fc:	50 e0       	ldi	r21, 0x00	; 0
      fe:	20 e0       	ldi	r18, 0x00	; 0
     100:	30 e0       	ldi	r19, 0x00	; 0
     102:	01 e0       	ldi	r16, 0x01	; 1
     104:	ee 24       	eor	r14, r14
     106:	ff 24       	eor	r15, r15
     108:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <xTaskCreate>
     10c:	0e 94 76 12 	call	0x24ec	; 0x24ec <vTaskStartScheduler>
     110:	ff cf       	rjmp	.-2      	; 0x110 <main+0x7e>

00000112 <task_1>:
	}
	return 0;
}

// Functions implementation
void task_1(void * pvParameners){
     112:	df 93       	push	r29
     114:	cf 93       	push	r28
     116:	00 d0       	rcall	.+0      	; 0x118 <task_1+0x6>
     118:	cd b7       	in	r28, 0x3d	; 61
     11a:	de b7       	in	r29, 0x3e	; 62
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
	/*
	 *
	 */
	DIO_void_set_pin_in_pullUP(DIO_REF_PORTC, B0);
     120:	82 e0       	ldi	r24, 0x02	; 2
     122:	60 e0       	ldi	r22, 0x00	; 0
     124:	0e 94 44 1c 	call	0x3888	; 0x3888 <DIO_void_set_pin_in_pullUP>
	xSemaphoreTake(x_sem, 10);
     128:	80 91 41 03 	lds	r24, 0x0341
     12c:	90 91 42 03 	lds	r25, 0x0342
     130:	6a e0       	ldi	r22, 0x0A	; 10
     132:	70 e0       	ldi	r23, 0x00	; 0
     134:	0e 94 b4 0b 	call	0x1768	; 0x1768 <xQueueSemaphoreTake>
	while(1){
		if(DIO_u8_get_pin(DIO_REF_PORTC, B0) == 0){
     138:	82 e0       	ldi	r24, 0x02	; 2
     13a:	60 e0       	ldi	r22, 0x00	; 0
     13c:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <DIO_u8_get_pin>
     140:	88 23       	and	r24, r24
     142:	89 f4       	brne	.+34     	; 0x166 <task_1+0x54>
			while(DIO_u8_get_pin(DIO_REF_PORTC, B0) == 0);
     144:	82 e0       	ldi	r24, 0x02	; 2
     146:	60 e0       	ldi	r22, 0x00	; 0
     148:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <DIO_u8_get_pin>
     14c:	88 23       	and	r24, r24
     14e:	d1 f3       	breq	.-12     	; 0x144 <task_1+0x32>
			xSemaphoreGive(x_sem);
     150:	80 91 41 03 	lds	r24, 0x0341
     154:	90 91 42 03 	lds	r25, 0x0342
     158:	60 e0       	ldi	r22, 0x00	; 0
     15a:	70 e0       	ldi	r23, 0x00	; 0
     15c:	40 e0       	ldi	r20, 0x00	; 0
     15e:	50 e0       	ldi	r21, 0x00	; 0
     160:	20 e0       	ldi	r18, 0x00	; 0
     162:	0e 94 b4 09 	call	0x1368	; 0x1368 <xQueueGenericSend>
		}
		vTaskDelay(200);
     166:	88 ec       	ldi	r24, 0xC8	; 200
     168:	90 e0       	ldi	r25, 0x00	; 0
     16a:	0e 94 54 12 	call	0x24a8	; 0x24a8 <vTaskDelay>
     16e:	e4 cf       	rjmp	.-56     	; 0x138 <task_1+0x26>

00000170 <task_2>:
	}
}

void task_2(void * pvParameners){
     170:	df 93       	push	r29
     172:	cf 93       	push	r28
     174:	00 d0       	rcall	.+0      	; 0x176 <task_2+0x6>
     176:	cd b7       	in	r28, 0x3d	; 61
     178:	de b7       	in	r29, 0x3e	; 62
     17a:	9a 83       	std	Y+2, r25	; 0x02
     17c:	89 83       	std	Y+1, r24	; 0x01
	/*
	 *
	 */
	DIO_void_set_pin_dir(DIO_REF_PORTC, B1, OUTPUT);
     17e:	82 e0       	ldi	r24, 0x02	; 2
     180:	61 e0       	ldi	r22, 0x01	; 1
     182:	4f ef       	ldi	r20, 0xFF	; 255
     184:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <DIO_void_set_pin_dir>
	DIO_void_clear_pin(DIO_REF_PORTC, B1);
     188:	82 e0       	ldi	r24, 0x02	; 2
     18a:	61 e0       	ldi	r22, 0x01	; 1
     18c:	0e 94 30 1d 	call	0x3a60	; 0x3a60 <DIO_void_clear_pin>
	while(1){
		if(xSemaphoreTake(x_sem, 10) == pdPASS){
     190:	80 91 41 03 	lds	r24, 0x0341
     194:	90 91 42 03 	lds	r25, 0x0342
     198:	6a e0       	ldi	r22, 0x0A	; 10
     19a:	70 e0       	ldi	r23, 0x00	; 0
     19c:	0e 94 b4 0b 	call	0x1768	; 0x1768 <xQueueSemaphoreTake>
     1a0:	81 30       	cpi	r24, 0x01	; 1
     1a2:	b1 f7       	brne	.-20     	; 0x190 <task_2+0x20>
			DIO_void_toggle_pin(DIO_REF_PORTC, B1);
     1a4:	82 e0       	ldi	r24, 0x02	; 2
     1a6:	61 e0       	ldi	r22, 0x01	; 1
     1a8:	0e 94 61 1d 	call	0x3ac2	; 0x3ac2 <DIO_void_toggle_pin>
     1ac:	f1 cf       	rjmp	.-30     	; 0x190 <task_2+0x20>

000001ae <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     1ae:	df 93       	push	r29
     1b0:	cf 93       	push	r28
     1b2:	00 d0       	rcall	.+0      	; 0x1b4 <xEventGroupCreate+0x6>
     1b4:	cd b7       	in	r28, 0x3d	; 61
     1b6:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     1b8:	8b e0       	ldi	r24, 0x0B	; 11
     1ba:	90 e0       	ldi	r25, 0x00	; 0
     1bc:	0e 94 1c 04 	call	0x838	; 0x838 <pvPortMalloc>
     1c0:	9a 83       	std	Y+2, r25	; 0x02
     1c2:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     1c4:	89 81       	ldd	r24, Y+1	; 0x01
     1c6:	9a 81       	ldd	r25, Y+2	; 0x02
     1c8:	00 97       	sbiw	r24, 0x00	; 0
     1ca:	49 f0       	breq	.+18     	; 0x1de <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     1cc:	e9 81       	ldd	r30, Y+1	; 0x01
     1ce:	fa 81       	ldd	r31, Y+2	; 0x02
     1d0:	11 82       	std	Z+1, r1	; 0x01
     1d2:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     1d4:	89 81       	ldd	r24, Y+1	; 0x01
     1d6:	9a 81       	ldd	r25, Y+2	; 0x02
     1d8:	02 96       	adiw	r24, 0x02	; 2
     1da:	0e 94 98 04 	call	0x930	; 0x930 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     1de:	89 81       	ldd	r24, Y+1	; 0x01
     1e0:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     1e2:	0f 90       	pop	r0
     1e4:	0f 90       	pop	r0
     1e6:	cf 91       	pop	r28
     1e8:	df 91       	pop	r29
     1ea:	08 95       	ret

000001ec <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     1ec:	df 93       	push	r29
     1ee:	cf 93       	push	r28
     1f0:	cd b7       	in	r28, 0x3d	; 61
     1f2:	de b7       	in	r29, 0x3e	; 62
     1f4:	60 97       	sbiw	r28, 0x10	; 16
     1f6:	0f b6       	in	r0, 0x3f	; 63
     1f8:	f8 94       	cli
     1fa:	de bf       	out	0x3e, r29	; 62
     1fc:	0f be       	out	0x3f, r0	; 63
     1fe:	cd bf       	out	0x3d, r28	; 61
     200:	9a 87       	std	Y+10, r25	; 0x0a
     202:	89 87       	std	Y+9, r24	; 0x09
     204:	7c 87       	std	Y+12, r23	; 0x0c
     206:	6b 87       	std	Y+11, r22	; 0x0b
     208:	5e 87       	std	Y+14, r21	; 0x0e
     20a:	4d 87       	std	Y+13, r20	; 0x0d
     20c:	38 8b       	std	Y+16, r19	; 0x10
     20e:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     210:	89 85       	ldd	r24, Y+9	; 0x09
     212:	9a 85       	ldd	r25, Y+10	; 0x0a
     214:	9c 83       	std	Y+4, r25	; 0x04
     216:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     218:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     21a:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     21e:	eb 81       	ldd	r30, Y+3	; 0x03
     220:	fc 81       	ldd	r31, Y+4	; 0x04
     222:	80 81       	ld	r24, Z
     224:	91 81       	ldd	r25, Z+1	; 0x01
     226:	98 87       	std	Y+8, r25	; 0x08
     228:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     22a:	89 85       	ldd	r24, Y+9	; 0x09
     22c:	9a 85       	ldd	r25, Y+10	; 0x0a
     22e:	2b 85       	ldd	r18, Y+11	; 0x0b
     230:	3c 85       	ldd	r19, Y+12	; 0x0c
     232:	b9 01       	movw	r22, r18
     234:	0e 94 cd 02 	call	0x59a	; 0x59a <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     238:	2f 81       	ldd	r18, Y+7	; 0x07
     23a:	38 85       	ldd	r19, Y+8	; 0x08
     23c:	8b 85       	ldd	r24, Y+11	; 0x0b
     23e:	9c 85       	ldd	r25, Y+12	; 0x0c
     240:	28 2b       	or	r18, r24
     242:	39 2b       	or	r19, r25
     244:	8d 85       	ldd	r24, Y+13	; 0x0d
     246:	9e 85       	ldd	r25, Y+14	; 0x0e
     248:	28 23       	and	r18, r24
     24a:	39 23       	and	r19, r25
     24c:	8d 85       	ldd	r24, Y+13	; 0x0d
     24e:	9e 85       	ldd	r25, Y+14	; 0x0e
     250:	28 17       	cp	r18, r24
     252:	39 07       	cpc	r19, r25
     254:	c9 f4       	brne	.+50     	; 0x288 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     256:	2f 81       	ldd	r18, Y+7	; 0x07
     258:	38 85       	ldd	r19, Y+8	; 0x08
     25a:	8b 85       	ldd	r24, Y+11	; 0x0b
     25c:	9c 85       	ldd	r25, Y+12	; 0x0c
     25e:	82 2b       	or	r24, r18
     260:	93 2b       	or	r25, r19
     262:	9e 83       	std	Y+6, r25	; 0x06
     264:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     266:	eb 81       	ldd	r30, Y+3	; 0x03
     268:	fc 81       	ldd	r31, Y+4	; 0x04
     26a:	20 81       	ld	r18, Z
     26c:	31 81       	ldd	r19, Z+1	; 0x01
     26e:	8d 85       	ldd	r24, Y+13	; 0x0d
     270:	9e 85       	ldd	r25, Y+14	; 0x0e
     272:	80 95       	com	r24
     274:	90 95       	com	r25
     276:	82 23       	and	r24, r18
     278:	93 23       	and	r25, r19
     27a:	eb 81       	ldd	r30, Y+3	; 0x03
     27c:	fc 81       	ldd	r31, Y+4	; 0x04
     27e:	91 83       	std	Z+1, r25	; 0x01
     280:	80 83       	st	Z, r24

			xTicksToWait = 0;
     282:	18 8a       	std	Y+16, r1	; 0x10
     284:	1f 86       	std	Y+15, r1	; 0x0f
     286:	1e c0       	rjmp	.+60     	; 0x2c4 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     288:	8f 85       	ldd	r24, Y+15	; 0x0f
     28a:	98 89       	ldd	r25, Y+16	; 0x10
     28c:	00 97       	sbiw	r24, 0x00	; 0
     28e:	91 f0       	breq	.+36     	; 0x2b4 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     290:	8b 81       	ldd	r24, Y+3	; 0x03
     292:	9c 81       	ldd	r25, Y+4	; 0x04
     294:	bc 01       	movw	r22, r24
     296:	6e 5f       	subi	r22, 0xFE	; 254
     298:	7f 4f       	sbci	r23, 0xFF	; 255
     29a:	8d 85       	ldd	r24, Y+13	; 0x0d
     29c:	9e 85       	ldd	r25, Y+14	; 0x0e
     29e:	9c 01       	movw	r18, r24
     2a0:	35 60       	ori	r19, 0x05	; 5
     2a2:	4f 85       	ldd	r20, Y+15	; 0x0f
     2a4:	58 89       	ldd	r21, Y+16	; 0x10
     2a6:	cb 01       	movw	r24, r22
     2a8:	b9 01       	movw	r22, r18
     2aa:	0e 94 24 15 	call	0x2a48	; 0x2a48 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     2ae:	1e 82       	std	Y+6, r1	; 0x06
     2b0:	1d 82       	std	Y+5, r1	; 0x05
     2b2:	08 c0       	rjmp	.+16     	; 0x2c4 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     2b4:	eb 81       	ldd	r30, Y+3	; 0x03
     2b6:	fc 81       	ldd	r31, Y+4	; 0x04
     2b8:	80 81       	ld	r24, Z
     2ba:	91 81       	ldd	r25, Z+1	; 0x01
     2bc:	9e 83       	std	Y+6, r25	; 0x06
     2be:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     2c0:	81 e0       	ldi	r24, 0x01	; 1
     2c2:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     2c4:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
     2c8:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     2ca:	8f 85       	ldd	r24, Y+15	; 0x0f
     2cc:	98 89       	ldd	r25, Y+16	; 0x10
     2ce:	00 97       	sbiw	r24, 0x00	; 0
     2d0:	09 f4       	brne	.+2      	; 0x2d4 <xEventGroupSync+0xe8>
     2d2:	3a c0       	rjmp	.+116    	; 0x348 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     2d4:	8a 81       	ldd	r24, Y+2	; 0x02
     2d6:	88 23       	and	r24, r24
     2d8:	11 f4       	brne	.+4      	; 0x2de <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     2da:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     2de:	0e 94 77 17 	call	0x2eee	; 0x2eee <uxTaskResetEventItemValue>
     2e2:	9e 83       	std	Y+6, r25	; 0x06
     2e4:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     2e6:	8d 81       	ldd	r24, Y+5	; 0x05
     2e8:	9e 81       	ldd	r25, Y+6	; 0x06
     2ea:	80 70       	andi	r24, 0x00	; 0
     2ec:	92 70       	andi	r25, 0x02	; 2
     2ee:	00 97       	sbiw	r24, 0x00	; 0
     2f0:	31 f5       	brne	.+76     	; 0x33e <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     2f2:	0f b6       	in	r0, 0x3f	; 63
     2f4:	f8 94       	cli
     2f6:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     2f8:	eb 81       	ldd	r30, Y+3	; 0x03
     2fa:	fc 81       	ldd	r31, Y+4	; 0x04
     2fc:	80 81       	ld	r24, Z
     2fe:	91 81       	ldd	r25, Z+1	; 0x01
     300:	9e 83       	std	Y+6, r25	; 0x06
     302:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     304:	2d 81       	ldd	r18, Y+5	; 0x05
     306:	3e 81       	ldd	r19, Y+6	; 0x06
     308:	8d 85       	ldd	r24, Y+13	; 0x0d
     30a:	9e 85       	ldd	r25, Y+14	; 0x0e
     30c:	28 23       	and	r18, r24
     30e:	39 23       	and	r19, r25
     310:	8d 85       	ldd	r24, Y+13	; 0x0d
     312:	9e 85       	ldd	r25, Y+14	; 0x0e
     314:	28 17       	cp	r18, r24
     316:	39 07       	cpc	r19, r25
     318:	71 f4       	brne	.+28     	; 0x336 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     31a:	eb 81       	ldd	r30, Y+3	; 0x03
     31c:	fc 81       	ldd	r31, Y+4	; 0x04
     31e:	20 81       	ld	r18, Z
     320:	31 81       	ldd	r19, Z+1	; 0x01
     322:	8d 85       	ldd	r24, Y+13	; 0x0d
     324:	9e 85       	ldd	r25, Y+14	; 0x0e
     326:	80 95       	com	r24
     328:	90 95       	com	r25
     32a:	82 23       	and	r24, r18
     32c:	93 23       	and	r25, r19
     32e:	eb 81       	ldd	r30, Y+3	; 0x03
     330:	fc 81       	ldd	r31, Y+4	; 0x04
     332:	91 83       	std	Z+1, r25	; 0x01
     334:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     336:	0f 90       	pop	r0
     338:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     33a:	81 e0       	ldi	r24, 0x01	; 1
     33c:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     33e:	8d 81       	ldd	r24, Y+5	; 0x05
     340:	9e 81       	ldd	r25, Y+6	; 0x06
     342:	90 70       	andi	r25, 0x00	; 0
     344:	9e 83       	std	Y+6, r25	; 0x06
     346:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     348:	8d 81       	ldd	r24, Y+5	; 0x05
     34a:	9e 81       	ldd	r25, Y+6	; 0x06
}
     34c:	60 96       	adiw	r28, 0x10	; 16
     34e:	0f b6       	in	r0, 0x3f	; 63
     350:	f8 94       	cli
     352:	de bf       	out	0x3e, r29	; 62
     354:	0f be       	out	0x3f, r0	; 63
     356:	cd bf       	out	0x3d, r28	; 61
     358:	cf 91       	pop	r28
     35a:	df 91       	pop	r29
     35c:	08 95       	ret

0000035e <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     35e:	0f 93       	push	r16
     360:	1f 93       	push	r17
     362:	df 93       	push	r29
     364:	cf 93       	push	r28
     366:	cd b7       	in	r28, 0x3d	; 61
     368:	de b7       	in	r29, 0x3e	; 62
     36a:	63 97       	sbiw	r28, 0x13	; 19
     36c:	0f b6       	in	r0, 0x3f	; 63
     36e:	f8 94       	cli
     370:	de bf       	out	0x3e, r29	; 62
     372:	0f be       	out	0x3f, r0	; 63
     374:	cd bf       	out	0x3d, r28	; 61
     376:	9d 87       	std	Y+13, r25	; 0x0d
     378:	8c 87       	std	Y+12, r24	; 0x0c
     37a:	7f 87       	std	Y+15, r23	; 0x0f
     37c:	6e 87       	std	Y+14, r22	; 0x0e
     37e:	48 8b       	std	Y+16, r20	; 0x10
     380:	29 8b       	std	Y+17, r18	; 0x11
     382:	1b 8b       	std	Y+19, r17	; 0x13
     384:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     386:	8c 85       	ldd	r24, Y+12	; 0x0c
     388:	9d 85       	ldd	r25, Y+13	; 0x0d
     38a:	9b 87       	std	Y+11, r25	; 0x0b
     38c:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     38e:	1f 82       	std	Y+7, r1	; 0x07
     390:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     392:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     394:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     398:	ea 85       	ldd	r30, Y+10	; 0x0a
     39a:	fb 85       	ldd	r31, Y+11	; 0x0b
     39c:	80 81       	ld	r24, Z
     39e:	91 81       	ldd	r25, Z+1	; 0x01
     3a0:	9a 83       	std	Y+2, r25	; 0x02
     3a2:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     3a4:	89 81       	ldd	r24, Y+1	; 0x01
     3a6:	9a 81       	ldd	r25, Y+2	; 0x02
     3a8:	2e 85       	ldd	r18, Y+14	; 0x0e
     3aa:	3f 85       	ldd	r19, Y+15	; 0x0f
     3ac:	b9 01       	movw	r22, r18
     3ae:	49 89       	ldd	r20, Y+17	; 0x11
     3b0:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <prvTestWaitCondition>
     3b4:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     3b6:	8d 81       	ldd	r24, Y+5	; 0x05
     3b8:	88 23       	and	r24, r24
     3ba:	c1 f0       	breq	.+48     	; 0x3ec <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     3bc:	89 81       	ldd	r24, Y+1	; 0x01
     3be:	9a 81       	ldd	r25, Y+2	; 0x02
     3c0:	99 87       	std	Y+9, r25	; 0x09
     3c2:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     3c4:	1b 8a       	std	Y+19, r1	; 0x13
     3c6:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     3c8:	88 89       	ldd	r24, Y+16	; 0x10
     3ca:	88 23       	and	r24, r24
     3cc:	e9 f1       	breq	.+122    	; 0x448 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     3ce:	ea 85       	ldd	r30, Y+10	; 0x0a
     3d0:	fb 85       	ldd	r31, Y+11	; 0x0b
     3d2:	20 81       	ld	r18, Z
     3d4:	31 81       	ldd	r19, Z+1	; 0x01
     3d6:	8e 85       	ldd	r24, Y+14	; 0x0e
     3d8:	9f 85       	ldd	r25, Y+15	; 0x0f
     3da:	80 95       	com	r24
     3dc:	90 95       	com	r25
     3de:	82 23       	and	r24, r18
     3e0:	93 23       	and	r25, r19
     3e2:	ea 85       	ldd	r30, Y+10	; 0x0a
     3e4:	fb 85       	ldd	r31, Y+11	; 0x0b
     3e6:	91 83       	std	Z+1, r25	; 0x01
     3e8:	80 83       	st	Z, r24
     3ea:	2e c0       	rjmp	.+92     	; 0x448 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     3ec:	8a 89       	ldd	r24, Y+18	; 0x12
     3ee:	9b 89       	ldd	r25, Y+19	; 0x13
     3f0:	00 97       	sbiw	r24, 0x00	; 0
     3f2:	39 f4       	brne	.+14     	; 0x402 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     3f4:	89 81       	ldd	r24, Y+1	; 0x01
     3f6:	9a 81       	ldd	r25, Y+2	; 0x02
     3f8:	99 87       	std	Y+9, r25	; 0x09
     3fa:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     3fc:	81 e0       	ldi	r24, 0x01	; 1
     3fe:	8b 83       	std	Y+3, r24	; 0x03
     400:	23 c0       	rjmp	.+70     	; 0x448 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     402:	88 89       	ldd	r24, Y+16	; 0x10
     404:	88 23       	and	r24, r24
     406:	29 f0       	breq	.+10     	; 0x412 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     408:	8e 81       	ldd	r24, Y+6	; 0x06
     40a:	9f 81       	ldd	r25, Y+7	; 0x07
     40c:	91 60       	ori	r25, 0x01	; 1
     40e:	9f 83       	std	Y+7, r25	; 0x07
     410:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     412:	89 89       	ldd	r24, Y+17	; 0x11
     414:	88 23       	and	r24, r24
     416:	29 f0       	breq	.+10     	; 0x422 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     418:	8e 81       	ldd	r24, Y+6	; 0x06
     41a:	9f 81       	ldd	r25, Y+7	; 0x07
     41c:	94 60       	ori	r25, 0x04	; 4
     41e:	9f 83       	std	Y+7, r25	; 0x07
     420:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     422:	8a 85       	ldd	r24, Y+10	; 0x0a
     424:	9b 85       	ldd	r25, Y+11	; 0x0b
     426:	bc 01       	movw	r22, r24
     428:	6e 5f       	subi	r22, 0xFE	; 254
     42a:	7f 4f       	sbci	r23, 0xFF	; 255
     42c:	2e 85       	ldd	r18, Y+14	; 0x0e
     42e:	3f 85       	ldd	r19, Y+15	; 0x0f
     430:	8e 81       	ldd	r24, Y+6	; 0x06
     432:	9f 81       	ldd	r25, Y+7	; 0x07
     434:	28 2b       	or	r18, r24
     436:	39 2b       	or	r19, r25
     438:	4a 89       	ldd	r20, Y+18	; 0x12
     43a:	5b 89       	ldd	r21, Y+19	; 0x13
     43c:	cb 01       	movw	r24, r22
     43e:	b9 01       	movw	r22, r18
     440:	0e 94 24 15 	call	0x2a48	; 0x2a48 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     444:	19 86       	std	Y+9, r1	; 0x09
     446:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     448:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
     44c:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     44e:	8a 89       	ldd	r24, Y+18	; 0x12
     450:	9b 89       	ldd	r25, Y+19	; 0x13
     452:	00 97       	sbiw	r24, 0x00	; 0
     454:	09 f4       	brne	.+2      	; 0x458 <xEventGroupWaitBits+0xfa>
     456:	3c c0       	rjmp	.+120    	; 0x4d0 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     458:	8c 81       	ldd	r24, Y+4	; 0x04
     45a:	88 23       	and	r24, r24
     45c:	11 f4       	brne	.+4      	; 0x462 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     45e:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     462:	0e 94 77 17 	call	0x2eee	; 0x2eee <uxTaskResetEventItemValue>
     466:	99 87       	std	Y+9, r25	; 0x09
     468:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     46a:	88 85       	ldd	r24, Y+8	; 0x08
     46c:	99 85       	ldd	r25, Y+9	; 0x09
     46e:	80 70       	andi	r24, 0x00	; 0
     470:	92 70       	andi	r25, 0x02	; 2
     472:	00 97       	sbiw	r24, 0x00	; 0
     474:	41 f5       	brne	.+80     	; 0x4c6 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     47c:	ea 85       	ldd	r30, Y+10	; 0x0a
     47e:	fb 85       	ldd	r31, Y+11	; 0x0b
     480:	80 81       	ld	r24, Z
     482:	91 81       	ldd	r25, Z+1	; 0x01
     484:	99 87       	std	Y+9, r25	; 0x09
     486:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     488:	88 85       	ldd	r24, Y+8	; 0x08
     48a:	99 85       	ldd	r25, Y+9	; 0x09
     48c:	2e 85       	ldd	r18, Y+14	; 0x0e
     48e:	3f 85       	ldd	r19, Y+15	; 0x0f
     490:	b9 01       	movw	r22, r18
     492:	49 89       	ldd	r20, Y+17	; 0x11
     494:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <prvTestWaitCondition>
     498:	88 23       	and	r24, r24
     49a:	89 f0       	breq	.+34     	; 0x4be <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     49c:	88 89       	ldd	r24, Y+16	; 0x10
     49e:	88 23       	and	r24, r24
     4a0:	71 f0       	breq	.+28     	; 0x4be <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     4a2:	ea 85       	ldd	r30, Y+10	; 0x0a
     4a4:	fb 85       	ldd	r31, Y+11	; 0x0b
     4a6:	20 81       	ld	r18, Z
     4a8:	31 81       	ldd	r19, Z+1	; 0x01
     4aa:	8e 85       	ldd	r24, Y+14	; 0x0e
     4ac:	9f 85       	ldd	r25, Y+15	; 0x0f
     4ae:	80 95       	com	r24
     4b0:	90 95       	com	r25
     4b2:	82 23       	and	r24, r18
     4b4:	93 23       	and	r25, r19
     4b6:	ea 85       	ldd	r30, Y+10	; 0x0a
     4b8:	fb 85       	ldd	r31, Y+11	; 0x0b
     4ba:	91 83       	std	Z+1, r25	; 0x01
     4bc:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     4be:	81 e0       	ldi	r24, 0x01	; 1
     4c0:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     4c2:	0f 90       	pop	r0
     4c4:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     4c6:	88 85       	ldd	r24, Y+8	; 0x08
     4c8:	99 85       	ldd	r25, Y+9	; 0x09
     4ca:	90 70       	andi	r25, 0x00	; 0
     4cc:	99 87       	std	Y+9, r25	; 0x09
     4ce:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     4d0:	88 85       	ldd	r24, Y+8	; 0x08
     4d2:	99 85       	ldd	r25, Y+9	; 0x09
}
     4d4:	63 96       	adiw	r28, 0x13	; 19
     4d6:	0f b6       	in	r0, 0x3f	; 63
     4d8:	f8 94       	cli
     4da:	de bf       	out	0x3e, r29	; 62
     4dc:	0f be       	out	0x3f, r0	; 63
     4de:	cd bf       	out	0x3d, r28	; 61
     4e0:	cf 91       	pop	r28
     4e2:	df 91       	pop	r29
     4e4:	1f 91       	pop	r17
     4e6:	0f 91       	pop	r16
     4e8:	08 95       	ret

000004ea <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     4ea:	df 93       	push	r29
     4ec:	cf 93       	push	r28
     4ee:	cd b7       	in	r28, 0x3d	; 61
     4f0:	de b7       	in	r29, 0x3e	; 62
     4f2:	28 97       	sbiw	r28, 0x08	; 8
     4f4:	0f b6       	in	r0, 0x3f	; 63
     4f6:	f8 94       	cli
     4f8:	de bf       	out	0x3e, r29	; 62
     4fa:	0f be       	out	0x3f, r0	; 63
     4fc:	cd bf       	out	0x3d, r28	; 61
     4fe:	9e 83       	std	Y+6, r25	; 0x06
     500:	8d 83       	std	Y+5, r24	; 0x05
     502:	78 87       	std	Y+8, r23	; 0x08
     504:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     506:	8d 81       	ldd	r24, Y+5	; 0x05
     508:	9e 81       	ldd	r25, Y+6	; 0x06
     50a:	9c 83       	std	Y+4, r25	; 0x04
     50c:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     50e:	0f b6       	in	r0, 0x3f	; 63
     510:	f8 94       	cli
     512:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     514:	eb 81       	ldd	r30, Y+3	; 0x03
     516:	fc 81       	ldd	r31, Y+4	; 0x04
     518:	80 81       	ld	r24, Z
     51a:	91 81       	ldd	r25, Z+1	; 0x01
     51c:	9a 83       	std	Y+2, r25	; 0x02
     51e:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     520:	eb 81       	ldd	r30, Y+3	; 0x03
     522:	fc 81       	ldd	r31, Y+4	; 0x04
     524:	20 81       	ld	r18, Z
     526:	31 81       	ldd	r19, Z+1	; 0x01
     528:	8f 81       	ldd	r24, Y+7	; 0x07
     52a:	98 85       	ldd	r25, Y+8	; 0x08
     52c:	80 95       	com	r24
     52e:	90 95       	com	r25
     530:	82 23       	and	r24, r18
     532:	93 23       	and	r25, r19
     534:	eb 81       	ldd	r30, Y+3	; 0x03
     536:	fc 81       	ldd	r31, Y+4	; 0x04
     538:	91 83       	std	Z+1, r25	; 0x01
     53a:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     53c:	0f 90       	pop	r0
     53e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     540:	89 81       	ldd	r24, Y+1	; 0x01
     542:	9a 81       	ldd	r25, Y+2	; 0x02
}
     544:	28 96       	adiw	r28, 0x08	; 8
     546:	0f b6       	in	r0, 0x3f	; 63
     548:	f8 94       	cli
     54a:	de bf       	out	0x3e, r29	; 62
     54c:	0f be       	out	0x3f, r0	; 63
     54e:	cd bf       	out	0x3d, r28	; 61
     550:	cf 91       	pop	r28
     552:	df 91       	pop	r29
     554:	08 95       	ret

00000556 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     556:	df 93       	push	r29
     558:	cf 93       	push	r28
     55a:	cd b7       	in	r28, 0x3d	; 61
     55c:	de b7       	in	r29, 0x3e	; 62
     55e:	27 97       	sbiw	r28, 0x07	; 7
     560:	0f b6       	in	r0, 0x3f	; 63
     562:	f8 94       	cli
     564:	de bf       	out	0x3e, r29	; 62
     566:	0f be       	out	0x3f, r0	; 63
     568:	cd bf       	out	0x3d, r28	; 61
     56a:	9f 83       	std	Y+7, r25	; 0x07
     56c:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     56e:	8e 81       	ldd	r24, Y+6	; 0x06
     570:	9f 81       	ldd	r25, Y+7	; 0x07
     572:	9c 83       	std	Y+4, r25	; 0x04
     574:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     576:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     578:	eb 81       	ldd	r30, Y+3	; 0x03
     57a:	fc 81       	ldd	r31, Y+4	; 0x04
     57c:	80 81       	ld	r24, Z
     57e:	91 81       	ldd	r25, Z+1	; 0x01
     580:	9a 83       	std	Y+2, r25	; 0x02
     582:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     584:	89 81       	ldd	r24, Y+1	; 0x01
     586:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     588:	27 96       	adiw	r28, 0x07	; 7
     58a:	0f b6       	in	r0, 0x3f	; 63
     58c:	f8 94       	cli
     58e:	de bf       	out	0x3e, r29	; 62
     590:	0f be       	out	0x3f, r0	; 63
     592:	cd bf       	out	0x3d, r28	; 61
     594:	cf 91       	pop	r28
     596:	df 91       	pop	r29
     598:	08 95       	ret

0000059a <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     59a:	df 93       	push	r29
     59c:	cf 93       	push	r28
     59e:	cd b7       	in	r28, 0x3d	; 61
     5a0:	de b7       	in	r29, 0x3e	; 62
     5a2:	65 97       	sbiw	r28, 0x15	; 21
     5a4:	0f b6       	in	r0, 0x3f	; 63
     5a6:	f8 94       	cli
     5a8:	de bf       	out	0x3e, r29	; 62
     5aa:	0f be       	out	0x3f, r0	; 63
     5ac:	cd bf       	out	0x3d, r28	; 61
     5ae:	9b 8b       	std	Y+19, r25	; 0x13
     5b0:	8a 8b       	std	Y+18, r24	; 0x12
     5b2:	7d 8b       	std	Y+21, r23	; 0x15
     5b4:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     5b6:	19 86       	std	Y+9, r1	; 0x09
     5b8:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     5ba:	8a 89       	ldd	r24, Y+18	; 0x12
     5bc:	9b 89       	ldd	r25, Y+19	; 0x13
     5be:	9b 83       	std	Y+3, r25	; 0x03
     5c0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     5c2:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     5c4:	8a 81       	ldd	r24, Y+2	; 0x02
     5c6:	9b 81       	ldd	r25, Y+3	; 0x03
     5c8:	02 96       	adiw	r24, 0x02	; 2
     5ca:	9b 87       	std	Y+11, r25	; 0x0b
     5cc:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ce:	8a 85       	ldd	r24, Y+10	; 0x0a
     5d0:	9b 85       	ldd	r25, Y+11	; 0x0b
     5d2:	03 96       	adiw	r24, 0x03	; 3
     5d4:	9d 87       	std	Y+13, r25	; 0x0d
     5d6:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     5d8:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     5dc:	ea 85       	ldd	r30, Y+10	; 0x0a
     5de:	fb 85       	ldd	r31, Y+11	; 0x0b
     5e0:	85 81       	ldd	r24, Z+5	; 0x05
     5e2:	96 81       	ldd	r25, Z+6	; 0x06
     5e4:	99 8b       	std	Y+17, r25	; 0x11
     5e6:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     5e8:	ea 81       	ldd	r30, Y+2	; 0x02
     5ea:	fb 81       	ldd	r31, Y+3	; 0x03
     5ec:	20 81       	ld	r18, Z
     5ee:	31 81       	ldd	r19, Z+1	; 0x01
     5f0:	8c 89       	ldd	r24, Y+20	; 0x14
     5f2:	9d 89       	ldd	r25, Y+21	; 0x15
     5f4:	82 2b       	or	r24, r18
     5f6:	93 2b       	or	r25, r19
     5f8:	ea 81       	ldd	r30, Y+2	; 0x02
     5fa:	fb 81       	ldd	r31, Y+3	; 0x03
     5fc:	91 83       	std	Z+1, r25	; 0x01
     5fe:	80 83       	st	Z, r24
     600:	59 c0       	rjmp	.+178    	; 0x6b4 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     602:	e8 89       	ldd	r30, Y+16	; 0x10
     604:	f9 89       	ldd	r31, Y+17	; 0x11
     606:	82 81       	ldd	r24, Z+2	; 0x02
     608:	93 81       	ldd	r25, Z+3	; 0x03
     60a:	9f 87       	std	Y+15, r25	; 0x0f
     60c:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     60e:	e8 89       	ldd	r30, Y+16	; 0x10
     610:	f9 89       	ldd	r31, Y+17	; 0x11
     612:	80 81       	ld	r24, Z
     614:	91 81       	ldd	r25, Z+1	; 0x01
     616:	9f 83       	std	Y+7, r25	; 0x07
     618:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     61a:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     61c:	8e 81       	ldd	r24, Y+6	; 0x06
     61e:	9f 81       	ldd	r25, Y+7	; 0x07
     620:	80 70       	andi	r24, 0x00	; 0
     622:	9d 83       	std	Y+5, r25	; 0x05
     624:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     626:	8e 81       	ldd	r24, Y+6	; 0x06
     628:	9f 81       	ldd	r25, Y+7	; 0x07
     62a:	90 70       	andi	r25, 0x00	; 0
     62c:	9f 83       	std	Y+7, r25	; 0x07
     62e:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     630:	8c 81       	ldd	r24, Y+4	; 0x04
     632:	9d 81       	ldd	r25, Y+5	; 0x05
     634:	80 70       	andi	r24, 0x00	; 0
     636:	94 70       	andi	r25, 0x04	; 4
     638:	00 97       	sbiw	r24, 0x00	; 0
     63a:	69 f4       	brne	.+26     	; 0x656 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     63c:	ea 81       	ldd	r30, Y+2	; 0x02
     63e:	fb 81       	ldd	r31, Y+3	; 0x03
     640:	20 81       	ld	r18, Z
     642:	31 81       	ldd	r19, Z+1	; 0x01
     644:	8e 81       	ldd	r24, Y+6	; 0x06
     646:	9f 81       	ldd	r25, Y+7	; 0x07
     648:	82 23       	and	r24, r18
     64a:	93 23       	and	r25, r19
     64c:	00 97       	sbiw	r24, 0x00	; 0
     64e:	91 f0       	breq	.+36     	; 0x674 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     650:	81 e0       	ldi	r24, 0x01	; 1
     652:	89 83       	std	Y+1, r24	; 0x01
     654:	0f c0       	rjmp	.+30     	; 0x674 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     656:	ea 81       	ldd	r30, Y+2	; 0x02
     658:	fb 81       	ldd	r31, Y+3	; 0x03
     65a:	20 81       	ld	r18, Z
     65c:	31 81       	ldd	r19, Z+1	; 0x01
     65e:	8e 81       	ldd	r24, Y+6	; 0x06
     660:	9f 81       	ldd	r25, Y+7	; 0x07
     662:	28 23       	and	r18, r24
     664:	39 23       	and	r19, r25
     666:	8e 81       	ldd	r24, Y+6	; 0x06
     668:	9f 81       	ldd	r25, Y+7	; 0x07
     66a:	28 17       	cp	r18, r24
     66c:	39 07       	cpc	r19, r25
     66e:	11 f4       	brne	.+4      	; 0x674 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     674:	89 81       	ldd	r24, Y+1	; 0x01
     676:	88 23       	and	r24, r24
     678:	c9 f0       	breq	.+50     	; 0x6ac <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     67a:	8c 81       	ldd	r24, Y+4	; 0x04
     67c:	9d 81       	ldd	r25, Y+5	; 0x05
     67e:	80 70       	andi	r24, 0x00	; 0
     680:	91 70       	andi	r25, 0x01	; 1
     682:	00 97       	sbiw	r24, 0x00	; 0
     684:	41 f0       	breq	.+16     	; 0x696 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     686:	88 85       	ldd	r24, Y+8	; 0x08
     688:	99 85       	ldd	r25, Y+9	; 0x09
     68a:	2e 81       	ldd	r18, Y+6	; 0x06
     68c:	3f 81       	ldd	r19, Y+7	; 0x07
     68e:	82 2b       	or	r24, r18
     690:	93 2b       	or	r25, r19
     692:	99 87       	std	Y+9, r25	; 0x09
     694:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     696:	ea 81       	ldd	r30, Y+2	; 0x02
     698:	fb 81       	ldd	r31, Y+3	; 0x03
     69a:	80 81       	ld	r24, Z
     69c:	91 81       	ldd	r25, Z+1	; 0x01
     69e:	9c 01       	movw	r18, r24
     6a0:	32 60       	ori	r19, 0x02	; 2
     6a2:	88 89       	ldd	r24, Y+16	; 0x10
     6a4:	99 89       	ldd	r25, Y+17	; 0x11
     6a6:	b9 01       	movw	r22, r18
     6a8:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     6ac:	8e 85       	ldd	r24, Y+14	; 0x0e
     6ae:	9f 85       	ldd	r25, Y+15	; 0x0f
     6b0:	99 8b       	std	Y+17, r25	; 0x11
     6b2:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     6b4:	28 89       	ldd	r18, Y+16	; 0x10
     6b6:	39 89       	ldd	r19, Y+17	; 0x11
     6b8:	8c 85       	ldd	r24, Y+12	; 0x0c
     6ba:	9d 85       	ldd	r25, Y+13	; 0x0d
     6bc:	28 17       	cp	r18, r24
     6be:	39 07       	cpc	r19, r25
     6c0:	09 f0       	breq	.+2      	; 0x6c4 <xEventGroupSetBits+0x12a>
     6c2:	9f cf       	rjmp	.-194    	; 0x602 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     6c4:	ea 81       	ldd	r30, Y+2	; 0x02
     6c6:	fb 81       	ldd	r31, Y+3	; 0x03
     6c8:	20 81       	ld	r18, Z
     6ca:	31 81       	ldd	r19, Z+1	; 0x01
     6cc:	88 85       	ldd	r24, Y+8	; 0x08
     6ce:	99 85       	ldd	r25, Y+9	; 0x09
     6d0:	80 95       	com	r24
     6d2:	90 95       	com	r25
     6d4:	82 23       	and	r24, r18
     6d6:	93 23       	and	r25, r19
     6d8:	ea 81       	ldd	r30, Y+2	; 0x02
     6da:	fb 81       	ldd	r31, Y+3	; 0x03
     6dc:	91 83       	std	Z+1, r25	; 0x01
     6de:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     6e0:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     6e4:	ea 81       	ldd	r30, Y+2	; 0x02
     6e6:	fb 81       	ldd	r31, Y+3	; 0x03
     6e8:	80 81       	ld	r24, Z
     6ea:	91 81       	ldd	r25, Z+1	; 0x01
}
     6ec:	65 96       	adiw	r28, 0x15	; 21
     6ee:	0f b6       	in	r0, 0x3f	; 63
     6f0:	f8 94       	cli
     6f2:	de bf       	out	0x3e, r29	; 62
     6f4:	0f be       	out	0x3f, r0	; 63
     6f6:	cd bf       	out	0x3d, r28	; 61
     6f8:	cf 91       	pop	r28
     6fa:	df 91       	pop	r29
     6fc:	08 95       	ret

000006fe <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     6fe:	df 93       	push	r29
     700:	cf 93       	push	r28
     702:	00 d0       	rcall	.+0      	; 0x704 <vEventGroupDelete+0x6>
     704:	00 d0       	rcall	.+0      	; 0x706 <vEventGroupDelete+0x8>
     706:	00 d0       	rcall	.+0      	; 0x708 <vEventGroupDelete+0xa>
     708:	cd b7       	in	r28, 0x3d	; 61
     70a:	de b7       	in	r29, 0x3e	; 62
     70c:	9e 83       	std	Y+6, r25	; 0x06
     70e:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     710:	8d 81       	ldd	r24, Y+5	; 0x05
     712:	9e 81       	ldd	r25, Y+6	; 0x06
     714:	9c 83       	std	Y+4, r25	; 0x04
     716:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     718:	8b 81       	ldd	r24, Y+3	; 0x03
     71a:	9c 81       	ldd	r25, Y+4	; 0x04
     71c:	02 96       	adiw	r24, 0x02	; 2
     71e:	9a 83       	std	Y+2, r25	; 0x02
     720:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     722:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
     726:	08 c0       	rjmp	.+16     	; 0x738 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     728:	e9 81       	ldd	r30, Y+1	; 0x01
     72a:	fa 81       	ldd	r31, Y+2	; 0x02
     72c:	85 81       	ldd	r24, Z+5	; 0x05
     72e:	96 81       	ldd	r25, Z+6	; 0x06
     730:	60 e0       	ldi	r22, 0x00	; 0
     732:	72 e0       	ldi	r23, 0x02	; 2
     734:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     738:	e9 81       	ldd	r30, Y+1	; 0x01
     73a:	fa 81       	ldd	r31, Y+2	; 0x02
     73c:	80 81       	ld	r24, Z
     73e:	88 23       	and	r24, r24
     740:	99 f7       	brne	.-26     	; 0x728 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     742:	8b 81       	ldd	r24, Y+3	; 0x03
     744:	9c 81       	ldd	r25, Y+4	; 0x04
     746:	0e 94 72 04 	call	0x8e4	; 0x8e4 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     74a:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
}
     74e:	26 96       	adiw	r28, 0x06	; 6
     750:	0f b6       	in	r0, 0x3f	; 63
     752:	f8 94       	cli
     754:	de bf       	out	0x3e, r29	; 62
     756:	0f be       	out	0x3f, r0	; 63
     758:	cd bf       	out	0x3d, r28	; 61
     75a:	cf 91       	pop	r28
     75c:	df 91       	pop	r29
     75e:	08 95       	ret

00000760 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     760:	df 93       	push	r29
     762:	cf 93       	push	r28
     764:	00 d0       	rcall	.+0      	; 0x766 <vEventGroupSetBitsCallback+0x6>
     766:	00 d0       	rcall	.+0      	; 0x768 <vEventGroupSetBitsCallback+0x8>
     768:	00 d0       	rcall	.+0      	; 0x76a <vEventGroupSetBitsCallback+0xa>
     76a:	cd b7       	in	r28, 0x3d	; 61
     76c:	de b7       	in	r29, 0x3e	; 62
     76e:	9a 83       	std	Y+2, r25	; 0x02
     770:	89 83       	std	Y+1, r24	; 0x01
     772:	4b 83       	std	Y+3, r20	; 0x03
     774:	5c 83       	std	Y+4, r21	; 0x04
     776:	6d 83       	std	Y+5, r22	; 0x05
     778:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     77a:	89 81       	ldd	r24, Y+1	; 0x01
     77c:	9a 81       	ldd	r25, Y+2	; 0x02
     77e:	2b 81       	ldd	r18, Y+3	; 0x03
     780:	3c 81       	ldd	r19, Y+4	; 0x04
     782:	b9 01       	movw	r22, r18
     784:	0e 94 cd 02 	call	0x59a	; 0x59a <xEventGroupSetBits>
}
     788:	26 96       	adiw	r28, 0x06	; 6
     78a:	0f b6       	in	r0, 0x3f	; 63
     78c:	f8 94       	cli
     78e:	de bf       	out	0x3e, r29	; 62
     790:	0f be       	out	0x3f, r0	; 63
     792:	cd bf       	out	0x3d, r28	; 61
     794:	cf 91       	pop	r28
     796:	df 91       	pop	r29
     798:	08 95       	ret

0000079a <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     79a:	df 93       	push	r29
     79c:	cf 93       	push	r28
     79e:	00 d0       	rcall	.+0      	; 0x7a0 <vEventGroupClearBitsCallback+0x6>
     7a0:	00 d0       	rcall	.+0      	; 0x7a2 <vEventGroupClearBitsCallback+0x8>
     7a2:	00 d0       	rcall	.+0      	; 0x7a4 <vEventGroupClearBitsCallback+0xa>
     7a4:	cd b7       	in	r28, 0x3d	; 61
     7a6:	de b7       	in	r29, 0x3e	; 62
     7a8:	9a 83       	std	Y+2, r25	; 0x02
     7aa:	89 83       	std	Y+1, r24	; 0x01
     7ac:	4b 83       	std	Y+3, r20	; 0x03
     7ae:	5c 83       	std	Y+4, r21	; 0x04
     7b0:	6d 83       	std	Y+5, r22	; 0x05
     7b2:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     7b4:	89 81       	ldd	r24, Y+1	; 0x01
     7b6:	9a 81       	ldd	r25, Y+2	; 0x02
     7b8:	2b 81       	ldd	r18, Y+3	; 0x03
     7ba:	3c 81       	ldd	r19, Y+4	; 0x04
     7bc:	b9 01       	movw	r22, r18
     7be:	0e 94 75 02 	call	0x4ea	; 0x4ea <xEventGroupClearBits>
}
     7c2:	26 96       	adiw	r28, 0x06	; 6
     7c4:	0f b6       	in	r0, 0x3f	; 63
     7c6:	f8 94       	cli
     7c8:	de bf       	out	0x3e, r29	; 62
     7ca:	0f be       	out	0x3f, r0	; 63
     7cc:	cd bf       	out	0x3d, r28	; 61
     7ce:	cf 91       	pop	r28
     7d0:	df 91       	pop	r29
     7d2:	08 95       	ret

000007d4 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     7d4:	df 93       	push	r29
     7d6:	cf 93       	push	r28
     7d8:	00 d0       	rcall	.+0      	; 0x7da <prvTestWaitCondition+0x6>
     7da:	00 d0       	rcall	.+0      	; 0x7dc <prvTestWaitCondition+0x8>
     7dc:	00 d0       	rcall	.+0      	; 0x7de <prvTestWaitCondition+0xa>
     7de:	cd b7       	in	r28, 0x3d	; 61
     7e0:	de b7       	in	r29, 0x3e	; 62
     7e2:	9b 83       	std	Y+3, r25	; 0x03
     7e4:	8a 83       	std	Y+2, r24	; 0x02
     7e6:	7d 83       	std	Y+5, r23	; 0x05
     7e8:	6c 83       	std	Y+4, r22	; 0x04
     7ea:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     7ec:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     7ee:	8e 81       	ldd	r24, Y+6	; 0x06
     7f0:	88 23       	and	r24, r24
     7f2:	59 f4       	brne	.+22     	; 0x80a <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     7f4:	8a 81       	ldd	r24, Y+2	; 0x02
     7f6:	9b 81       	ldd	r25, Y+3	; 0x03
     7f8:	2c 81       	ldd	r18, Y+4	; 0x04
     7fa:	3d 81       	ldd	r19, Y+5	; 0x05
     7fc:	82 23       	and	r24, r18
     7fe:	93 23       	and	r25, r19
     800:	00 97       	sbiw	r24, 0x00	; 0
     802:	81 f0       	breq	.+32     	; 0x824 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     804:	81 e0       	ldi	r24, 0x01	; 1
     806:	89 83       	std	Y+1, r24	; 0x01
     808:	0d c0       	rjmp	.+26     	; 0x824 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     80a:	2a 81       	ldd	r18, Y+2	; 0x02
     80c:	3b 81       	ldd	r19, Y+3	; 0x03
     80e:	8c 81       	ldd	r24, Y+4	; 0x04
     810:	9d 81       	ldd	r25, Y+5	; 0x05
     812:	28 23       	and	r18, r24
     814:	39 23       	and	r19, r25
     816:	8c 81       	ldd	r24, Y+4	; 0x04
     818:	9d 81       	ldd	r25, Y+5	; 0x05
     81a:	28 17       	cp	r18, r24
     81c:	39 07       	cpc	r19, r25
     81e:	11 f4       	brne	.+4      	; 0x824 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     820:	81 e0       	ldi	r24, 0x01	; 1
     822:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     824:	89 81       	ldd	r24, Y+1	; 0x01
}
     826:	26 96       	adiw	r28, 0x06	; 6
     828:	0f b6       	in	r0, 0x3f	; 63
     82a:	f8 94       	cli
     82c:	de bf       	out	0x3e, r29	; 62
     82e:	0f be       	out	0x3f, r0	; 63
     830:	cd bf       	out	0x3d, r28	; 61
     832:	cf 91       	pop	r28
     834:	df 91       	pop	r29
     836:	08 95       	ret

00000838 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     838:	df 93       	push	r29
     83a:	cf 93       	push	r28
     83c:	00 d0       	rcall	.+0      	; 0x83e <pvPortMalloc+0x6>
     83e:	00 d0       	rcall	.+0      	; 0x840 <pvPortMalloc+0x8>
     840:	cd b7       	in	r28, 0x3d	; 61
     842:	de b7       	in	r29, 0x3e	; 62
     844:	9c 83       	std	Y+4, r25	; 0x04
     846:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     848:	1a 82       	std	Y+2, r1	; 0x02
     84a:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     84c:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     850:	80 91 8a 00 	lds	r24, 0x008A
     854:	90 91 8b 00 	lds	r25, 0x008B
     858:	00 97       	sbiw	r24, 0x00	; 0
     85a:	31 f4       	brne	.+12     	; 0x868 <__stack+0x9>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     85c:	8d e8       	ldi	r24, 0x8D	; 141
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	90 93 8b 00 	sts	0x008B, r25
     864:	80 93 8a 00 	sts	0x008A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     868:	80 91 88 00 	lds	r24, 0x0088
     86c:	90 91 89 00 	lds	r25, 0x0089
     870:	2b 81       	ldd	r18, Y+3	; 0x03
     872:	3c 81       	ldd	r19, Y+4	; 0x04
     874:	82 0f       	add	r24, r18
     876:	93 1f       	adc	r25, r19
     878:	22 e0       	ldi	r18, 0x02	; 2
     87a:	87 35       	cpi	r24, 0x57	; 87
     87c:	92 07       	cpc	r25, r18
     87e:	38 f5       	brcc	.+78     	; 0x8ce <__stack+0x6f>
     880:	20 91 88 00 	lds	r18, 0x0088
     884:	30 91 89 00 	lds	r19, 0x0089
     888:	8b 81       	ldd	r24, Y+3	; 0x03
     88a:	9c 81       	ldd	r25, Y+4	; 0x04
     88c:	28 0f       	add	r18, r24
     88e:	39 1f       	adc	r19, r25
     890:	80 91 88 00 	lds	r24, 0x0088
     894:	90 91 89 00 	lds	r25, 0x0089
     898:	82 17       	cp	r24, r18
     89a:	93 07       	cpc	r25, r19
     89c:	c0 f4       	brcc	.+48     	; 0x8ce <__stack+0x6f>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     89e:	20 91 8a 00 	lds	r18, 0x008A
     8a2:	30 91 8b 00 	lds	r19, 0x008B
     8a6:	80 91 88 00 	lds	r24, 0x0088
     8aa:	90 91 89 00 	lds	r25, 0x0089
     8ae:	82 0f       	add	r24, r18
     8b0:	93 1f       	adc	r25, r19
     8b2:	9a 83       	std	Y+2, r25	; 0x02
     8b4:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     8b6:	20 91 88 00 	lds	r18, 0x0088
     8ba:	30 91 89 00 	lds	r19, 0x0089
     8be:	8b 81       	ldd	r24, Y+3	; 0x03
     8c0:	9c 81       	ldd	r25, Y+4	; 0x04
     8c2:	82 0f       	add	r24, r18
     8c4:	93 1f       	adc	r25, r19
     8c6:	90 93 89 00 	sts	0x0089, r25
     8ca:	80 93 88 00 	sts	0x0088, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     8ce:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     8d2:	89 81       	ldd	r24, Y+1	; 0x01
     8d4:	9a 81       	ldd	r25, Y+2	; 0x02
}
     8d6:	0f 90       	pop	r0
     8d8:	0f 90       	pop	r0
     8da:	0f 90       	pop	r0
     8dc:	0f 90       	pop	r0
     8de:	cf 91       	pop	r28
     8e0:	df 91       	pop	r29
     8e2:	08 95       	ret

000008e4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     8e4:	df 93       	push	r29
     8e6:	cf 93       	push	r28
     8e8:	00 d0       	rcall	.+0      	; 0x8ea <vPortFree+0x6>
     8ea:	cd b7       	in	r28, 0x3d	; 61
     8ec:	de b7       	in	r29, 0x3e	; 62
     8ee:	9a 83       	std	Y+2, r25	; 0x02
     8f0:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     8f2:	0f 90       	pop	r0
     8f4:	0f 90       	pop	r0
     8f6:	cf 91       	pop	r28
     8f8:	df 91       	pop	r29
     8fa:	08 95       	ret

000008fc <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     8fc:	df 93       	push	r29
     8fe:	cf 93       	push	r28
     900:	cd b7       	in	r28, 0x3d	; 61
     902:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     904:	10 92 89 00 	sts	0x0089, r1
     908:	10 92 88 00 	sts	0x0088, r1
}
     90c:	cf 91       	pop	r28
     90e:	df 91       	pop	r29
     910:	08 95       	ret

00000912 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     912:	df 93       	push	r29
     914:	cf 93       	push	r28
     916:	cd b7       	in	r28, 0x3d	; 61
     918:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     91a:	20 91 88 00 	lds	r18, 0x0088
     91e:	30 91 89 00 	lds	r19, 0x0089
     922:	87 e5       	ldi	r24, 0x57	; 87
     924:	92 e0       	ldi	r25, 0x02	; 2
     926:	82 1b       	sub	r24, r18
     928:	93 0b       	sbc	r25, r19
}
     92a:	cf 91       	pop	r28
     92c:	df 91       	pop	r29
     92e:	08 95       	ret

00000930 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     930:	df 93       	push	r29
     932:	cf 93       	push	r28
     934:	00 d0       	rcall	.+0      	; 0x936 <vListInitialise+0x6>
     936:	cd b7       	in	r28, 0x3d	; 61
     938:	de b7       	in	r29, 0x3e	; 62
     93a:	9a 83       	std	Y+2, r25	; 0x02
     93c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     93e:	89 81       	ldd	r24, Y+1	; 0x01
     940:	9a 81       	ldd	r25, Y+2	; 0x02
     942:	03 96       	adiw	r24, 0x03	; 3
     944:	e9 81       	ldd	r30, Y+1	; 0x01
     946:	fa 81       	ldd	r31, Y+2	; 0x02
     948:	92 83       	std	Z+2, r25	; 0x02
     94a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     94c:	e9 81       	ldd	r30, Y+1	; 0x01
     94e:	fa 81       	ldd	r31, Y+2	; 0x02
     950:	8f ef       	ldi	r24, 0xFF	; 255
     952:	9f ef       	ldi	r25, 0xFF	; 255
     954:	94 83       	std	Z+4, r25	; 0x04
     956:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     958:	89 81       	ldd	r24, Y+1	; 0x01
     95a:	9a 81       	ldd	r25, Y+2	; 0x02
     95c:	03 96       	adiw	r24, 0x03	; 3
     95e:	e9 81       	ldd	r30, Y+1	; 0x01
     960:	fa 81       	ldd	r31, Y+2	; 0x02
     962:	96 83       	std	Z+6, r25	; 0x06
     964:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     966:	89 81       	ldd	r24, Y+1	; 0x01
     968:	9a 81       	ldd	r25, Y+2	; 0x02
     96a:	03 96       	adiw	r24, 0x03	; 3
     96c:	e9 81       	ldd	r30, Y+1	; 0x01
     96e:	fa 81       	ldd	r31, Y+2	; 0x02
     970:	90 87       	std	Z+8, r25	; 0x08
     972:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     974:	e9 81       	ldd	r30, Y+1	; 0x01
     976:	fa 81       	ldd	r31, Y+2	; 0x02
     978:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     97a:	0f 90       	pop	r0
     97c:	0f 90       	pop	r0
     97e:	cf 91       	pop	r28
     980:	df 91       	pop	r29
     982:	08 95       	ret

00000984 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     984:	df 93       	push	r29
     986:	cf 93       	push	r28
     988:	00 d0       	rcall	.+0      	; 0x98a <vListInitialiseItem+0x6>
     98a:	cd b7       	in	r28, 0x3d	; 61
     98c:	de b7       	in	r29, 0x3e	; 62
     98e:	9a 83       	std	Y+2, r25	; 0x02
     990:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     992:	e9 81       	ldd	r30, Y+1	; 0x01
     994:	fa 81       	ldd	r31, Y+2	; 0x02
     996:	11 86       	std	Z+9, r1	; 0x09
     998:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     99a:	0f 90       	pop	r0
     99c:	0f 90       	pop	r0
     99e:	cf 91       	pop	r28
     9a0:	df 91       	pop	r29
     9a2:	08 95       	ret

000009a4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9a4:	df 93       	push	r29
     9a6:	cf 93       	push	r28
     9a8:	00 d0       	rcall	.+0      	; 0x9aa <vListInsertEnd+0x6>
     9aa:	00 d0       	rcall	.+0      	; 0x9ac <vListInsertEnd+0x8>
     9ac:	00 d0       	rcall	.+0      	; 0x9ae <vListInsertEnd+0xa>
     9ae:	cd b7       	in	r28, 0x3d	; 61
     9b0:	de b7       	in	r29, 0x3e	; 62
     9b2:	9c 83       	std	Y+4, r25	; 0x04
     9b4:	8b 83       	std	Y+3, r24	; 0x03
     9b6:	7e 83       	std	Y+6, r23	; 0x06
     9b8:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     9ba:	eb 81       	ldd	r30, Y+3	; 0x03
     9bc:	fc 81       	ldd	r31, Y+4	; 0x04
     9be:	81 81       	ldd	r24, Z+1	; 0x01
     9c0:	92 81       	ldd	r25, Z+2	; 0x02
     9c2:	9a 83       	std	Y+2, r25	; 0x02
     9c4:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9c6:	ed 81       	ldd	r30, Y+5	; 0x05
     9c8:	fe 81       	ldd	r31, Y+6	; 0x06
     9ca:	89 81       	ldd	r24, Y+1	; 0x01
     9cc:	9a 81       	ldd	r25, Y+2	; 0x02
     9ce:	93 83       	std	Z+3, r25	; 0x03
     9d0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9d2:	e9 81       	ldd	r30, Y+1	; 0x01
     9d4:	fa 81       	ldd	r31, Y+2	; 0x02
     9d6:	84 81       	ldd	r24, Z+4	; 0x04
     9d8:	95 81       	ldd	r25, Z+5	; 0x05
     9da:	ed 81       	ldd	r30, Y+5	; 0x05
     9dc:	fe 81       	ldd	r31, Y+6	; 0x06
     9de:	95 83       	std	Z+5, r25	; 0x05
     9e0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     9e2:	e9 81       	ldd	r30, Y+1	; 0x01
     9e4:	fa 81       	ldd	r31, Y+2	; 0x02
     9e6:	04 80       	ldd	r0, Z+4	; 0x04
     9e8:	f5 81       	ldd	r31, Z+5	; 0x05
     9ea:	e0 2d       	mov	r30, r0
     9ec:	8d 81       	ldd	r24, Y+5	; 0x05
     9ee:	9e 81       	ldd	r25, Y+6	; 0x06
     9f0:	93 83       	std	Z+3, r25	; 0x03
     9f2:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     9f4:	e9 81       	ldd	r30, Y+1	; 0x01
     9f6:	fa 81       	ldd	r31, Y+2	; 0x02
     9f8:	8d 81       	ldd	r24, Y+5	; 0x05
     9fa:	9e 81       	ldd	r25, Y+6	; 0x06
     9fc:	95 83       	std	Z+5, r25	; 0x05
     9fe:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     a00:	ed 81       	ldd	r30, Y+5	; 0x05
     a02:	fe 81       	ldd	r31, Y+6	; 0x06
     a04:	8b 81       	ldd	r24, Y+3	; 0x03
     a06:	9c 81       	ldd	r25, Y+4	; 0x04
     a08:	91 87       	std	Z+9, r25	; 0x09
     a0a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a0c:	eb 81       	ldd	r30, Y+3	; 0x03
     a0e:	fc 81       	ldd	r31, Y+4	; 0x04
     a10:	80 81       	ld	r24, Z
     a12:	8f 5f       	subi	r24, 0xFF	; 255
     a14:	eb 81       	ldd	r30, Y+3	; 0x03
     a16:	fc 81       	ldd	r31, Y+4	; 0x04
     a18:	80 83       	st	Z, r24
}
     a1a:	26 96       	adiw	r28, 0x06	; 6
     a1c:	0f b6       	in	r0, 0x3f	; 63
     a1e:	f8 94       	cli
     a20:	de bf       	out	0x3e, r29	; 62
     a22:	0f be       	out	0x3f, r0	; 63
     a24:	cd bf       	out	0x3d, r28	; 61
     a26:	cf 91       	pop	r28
     a28:	df 91       	pop	r29
     a2a:	08 95       	ret

00000a2c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a2c:	df 93       	push	r29
     a2e:	cf 93       	push	r28
     a30:	cd b7       	in	r28, 0x3d	; 61
     a32:	de b7       	in	r29, 0x3e	; 62
     a34:	28 97       	sbiw	r28, 0x08	; 8
     a36:	0f b6       	in	r0, 0x3f	; 63
     a38:	f8 94       	cli
     a3a:	de bf       	out	0x3e, r29	; 62
     a3c:	0f be       	out	0x3f, r0	; 63
     a3e:	cd bf       	out	0x3d, r28	; 61
     a40:	9e 83       	std	Y+6, r25	; 0x06
     a42:	8d 83       	std	Y+5, r24	; 0x05
     a44:	78 87       	std	Y+8, r23	; 0x08
     a46:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a48:	ef 81       	ldd	r30, Y+7	; 0x07
     a4a:	f8 85       	ldd	r31, Y+8	; 0x08
     a4c:	80 81       	ld	r24, Z
     a4e:	91 81       	ldd	r25, Z+1	; 0x01
     a50:	9a 83       	std	Y+2, r25	; 0x02
     a52:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a54:	89 81       	ldd	r24, Y+1	; 0x01
     a56:	9a 81       	ldd	r25, Y+2	; 0x02
     a58:	2f ef       	ldi	r18, 0xFF	; 255
     a5a:	8f 3f       	cpi	r24, 0xFF	; 255
     a5c:	92 07       	cpc	r25, r18
     a5e:	39 f4       	brne	.+14     	; 0xa6e <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a60:	ed 81       	ldd	r30, Y+5	; 0x05
     a62:	fe 81       	ldd	r31, Y+6	; 0x06
     a64:	87 81       	ldd	r24, Z+7	; 0x07
     a66:	90 85       	ldd	r25, Z+8	; 0x08
     a68:	9c 83       	std	Y+4, r25	; 0x04
     a6a:	8b 83       	std	Y+3, r24	; 0x03
     a6c:	18 c0       	rjmp	.+48     	; 0xa9e <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     a6e:	8d 81       	ldd	r24, Y+5	; 0x05
     a70:	9e 81       	ldd	r25, Y+6	; 0x06
     a72:	03 96       	adiw	r24, 0x03	; 3
     a74:	9c 83       	std	Y+4, r25	; 0x04
     a76:	8b 83       	std	Y+3, r24	; 0x03
     a78:	06 c0       	rjmp	.+12     	; 0xa86 <vListInsert+0x5a>
     a7a:	eb 81       	ldd	r30, Y+3	; 0x03
     a7c:	fc 81       	ldd	r31, Y+4	; 0x04
     a7e:	82 81       	ldd	r24, Z+2	; 0x02
     a80:	93 81       	ldd	r25, Z+3	; 0x03
     a82:	9c 83       	std	Y+4, r25	; 0x04
     a84:	8b 83       	std	Y+3, r24	; 0x03
     a86:	eb 81       	ldd	r30, Y+3	; 0x03
     a88:	fc 81       	ldd	r31, Y+4	; 0x04
     a8a:	02 80       	ldd	r0, Z+2	; 0x02
     a8c:	f3 81       	ldd	r31, Z+3	; 0x03
     a8e:	e0 2d       	mov	r30, r0
     a90:	20 81       	ld	r18, Z
     a92:	31 81       	ldd	r19, Z+1	; 0x01
     a94:	89 81       	ldd	r24, Y+1	; 0x01
     a96:	9a 81       	ldd	r25, Y+2	; 0x02
     a98:	82 17       	cp	r24, r18
     a9a:	93 07       	cpc	r25, r19
     a9c:	70 f7       	brcc	.-36     	; 0xa7a <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a9e:	eb 81       	ldd	r30, Y+3	; 0x03
     aa0:	fc 81       	ldd	r31, Y+4	; 0x04
     aa2:	82 81       	ldd	r24, Z+2	; 0x02
     aa4:	93 81       	ldd	r25, Z+3	; 0x03
     aa6:	ef 81       	ldd	r30, Y+7	; 0x07
     aa8:	f8 85       	ldd	r31, Y+8	; 0x08
     aaa:	93 83       	std	Z+3, r25	; 0x03
     aac:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     aae:	ef 81       	ldd	r30, Y+7	; 0x07
     ab0:	f8 85       	ldd	r31, Y+8	; 0x08
     ab2:	02 80       	ldd	r0, Z+2	; 0x02
     ab4:	f3 81       	ldd	r31, Z+3	; 0x03
     ab6:	e0 2d       	mov	r30, r0
     ab8:	8f 81       	ldd	r24, Y+7	; 0x07
     aba:	98 85       	ldd	r25, Y+8	; 0x08
     abc:	95 83       	std	Z+5, r25	; 0x05
     abe:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     ac0:	ef 81       	ldd	r30, Y+7	; 0x07
     ac2:	f8 85       	ldd	r31, Y+8	; 0x08
     ac4:	8b 81       	ldd	r24, Y+3	; 0x03
     ac6:	9c 81       	ldd	r25, Y+4	; 0x04
     ac8:	95 83       	std	Z+5, r25	; 0x05
     aca:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     acc:	eb 81       	ldd	r30, Y+3	; 0x03
     ace:	fc 81       	ldd	r31, Y+4	; 0x04
     ad0:	8f 81       	ldd	r24, Y+7	; 0x07
     ad2:	98 85       	ldd	r25, Y+8	; 0x08
     ad4:	93 83       	std	Z+3, r25	; 0x03
     ad6:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     ad8:	ef 81       	ldd	r30, Y+7	; 0x07
     ada:	f8 85       	ldd	r31, Y+8	; 0x08
     adc:	8d 81       	ldd	r24, Y+5	; 0x05
     ade:	9e 81       	ldd	r25, Y+6	; 0x06
     ae0:	91 87       	std	Z+9, r25	; 0x09
     ae2:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     ae4:	ed 81       	ldd	r30, Y+5	; 0x05
     ae6:	fe 81       	ldd	r31, Y+6	; 0x06
     ae8:	80 81       	ld	r24, Z
     aea:	8f 5f       	subi	r24, 0xFF	; 255
     aec:	ed 81       	ldd	r30, Y+5	; 0x05
     aee:	fe 81       	ldd	r31, Y+6	; 0x06
     af0:	80 83       	st	Z, r24
}
     af2:	28 96       	adiw	r28, 0x08	; 8
     af4:	0f b6       	in	r0, 0x3f	; 63
     af6:	f8 94       	cli
     af8:	de bf       	out	0x3e, r29	; 62
     afa:	0f be       	out	0x3f, r0	; 63
     afc:	cd bf       	out	0x3d, r28	; 61
     afe:	cf 91       	pop	r28
     b00:	df 91       	pop	r29
     b02:	08 95       	ret

00000b04 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     b04:	df 93       	push	r29
     b06:	cf 93       	push	r28
     b08:	00 d0       	rcall	.+0      	; 0xb0a <uxListRemove+0x6>
     b0a:	00 d0       	rcall	.+0      	; 0xb0c <uxListRemove+0x8>
     b0c:	cd b7       	in	r28, 0x3d	; 61
     b0e:	de b7       	in	r29, 0x3e	; 62
     b10:	9c 83       	std	Y+4, r25	; 0x04
     b12:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     b14:	eb 81       	ldd	r30, Y+3	; 0x03
     b16:	fc 81       	ldd	r31, Y+4	; 0x04
     b18:	80 85       	ldd	r24, Z+8	; 0x08
     b1a:	91 85       	ldd	r25, Z+9	; 0x09
     b1c:	9a 83       	std	Y+2, r25	; 0x02
     b1e:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     b20:	eb 81       	ldd	r30, Y+3	; 0x03
     b22:	fc 81       	ldd	r31, Y+4	; 0x04
     b24:	a2 81       	ldd	r26, Z+2	; 0x02
     b26:	b3 81       	ldd	r27, Z+3	; 0x03
     b28:	eb 81       	ldd	r30, Y+3	; 0x03
     b2a:	fc 81       	ldd	r31, Y+4	; 0x04
     b2c:	84 81       	ldd	r24, Z+4	; 0x04
     b2e:	95 81       	ldd	r25, Z+5	; 0x05
     b30:	15 96       	adiw	r26, 0x05	; 5
     b32:	9c 93       	st	X, r25
     b34:	8e 93       	st	-X, r24
     b36:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     b38:	eb 81       	ldd	r30, Y+3	; 0x03
     b3a:	fc 81       	ldd	r31, Y+4	; 0x04
     b3c:	a4 81       	ldd	r26, Z+4	; 0x04
     b3e:	b5 81       	ldd	r27, Z+5	; 0x05
     b40:	eb 81       	ldd	r30, Y+3	; 0x03
     b42:	fc 81       	ldd	r31, Y+4	; 0x04
     b44:	82 81       	ldd	r24, Z+2	; 0x02
     b46:	93 81       	ldd	r25, Z+3	; 0x03
     b48:	13 96       	adiw	r26, 0x03	; 3
     b4a:	9c 93       	st	X, r25
     b4c:	8e 93       	st	-X, r24
     b4e:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     b50:	e9 81       	ldd	r30, Y+1	; 0x01
     b52:	fa 81       	ldd	r31, Y+2	; 0x02
     b54:	21 81       	ldd	r18, Z+1	; 0x01
     b56:	32 81       	ldd	r19, Z+2	; 0x02
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	9c 81       	ldd	r25, Y+4	; 0x04
     b5c:	28 17       	cp	r18, r24
     b5e:	39 07       	cpc	r19, r25
     b60:	41 f4       	brne	.+16     	; 0xb72 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     b62:	eb 81       	ldd	r30, Y+3	; 0x03
     b64:	fc 81       	ldd	r31, Y+4	; 0x04
     b66:	84 81       	ldd	r24, Z+4	; 0x04
     b68:	95 81       	ldd	r25, Z+5	; 0x05
     b6a:	e9 81       	ldd	r30, Y+1	; 0x01
     b6c:	fa 81       	ldd	r31, Y+2	; 0x02
     b6e:	92 83       	std	Z+2, r25	; 0x02
     b70:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     b72:	eb 81       	ldd	r30, Y+3	; 0x03
     b74:	fc 81       	ldd	r31, Y+4	; 0x04
     b76:	11 86       	std	Z+9, r1	; 0x09
     b78:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     b7a:	e9 81       	ldd	r30, Y+1	; 0x01
     b7c:	fa 81       	ldd	r31, Y+2	; 0x02
     b7e:	80 81       	ld	r24, Z
     b80:	81 50       	subi	r24, 0x01	; 1
     b82:	e9 81       	ldd	r30, Y+1	; 0x01
     b84:	fa 81       	ldd	r31, Y+2	; 0x02
     b86:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
     b88:	e9 81       	ldd	r30, Y+1	; 0x01
     b8a:	fa 81       	ldd	r31, Y+2	; 0x02
     b8c:	80 81       	ld	r24, Z
}
     b8e:	0f 90       	pop	r0
     b90:	0f 90       	pop	r0
     b92:	0f 90       	pop	r0
     b94:	0f 90       	pop	r0
     b96:	cf 91       	pop	r28
     b98:	df 91       	pop	r29
     b9a:	08 95       	ret

00000b9c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     b9c:	df 93       	push	r29
     b9e:	cf 93       	push	r28
     ba0:	cd b7       	in	r28, 0x3d	; 61
     ba2:	de b7       	in	r29, 0x3e	; 62
     ba4:	28 97       	sbiw	r28, 0x08	; 8
     ba6:	0f b6       	in	r0, 0x3f	; 63
     ba8:	f8 94       	cli
     baa:	de bf       	out	0x3e, r29	; 62
     bac:	0f be       	out	0x3f, r0	; 63
     bae:	cd bf       	out	0x3d, r28	; 61
     bb0:	9c 83       	std	Y+4, r25	; 0x04
     bb2:	8b 83       	std	Y+3, r24	; 0x03
     bb4:	7e 83       	std	Y+6, r23	; 0x06
     bb6:	6d 83       	std	Y+5, r22	; 0x05
     bb8:	58 87       	std	Y+8, r21	; 0x08
     bba:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     bbc:	eb 81       	ldd	r30, Y+3	; 0x03
     bbe:	fc 81       	ldd	r31, Y+4	; 0x04
     bc0:	81 e1       	ldi	r24, 0x11	; 17
     bc2:	80 83       	st	Z, r24
	pxTopOfStack--;
     bc4:	8b 81       	ldd	r24, Y+3	; 0x03
     bc6:	9c 81       	ldd	r25, Y+4	; 0x04
     bc8:	01 97       	sbiw	r24, 0x01	; 1
     bca:	9c 83       	std	Y+4, r25	; 0x04
     bcc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     bce:	eb 81       	ldd	r30, Y+3	; 0x03
     bd0:	fc 81       	ldd	r31, Y+4	; 0x04
     bd2:	82 e2       	ldi	r24, 0x22	; 34
     bd4:	80 83       	st	Z, r24
	pxTopOfStack--;
     bd6:	8b 81       	ldd	r24, Y+3	; 0x03
     bd8:	9c 81       	ldd	r25, Y+4	; 0x04
     bda:	01 97       	sbiw	r24, 0x01	; 1
     bdc:	9c 83       	std	Y+4, r25	; 0x04
     bde:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     be0:	eb 81       	ldd	r30, Y+3	; 0x03
     be2:	fc 81       	ldd	r31, Y+4	; 0x04
     be4:	83 e3       	ldi	r24, 0x33	; 51
     be6:	80 83       	st	Z, r24
	pxTopOfStack--;
     be8:	8b 81       	ldd	r24, Y+3	; 0x03
     bea:	9c 81       	ldd	r25, Y+4	; 0x04
     bec:	01 97       	sbiw	r24, 0x01	; 1
     bee:	9c 83       	std	Y+4, r25	; 0x04
     bf0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     bf2:	8d 81       	ldd	r24, Y+5	; 0x05
     bf4:	9e 81       	ldd	r25, Y+6	; 0x06
     bf6:	9a 83       	std	Y+2, r25	; 0x02
     bf8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     bfa:	89 81       	ldd	r24, Y+1	; 0x01
     bfc:	eb 81       	ldd	r30, Y+3	; 0x03
     bfe:	fc 81       	ldd	r31, Y+4	; 0x04
     c00:	80 83       	st	Z, r24
	pxTopOfStack--;
     c02:	8b 81       	ldd	r24, Y+3	; 0x03
     c04:	9c 81       	ldd	r25, Y+4	; 0x04
     c06:	01 97       	sbiw	r24, 0x01	; 1
     c08:	9c 83       	std	Y+4, r25	; 0x04
     c0a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     c0c:	89 81       	ldd	r24, Y+1	; 0x01
     c0e:	9a 81       	ldd	r25, Y+2	; 0x02
     c10:	89 2f       	mov	r24, r25
     c12:	99 27       	eor	r25, r25
     c14:	9a 83       	std	Y+2, r25	; 0x02
     c16:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     c18:	89 81       	ldd	r24, Y+1	; 0x01
     c1a:	eb 81       	ldd	r30, Y+3	; 0x03
     c1c:	fc 81       	ldd	r31, Y+4	; 0x04
     c1e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c20:	8b 81       	ldd	r24, Y+3	; 0x03
     c22:	9c 81       	ldd	r25, Y+4	; 0x04
     c24:	01 97       	sbiw	r24, 0x01	; 1
     c26:	9c 83       	std	Y+4, r25	; 0x04
     c28:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     c2a:	eb 81       	ldd	r30, Y+3	; 0x03
     c2c:	fc 81       	ldd	r31, Y+4	; 0x04
     c2e:	10 82       	st	Z, r1
	pxTopOfStack--;
     c30:	8b 81       	ldd	r24, Y+3	; 0x03
     c32:	9c 81       	ldd	r25, Y+4	; 0x04
     c34:	01 97       	sbiw	r24, 0x01	; 1
     c36:	9c 83       	std	Y+4, r25	; 0x04
     c38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     c3a:	eb 81       	ldd	r30, Y+3	; 0x03
     c3c:	fc 81       	ldd	r31, Y+4	; 0x04
     c3e:	80 e8       	ldi	r24, 0x80	; 128
     c40:	80 83       	st	Z, r24
	pxTopOfStack--;
     c42:	8b 81       	ldd	r24, Y+3	; 0x03
     c44:	9c 81       	ldd	r25, Y+4	; 0x04
     c46:	01 97       	sbiw	r24, 0x01	; 1
     c48:	9c 83       	std	Y+4, r25	; 0x04
     c4a:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     c4c:	eb 81       	ldd	r30, Y+3	; 0x03
     c4e:	fc 81       	ldd	r31, Y+4	; 0x04
     c50:	10 82       	st	Z, r1
	pxTopOfStack--;
     c52:	8b 81       	ldd	r24, Y+3	; 0x03
     c54:	9c 81       	ldd	r25, Y+4	; 0x04
     c56:	01 97       	sbiw	r24, 0x01	; 1
     c58:	9c 83       	std	Y+4, r25	; 0x04
     c5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     c5c:	eb 81       	ldd	r30, Y+3	; 0x03
     c5e:	fc 81       	ldd	r31, Y+4	; 0x04
     c60:	82 e0       	ldi	r24, 0x02	; 2
     c62:	80 83       	st	Z, r24
	pxTopOfStack--;
     c64:	8b 81       	ldd	r24, Y+3	; 0x03
     c66:	9c 81       	ldd	r25, Y+4	; 0x04
     c68:	01 97       	sbiw	r24, 0x01	; 1
     c6a:	9c 83       	std	Y+4, r25	; 0x04
     c6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     c6e:	eb 81       	ldd	r30, Y+3	; 0x03
     c70:	fc 81       	ldd	r31, Y+4	; 0x04
     c72:	83 e0       	ldi	r24, 0x03	; 3
     c74:	80 83       	st	Z, r24
	pxTopOfStack--;
     c76:	8b 81       	ldd	r24, Y+3	; 0x03
     c78:	9c 81       	ldd	r25, Y+4	; 0x04
     c7a:	01 97       	sbiw	r24, 0x01	; 1
     c7c:	9c 83       	std	Y+4, r25	; 0x04
     c7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     c80:	eb 81       	ldd	r30, Y+3	; 0x03
     c82:	fc 81       	ldd	r31, Y+4	; 0x04
     c84:	84 e0       	ldi	r24, 0x04	; 4
     c86:	80 83       	st	Z, r24
	pxTopOfStack--;
     c88:	8b 81       	ldd	r24, Y+3	; 0x03
     c8a:	9c 81       	ldd	r25, Y+4	; 0x04
     c8c:	01 97       	sbiw	r24, 0x01	; 1
     c8e:	9c 83       	std	Y+4, r25	; 0x04
     c90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     c92:	eb 81       	ldd	r30, Y+3	; 0x03
     c94:	fc 81       	ldd	r31, Y+4	; 0x04
     c96:	85 e0       	ldi	r24, 0x05	; 5
     c98:	80 83       	st	Z, r24
	pxTopOfStack--;
     c9a:	8b 81       	ldd	r24, Y+3	; 0x03
     c9c:	9c 81       	ldd	r25, Y+4	; 0x04
     c9e:	01 97       	sbiw	r24, 0x01	; 1
     ca0:	9c 83       	std	Y+4, r25	; 0x04
     ca2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     ca4:	eb 81       	ldd	r30, Y+3	; 0x03
     ca6:	fc 81       	ldd	r31, Y+4	; 0x04
     ca8:	86 e0       	ldi	r24, 0x06	; 6
     caa:	80 83       	st	Z, r24
	pxTopOfStack--;
     cac:	8b 81       	ldd	r24, Y+3	; 0x03
     cae:	9c 81       	ldd	r25, Y+4	; 0x04
     cb0:	01 97       	sbiw	r24, 0x01	; 1
     cb2:	9c 83       	std	Y+4, r25	; 0x04
     cb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     cb6:	eb 81       	ldd	r30, Y+3	; 0x03
     cb8:	fc 81       	ldd	r31, Y+4	; 0x04
     cba:	87 e0       	ldi	r24, 0x07	; 7
     cbc:	80 83       	st	Z, r24
	pxTopOfStack--;
     cbe:	8b 81       	ldd	r24, Y+3	; 0x03
     cc0:	9c 81       	ldd	r25, Y+4	; 0x04
     cc2:	01 97       	sbiw	r24, 0x01	; 1
     cc4:	9c 83       	std	Y+4, r25	; 0x04
     cc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     cc8:	eb 81       	ldd	r30, Y+3	; 0x03
     cca:	fc 81       	ldd	r31, Y+4	; 0x04
     ccc:	88 e0       	ldi	r24, 0x08	; 8
     cce:	80 83       	st	Z, r24
	pxTopOfStack--;
     cd0:	8b 81       	ldd	r24, Y+3	; 0x03
     cd2:	9c 81       	ldd	r25, Y+4	; 0x04
     cd4:	01 97       	sbiw	r24, 0x01	; 1
     cd6:	9c 83       	std	Y+4, r25	; 0x04
     cd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     cda:	eb 81       	ldd	r30, Y+3	; 0x03
     cdc:	fc 81       	ldd	r31, Y+4	; 0x04
     cde:	89 e0       	ldi	r24, 0x09	; 9
     ce0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ce2:	8b 81       	ldd	r24, Y+3	; 0x03
     ce4:	9c 81       	ldd	r25, Y+4	; 0x04
     ce6:	01 97       	sbiw	r24, 0x01	; 1
     ce8:	9c 83       	std	Y+4, r25	; 0x04
     cea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     cec:	eb 81       	ldd	r30, Y+3	; 0x03
     cee:	fc 81       	ldd	r31, Y+4	; 0x04
     cf0:	80 e1       	ldi	r24, 0x10	; 16
     cf2:	80 83       	st	Z, r24
	pxTopOfStack--;
     cf4:	8b 81       	ldd	r24, Y+3	; 0x03
     cf6:	9c 81       	ldd	r25, Y+4	; 0x04
     cf8:	01 97       	sbiw	r24, 0x01	; 1
     cfa:	9c 83       	std	Y+4, r25	; 0x04
     cfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     cfe:	eb 81       	ldd	r30, Y+3	; 0x03
     d00:	fc 81       	ldd	r31, Y+4	; 0x04
     d02:	81 e1       	ldi	r24, 0x11	; 17
     d04:	80 83       	st	Z, r24
	pxTopOfStack--;
     d06:	8b 81       	ldd	r24, Y+3	; 0x03
     d08:	9c 81       	ldd	r25, Y+4	; 0x04
     d0a:	01 97       	sbiw	r24, 0x01	; 1
     d0c:	9c 83       	std	Y+4, r25	; 0x04
     d0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     d10:	eb 81       	ldd	r30, Y+3	; 0x03
     d12:	fc 81       	ldd	r31, Y+4	; 0x04
     d14:	82 e1       	ldi	r24, 0x12	; 18
     d16:	80 83       	st	Z, r24
	pxTopOfStack--;
     d18:	8b 81       	ldd	r24, Y+3	; 0x03
     d1a:	9c 81       	ldd	r25, Y+4	; 0x04
     d1c:	01 97       	sbiw	r24, 0x01	; 1
     d1e:	9c 83       	std	Y+4, r25	; 0x04
     d20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     d22:	eb 81       	ldd	r30, Y+3	; 0x03
     d24:	fc 81       	ldd	r31, Y+4	; 0x04
     d26:	83 e1       	ldi	r24, 0x13	; 19
     d28:	80 83       	st	Z, r24
	pxTopOfStack--;
     d2a:	8b 81       	ldd	r24, Y+3	; 0x03
     d2c:	9c 81       	ldd	r25, Y+4	; 0x04
     d2e:	01 97       	sbiw	r24, 0x01	; 1
     d30:	9c 83       	std	Y+4, r25	; 0x04
     d32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     d34:	eb 81       	ldd	r30, Y+3	; 0x03
     d36:	fc 81       	ldd	r31, Y+4	; 0x04
     d38:	84 e1       	ldi	r24, 0x14	; 20
     d3a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d3c:	8b 81       	ldd	r24, Y+3	; 0x03
     d3e:	9c 81       	ldd	r25, Y+4	; 0x04
     d40:	01 97       	sbiw	r24, 0x01	; 1
     d42:	9c 83       	std	Y+4, r25	; 0x04
     d44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     d46:	eb 81       	ldd	r30, Y+3	; 0x03
     d48:	fc 81       	ldd	r31, Y+4	; 0x04
     d4a:	85 e1       	ldi	r24, 0x15	; 21
     d4c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d4e:	8b 81       	ldd	r24, Y+3	; 0x03
     d50:	9c 81       	ldd	r25, Y+4	; 0x04
     d52:	01 97       	sbiw	r24, 0x01	; 1
     d54:	9c 83       	std	Y+4, r25	; 0x04
     d56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     d58:	eb 81       	ldd	r30, Y+3	; 0x03
     d5a:	fc 81       	ldd	r31, Y+4	; 0x04
     d5c:	86 e1       	ldi	r24, 0x16	; 22
     d5e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d60:	8b 81       	ldd	r24, Y+3	; 0x03
     d62:	9c 81       	ldd	r25, Y+4	; 0x04
     d64:	01 97       	sbiw	r24, 0x01	; 1
     d66:	9c 83       	std	Y+4, r25	; 0x04
     d68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     d6a:	eb 81       	ldd	r30, Y+3	; 0x03
     d6c:	fc 81       	ldd	r31, Y+4	; 0x04
     d6e:	87 e1       	ldi	r24, 0x17	; 23
     d70:	80 83       	st	Z, r24
	pxTopOfStack--;
     d72:	8b 81       	ldd	r24, Y+3	; 0x03
     d74:	9c 81       	ldd	r25, Y+4	; 0x04
     d76:	01 97       	sbiw	r24, 0x01	; 1
     d78:	9c 83       	std	Y+4, r25	; 0x04
     d7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     d7c:	eb 81       	ldd	r30, Y+3	; 0x03
     d7e:	fc 81       	ldd	r31, Y+4	; 0x04
     d80:	88 e1       	ldi	r24, 0x18	; 24
     d82:	80 83       	st	Z, r24
	pxTopOfStack--;
     d84:	8b 81       	ldd	r24, Y+3	; 0x03
     d86:	9c 81       	ldd	r25, Y+4	; 0x04
     d88:	01 97       	sbiw	r24, 0x01	; 1
     d8a:	9c 83       	std	Y+4, r25	; 0x04
     d8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     d8e:	eb 81       	ldd	r30, Y+3	; 0x03
     d90:	fc 81       	ldd	r31, Y+4	; 0x04
     d92:	89 e1       	ldi	r24, 0x19	; 25
     d94:	80 83       	st	Z, r24
	pxTopOfStack--;
     d96:	8b 81       	ldd	r24, Y+3	; 0x03
     d98:	9c 81       	ldd	r25, Y+4	; 0x04
     d9a:	01 97       	sbiw	r24, 0x01	; 1
     d9c:	9c 83       	std	Y+4, r25	; 0x04
     d9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     da0:	eb 81       	ldd	r30, Y+3	; 0x03
     da2:	fc 81       	ldd	r31, Y+4	; 0x04
     da4:	80 e2       	ldi	r24, 0x20	; 32
     da6:	80 83       	st	Z, r24
	pxTopOfStack--;
     da8:	8b 81       	ldd	r24, Y+3	; 0x03
     daa:	9c 81       	ldd	r25, Y+4	; 0x04
     dac:	01 97       	sbiw	r24, 0x01	; 1
     dae:	9c 83       	std	Y+4, r25	; 0x04
     db0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     db2:	eb 81       	ldd	r30, Y+3	; 0x03
     db4:	fc 81       	ldd	r31, Y+4	; 0x04
     db6:	81 e2       	ldi	r24, 0x21	; 33
     db8:	80 83       	st	Z, r24
	pxTopOfStack--;
     dba:	8b 81       	ldd	r24, Y+3	; 0x03
     dbc:	9c 81       	ldd	r25, Y+4	; 0x04
     dbe:	01 97       	sbiw	r24, 0x01	; 1
     dc0:	9c 83       	std	Y+4, r25	; 0x04
     dc2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     dc4:	eb 81       	ldd	r30, Y+3	; 0x03
     dc6:	fc 81       	ldd	r31, Y+4	; 0x04
     dc8:	82 e2       	ldi	r24, 0x22	; 34
     dca:	80 83       	st	Z, r24
	pxTopOfStack--;
     dcc:	8b 81       	ldd	r24, Y+3	; 0x03
     dce:	9c 81       	ldd	r25, Y+4	; 0x04
     dd0:	01 97       	sbiw	r24, 0x01	; 1
     dd2:	9c 83       	std	Y+4, r25	; 0x04
     dd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     dd6:	eb 81       	ldd	r30, Y+3	; 0x03
     dd8:	fc 81       	ldd	r31, Y+4	; 0x04
     dda:	83 e2       	ldi	r24, 0x23	; 35
     ddc:	80 83       	st	Z, r24
	pxTopOfStack--;
     dde:	8b 81       	ldd	r24, Y+3	; 0x03
     de0:	9c 81       	ldd	r25, Y+4	; 0x04
     de2:	01 97       	sbiw	r24, 0x01	; 1
     de4:	9c 83       	std	Y+4, r25	; 0x04
     de6:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     de8:	8f 81       	ldd	r24, Y+7	; 0x07
     dea:	98 85       	ldd	r25, Y+8	; 0x08
     dec:	9a 83       	std	Y+2, r25	; 0x02
     dee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     df0:	89 81       	ldd	r24, Y+1	; 0x01
     df2:	eb 81       	ldd	r30, Y+3	; 0x03
     df4:	fc 81       	ldd	r31, Y+4	; 0x04
     df6:	80 83       	st	Z, r24
	pxTopOfStack--;
     df8:	8b 81       	ldd	r24, Y+3	; 0x03
     dfa:	9c 81       	ldd	r25, Y+4	; 0x04
     dfc:	01 97       	sbiw	r24, 0x01	; 1
     dfe:	9c 83       	std	Y+4, r25	; 0x04
     e00:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     e02:	89 81       	ldd	r24, Y+1	; 0x01
     e04:	9a 81       	ldd	r25, Y+2	; 0x02
     e06:	89 2f       	mov	r24, r25
     e08:	99 27       	eor	r25, r25
     e0a:	9a 83       	std	Y+2, r25	; 0x02
     e0c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     e0e:	89 81       	ldd	r24, Y+1	; 0x01
     e10:	eb 81       	ldd	r30, Y+3	; 0x03
     e12:	fc 81       	ldd	r31, Y+4	; 0x04
     e14:	80 83       	st	Z, r24
	pxTopOfStack--;
     e16:	8b 81       	ldd	r24, Y+3	; 0x03
     e18:	9c 81       	ldd	r25, Y+4	; 0x04
     e1a:	01 97       	sbiw	r24, 0x01	; 1
     e1c:	9c 83       	std	Y+4, r25	; 0x04
     e1e:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     e20:	eb 81       	ldd	r30, Y+3	; 0x03
     e22:	fc 81       	ldd	r31, Y+4	; 0x04
     e24:	86 e2       	ldi	r24, 0x26	; 38
     e26:	80 83       	st	Z, r24
	pxTopOfStack--;
     e28:	8b 81       	ldd	r24, Y+3	; 0x03
     e2a:	9c 81       	ldd	r25, Y+4	; 0x04
     e2c:	01 97       	sbiw	r24, 0x01	; 1
     e2e:	9c 83       	std	Y+4, r25	; 0x04
     e30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     e32:	eb 81       	ldd	r30, Y+3	; 0x03
     e34:	fc 81       	ldd	r31, Y+4	; 0x04
     e36:	87 e2       	ldi	r24, 0x27	; 39
     e38:	80 83       	st	Z, r24
	pxTopOfStack--;
     e3a:	8b 81       	ldd	r24, Y+3	; 0x03
     e3c:	9c 81       	ldd	r25, Y+4	; 0x04
     e3e:	01 97       	sbiw	r24, 0x01	; 1
     e40:	9c 83       	std	Y+4, r25	; 0x04
     e42:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     e44:	eb 81       	ldd	r30, Y+3	; 0x03
     e46:	fc 81       	ldd	r31, Y+4	; 0x04
     e48:	88 e2       	ldi	r24, 0x28	; 40
     e4a:	80 83       	st	Z, r24
	pxTopOfStack--;
     e4c:	8b 81       	ldd	r24, Y+3	; 0x03
     e4e:	9c 81       	ldd	r25, Y+4	; 0x04
     e50:	01 97       	sbiw	r24, 0x01	; 1
     e52:	9c 83       	std	Y+4, r25	; 0x04
     e54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     e56:	eb 81       	ldd	r30, Y+3	; 0x03
     e58:	fc 81       	ldd	r31, Y+4	; 0x04
     e5a:	89 e2       	ldi	r24, 0x29	; 41
     e5c:	80 83       	st	Z, r24
	pxTopOfStack--;
     e5e:	8b 81       	ldd	r24, Y+3	; 0x03
     e60:	9c 81       	ldd	r25, Y+4	; 0x04
     e62:	01 97       	sbiw	r24, 0x01	; 1
     e64:	9c 83       	std	Y+4, r25	; 0x04
     e66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     e68:	eb 81       	ldd	r30, Y+3	; 0x03
     e6a:	fc 81       	ldd	r31, Y+4	; 0x04
     e6c:	80 e3       	ldi	r24, 0x30	; 48
     e6e:	80 83       	st	Z, r24
	pxTopOfStack--;
     e70:	8b 81       	ldd	r24, Y+3	; 0x03
     e72:	9c 81       	ldd	r25, Y+4	; 0x04
     e74:	01 97       	sbiw	r24, 0x01	; 1
     e76:	9c 83       	std	Y+4, r25	; 0x04
     e78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     e7a:	eb 81       	ldd	r30, Y+3	; 0x03
     e7c:	fc 81       	ldd	r31, Y+4	; 0x04
     e7e:	81 e3       	ldi	r24, 0x31	; 49
     e80:	80 83       	st	Z, r24
	pxTopOfStack--;
     e82:	8b 81       	ldd	r24, Y+3	; 0x03
     e84:	9c 81       	ldd	r25, Y+4	; 0x04
     e86:	01 97       	sbiw	r24, 0x01	; 1
     e88:	9c 83       	std	Y+4, r25	; 0x04
     e8a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     e8c:	8b 81       	ldd	r24, Y+3	; 0x03
     e8e:	9c 81       	ldd	r25, Y+4	; 0x04
}
     e90:	28 96       	adiw	r28, 0x08	; 8
     e92:	0f b6       	in	r0, 0x3f	; 63
     e94:	f8 94       	cli
     e96:	de bf       	out	0x3e, r29	; 62
     e98:	0f be       	out	0x3f, r0	; 63
     e9a:	cd bf       	out	0x3d, r28	; 61
     e9c:	cf 91       	pop	r28
     e9e:	df 91       	pop	r29
     ea0:	08 95       	ret

00000ea2 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     ea2:	df 93       	push	r29
     ea4:	cf 93       	push	r28
     ea6:	cd b7       	in	r28, 0x3d	; 61
     ea8:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     eaa:	0e 94 43 08 	call	0x1086	; 0x1086 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     eae:	a0 91 e4 02 	lds	r26, 0x02E4
     eb2:	b0 91 e5 02 	lds	r27, 0x02E5
     eb6:	cd 91       	ld	r28, X+
     eb8:	cd bf       	out	0x3d, r28	; 61
     eba:	dd 91       	ld	r29, X+
     ebc:	de bf       	out	0x3e, r29	; 62
     ebe:	ff 91       	pop	r31
     ec0:	ef 91       	pop	r30
     ec2:	df 91       	pop	r29
     ec4:	cf 91       	pop	r28
     ec6:	bf 91       	pop	r27
     ec8:	af 91       	pop	r26
     eca:	9f 91       	pop	r25
     ecc:	8f 91       	pop	r24
     ece:	7f 91       	pop	r23
     ed0:	6f 91       	pop	r22
     ed2:	5f 91       	pop	r21
     ed4:	4f 91       	pop	r20
     ed6:	3f 91       	pop	r19
     ed8:	2f 91       	pop	r18
     eda:	1f 91       	pop	r17
     edc:	0f 91       	pop	r16
     ede:	ff 90       	pop	r15
     ee0:	ef 90       	pop	r14
     ee2:	df 90       	pop	r13
     ee4:	cf 90       	pop	r12
     ee6:	bf 90       	pop	r11
     ee8:	af 90       	pop	r10
     eea:	9f 90       	pop	r9
     eec:	8f 90       	pop	r8
     eee:	7f 90       	pop	r7
     ef0:	6f 90       	pop	r6
     ef2:	5f 90       	pop	r5
     ef4:	4f 90       	pop	r4
     ef6:	3f 90       	pop	r3
     ef8:	2f 90       	pop	r2
     efa:	1f 90       	pop	r1
     efc:	0f 90       	pop	r0
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     f02:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     f04:	81 e0       	ldi	r24, 0x01	; 1
}
     f06:	cf 91       	pop	r28
     f08:	df 91       	pop	r29
     f0a:	08 95       	ret

00000f0c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     f0c:	df 93       	push	r29
     f0e:	cf 93       	push	r28
     f10:	cd b7       	in	r28, 0x3d	; 61
     f12:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     f14:	cf 91       	pop	r28
     f16:	df 91       	pop	r29
     f18:	08 95       	ret

00000f1a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     f1a:	0f 92       	push	r0
     f1c:	0f b6       	in	r0, 0x3f	; 63
     f1e:	f8 94       	cli
     f20:	0f 92       	push	r0
     f22:	1f 92       	push	r1
     f24:	11 24       	eor	r1, r1
     f26:	2f 92       	push	r2
     f28:	3f 92       	push	r3
     f2a:	4f 92       	push	r4
     f2c:	5f 92       	push	r5
     f2e:	6f 92       	push	r6
     f30:	7f 92       	push	r7
     f32:	8f 92       	push	r8
     f34:	9f 92       	push	r9
     f36:	af 92       	push	r10
     f38:	bf 92       	push	r11
     f3a:	cf 92       	push	r12
     f3c:	df 92       	push	r13
     f3e:	ef 92       	push	r14
     f40:	ff 92       	push	r15
     f42:	0f 93       	push	r16
     f44:	1f 93       	push	r17
     f46:	2f 93       	push	r18
     f48:	3f 93       	push	r19
     f4a:	4f 93       	push	r20
     f4c:	5f 93       	push	r21
     f4e:	6f 93       	push	r22
     f50:	7f 93       	push	r23
     f52:	8f 93       	push	r24
     f54:	9f 93       	push	r25
     f56:	af 93       	push	r26
     f58:	bf 93       	push	r27
     f5a:	cf 93       	push	r28
     f5c:	df 93       	push	r29
     f5e:	ef 93       	push	r30
     f60:	ff 93       	push	r31
     f62:	a0 91 e4 02 	lds	r26, 0x02E4
     f66:	b0 91 e5 02 	lds	r27, 0x02E5
     f6a:	0d b6       	in	r0, 0x3d	; 61
     f6c:	0d 92       	st	X+, r0
     f6e:	0e b6       	in	r0, 0x3e	; 62
     f70:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f72:	0e 94 95 14 	call	0x292a	; 0x292a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f76:	a0 91 e4 02 	lds	r26, 0x02E4
     f7a:	b0 91 e5 02 	lds	r27, 0x02E5
     f7e:	cd 91       	ld	r28, X+
     f80:	cd bf       	out	0x3d, r28	; 61
     f82:	dd 91       	ld	r29, X+
     f84:	de bf       	out	0x3e, r29	; 62
     f86:	ff 91       	pop	r31
     f88:	ef 91       	pop	r30
     f8a:	df 91       	pop	r29
     f8c:	cf 91       	pop	r28
     f8e:	bf 91       	pop	r27
     f90:	af 91       	pop	r26
     f92:	9f 91       	pop	r25
     f94:	8f 91       	pop	r24
     f96:	7f 91       	pop	r23
     f98:	6f 91       	pop	r22
     f9a:	5f 91       	pop	r21
     f9c:	4f 91       	pop	r20
     f9e:	3f 91       	pop	r19
     fa0:	2f 91       	pop	r18
     fa2:	1f 91       	pop	r17
     fa4:	0f 91       	pop	r16
     fa6:	ff 90       	pop	r15
     fa8:	ef 90       	pop	r14
     faa:	df 90       	pop	r13
     fac:	cf 90       	pop	r12
     fae:	bf 90       	pop	r11
     fb0:	af 90       	pop	r10
     fb2:	9f 90       	pop	r9
     fb4:	8f 90       	pop	r8
     fb6:	7f 90       	pop	r7
     fb8:	6f 90       	pop	r6
     fba:	5f 90       	pop	r5
     fbc:	4f 90       	pop	r4
     fbe:	3f 90       	pop	r3
     fc0:	2f 90       	pop	r2
     fc2:	1f 90       	pop	r1
     fc4:	0f 90       	pop	r0
     fc6:	0f be       	out	0x3f, r0	; 63
     fc8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     fca:	08 95       	ret

00000fcc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     fcc:	0f 92       	push	r0
     fce:	0f b6       	in	r0, 0x3f	; 63
     fd0:	f8 94       	cli
     fd2:	0f 92       	push	r0
     fd4:	1f 92       	push	r1
     fd6:	11 24       	eor	r1, r1
     fd8:	2f 92       	push	r2
     fda:	3f 92       	push	r3
     fdc:	4f 92       	push	r4
     fde:	5f 92       	push	r5
     fe0:	6f 92       	push	r6
     fe2:	7f 92       	push	r7
     fe4:	8f 92       	push	r8
     fe6:	9f 92       	push	r9
     fe8:	af 92       	push	r10
     fea:	bf 92       	push	r11
     fec:	cf 92       	push	r12
     fee:	df 92       	push	r13
     ff0:	ef 92       	push	r14
     ff2:	ff 92       	push	r15
     ff4:	0f 93       	push	r16
     ff6:	1f 93       	push	r17
     ff8:	2f 93       	push	r18
     ffa:	3f 93       	push	r19
     ffc:	4f 93       	push	r20
     ffe:	5f 93       	push	r21
    1000:	6f 93       	push	r22
    1002:	7f 93       	push	r23
    1004:	8f 93       	push	r24
    1006:	9f 93       	push	r25
    1008:	af 93       	push	r26
    100a:	bf 93       	push	r27
    100c:	cf 93       	push	r28
    100e:	df 93       	push	r29
    1010:	ef 93       	push	r30
    1012:	ff 93       	push	r31
    1014:	a0 91 e4 02 	lds	r26, 0x02E4
    1018:	b0 91 e5 02 	lds	r27, 0x02E5
    101c:	0d b6       	in	r0, 0x3d	; 61
    101e:	0d 92       	st	X+, r0
    1020:	0e b6       	in	r0, 0x3e	; 62
    1022:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1024:	0e 94 b0 13 	call	0x2760	; 0x2760 <xTaskIncrementTick>
    1028:	88 23       	and	r24, r24
    102a:	11 f0       	breq	.+4      	; 0x1030 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    102c:	0e 94 95 14 	call	0x292a	; 0x292a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1030:	a0 91 e4 02 	lds	r26, 0x02E4
    1034:	b0 91 e5 02 	lds	r27, 0x02E5
    1038:	cd 91       	ld	r28, X+
    103a:	cd bf       	out	0x3d, r28	; 61
    103c:	dd 91       	ld	r29, X+
    103e:	de bf       	out	0x3e, r29	; 62
    1040:	ff 91       	pop	r31
    1042:	ef 91       	pop	r30
    1044:	df 91       	pop	r29
    1046:	cf 91       	pop	r28
    1048:	bf 91       	pop	r27
    104a:	af 91       	pop	r26
    104c:	9f 91       	pop	r25
    104e:	8f 91       	pop	r24
    1050:	7f 91       	pop	r23
    1052:	6f 91       	pop	r22
    1054:	5f 91       	pop	r21
    1056:	4f 91       	pop	r20
    1058:	3f 91       	pop	r19
    105a:	2f 91       	pop	r18
    105c:	1f 91       	pop	r17
    105e:	0f 91       	pop	r16
    1060:	ff 90       	pop	r15
    1062:	ef 90       	pop	r14
    1064:	df 90       	pop	r13
    1066:	cf 90       	pop	r12
    1068:	bf 90       	pop	r11
    106a:	af 90       	pop	r10
    106c:	9f 90       	pop	r9
    106e:	8f 90       	pop	r8
    1070:	7f 90       	pop	r7
    1072:	6f 90       	pop	r6
    1074:	5f 90       	pop	r5
    1076:	4f 90       	pop	r4
    1078:	3f 90       	pop	r3
    107a:	2f 90       	pop	r2
    107c:	1f 90       	pop	r1
    107e:	0f 90       	pop	r0
    1080:	0f be       	out	0x3f, r0	; 63
    1082:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1084:	08 95       	ret

00001086 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1086:	df 93       	push	r29
    1088:	cf 93       	push	r28
    108a:	00 d0       	rcall	.+0      	; 0x108c <prvSetupTimerInterrupt+0x6>
    108c:	00 d0       	rcall	.+0      	; 0x108e <prvSetupTimerInterrupt+0x8>
    108e:	00 d0       	rcall	.+0      	; 0x1090 <prvSetupTimerInterrupt+0xa>
    1090:	cd b7       	in	r28, 0x3d	; 61
    1092:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1094:	80 e4       	ldi	r24, 0x40	; 64
    1096:	9f e1       	ldi	r25, 0x1F	; 31
    1098:	a0 e0       	ldi	r26, 0x00	; 0
    109a:	b0 e0       	ldi	r27, 0x00	; 0
    109c:	8b 83       	std	Y+3, r24	; 0x03
    109e:	9c 83       	std	Y+4, r25	; 0x04
    10a0:	ad 83       	std	Y+5, r26	; 0x05
    10a2:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    10a4:	8b 81       	ldd	r24, Y+3	; 0x03
    10a6:	9c 81       	ldd	r25, Y+4	; 0x04
    10a8:	ad 81       	ldd	r26, Y+5	; 0x05
    10aa:	be 81       	ldd	r27, Y+6	; 0x06
    10ac:	68 94       	set
    10ae:	15 f8       	bld	r1, 5
    10b0:	b6 95       	lsr	r27
    10b2:	a7 95       	ror	r26
    10b4:	97 95       	ror	r25
    10b6:	87 95       	ror	r24
    10b8:	16 94       	lsr	r1
    10ba:	d1 f7       	brne	.-12     	; 0x10b0 <prvSetupTimerInterrupt+0x2a>
    10bc:	8b 83       	std	Y+3, r24	; 0x03
    10be:	9c 83       	std	Y+4, r25	; 0x04
    10c0:	ad 83       	std	Y+5, r26	; 0x05
    10c2:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    10c4:	8b 81       	ldd	r24, Y+3	; 0x03
    10c6:	9c 81       	ldd	r25, Y+4	; 0x04
    10c8:	ad 81       	ldd	r26, Y+5	; 0x05
    10ca:	be 81       	ldd	r27, Y+6	; 0x06
    10cc:	01 97       	sbiw	r24, 0x01	; 1
    10ce:	a1 09       	sbc	r26, r1
    10d0:	b1 09       	sbc	r27, r1
    10d2:	8b 83       	std	Y+3, r24	; 0x03
    10d4:	9c 83       	std	Y+4, r25	; 0x04
    10d6:	ad 83       	std	Y+5, r26	; 0x05
    10d8:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    10da:	8b 81       	ldd	r24, Y+3	; 0x03
    10dc:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    10de:	8b 81       	ldd	r24, Y+3	; 0x03
    10e0:	9c 81       	ldd	r25, Y+4	; 0x04
    10e2:	ad 81       	ldd	r26, Y+5	; 0x05
    10e4:	be 81       	ldd	r27, Y+6	; 0x06
    10e6:	89 2f       	mov	r24, r25
    10e8:	9a 2f       	mov	r25, r26
    10ea:	ab 2f       	mov	r26, r27
    10ec:	bb 27       	eor	r27, r27
    10ee:	8b 83       	std	Y+3, r24	; 0x03
    10f0:	9c 83       	std	Y+4, r25	; 0x04
    10f2:	ad 83       	std	Y+5, r26	; 0x05
    10f4:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    10f6:	8b 81       	ldd	r24, Y+3	; 0x03
    10f8:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    10fa:	eb e4       	ldi	r30, 0x4B	; 75
    10fc:	f0 e0       	ldi	r31, 0x00	; 0
    10fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1100:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1102:	ea e4       	ldi	r30, 0x4A	; 74
    1104:	f0 e0       	ldi	r31, 0x00	; 0
    1106:	89 81       	ldd	r24, Y+1	; 0x01
    1108:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    110a:	8b e0       	ldi	r24, 0x0B	; 11
    110c:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    110e:	ee e4       	ldi	r30, 0x4E	; 78
    1110:	f0 e0       	ldi	r31, 0x00	; 0
    1112:	89 81       	ldd	r24, Y+1	; 0x01
    1114:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1116:	e9 e5       	ldi	r30, 0x59	; 89
    1118:	f0 e0       	ldi	r31, 0x00	; 0
    111a:	80 81       	ld	r24, Z
    111c:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    111e:	89 81       	ldd	r24, Y+1	; 0x01
    1120:	80 61       	ori	r24, 0x10	; 16
    1122:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1124:	e9 e5       	ldi	r30, 0x59	; 89
    1126:	f0 e0       	ldi	r31, 0x00	; 0
    1128:	89 81       	ldd	r24, Y+1	; 0x01
    112a:	80 83       	st	Z, r24
}
    112c:	26 96       	adiw	r28, 0x06	; 6
    112e:	0f b6       	in	r0, 0x3f	; 63
    1130:	f8 94       	cli
    1132:	de bf       	out	0x3e, r29	; 62
    1134:	0f be       	out	0x3f, r0	; 63
    1136:	cd bf       	out	0x3d, r28	; 61
    1138:	cf 91       	pop	r28
    113a:	df 91       	pop	r29
    113c:	08 95       	ret

0000113e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    113e:	0e 94 e6 07 	call	0xfcc	; 0xfcc <vPortYieldFromTick>
		asm volatile ( "reti" );
    1142:	18 95       	reti

00001144 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1144:	df 93       	push	r29
    1146:	cf 93       	push	r28
    1148:	00 d0       	rcall	.+0      	; 0x114a <xQueueGenericReset+0x6>
    114a:	00 d0       	rcall	.+0      	; 0x114c <xQueueGenericReset+0x8>
    114c:	0f 92       	push	r0
    114e:	cd b7       	in	r28, 0x3d	; 61
    1150:	de b7       	in	r29, 0x3e	; 62
    1152:	9c 83       	std	Y+4, r25	; 0x04
    1154:	8b 83       	std	Y+3, r24	; 0x03
    1156:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1158:	8b 81       	ldd	r24, Y+3	; 0x03
    115a:	9c 81       	ldd	r25, Y+4	; 0x04
    115c:	9a 83       	std	Y+2, r25	; 0x02
    115e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1160:	0f b6       	in	r0, 0x3f	; 63
    1162:	f8 94       	cli
    1164:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1166:	e9 81       	ldd	r30, Y+1	; 0x01
    1168:	fa 81       	ldd	r31, Y+2	; 0x02
    116a:	40 81       	ld	r20, Z
    116c:	51 81       	ldd	r21, Z+1	; 0x01
    116e:	e9 81       	ldd	r30, Y+1	; 0x01
    1170:	fa 81       	ldd	r31, Y+2	; 0x02
    1172:	83 8d       	ldd	r24, Z+27	; 0x1b
    1174:	28 2f       	mov	r18, r24
    1176:	30 e0       	ldi	r19, 0x00	; 0
    1178:	e9 81       	ldd	r30, Y+1	; 0x01
    117a:	fa 81       	ldd	r31, Y+2	; 0x02
    117c:	84 8d       	ldd	r24, Z+28	; 0x1c
    117e:	88 2f       	mov	r24, r24
    1180:	90 e0       	ldi	r25, 0x00	; 0
    1182:	bc 01       	movw	r22, r24
    1184:	26 9f       	mul	r18, r22
    1186:	c0 01       	movw	r24, r0
    1188:	27 9f       	mul	r18, r23
    118a:	90 0d       	add	r25, r0
    118c:	36 9f       	mul	r19, r22
    118e:	90 0d       	add	r25, r0
    1190:	11 24       	eor	r1, r1
    1192:	84 0f       	add	r24, r20
    1194:	95 1f       	adc	r25, r21
    1196:	e9 81       	ldd	r30, Y+1	; 0x01
    1198:	fa 81       	ldd	r31, Y+2	; 0x02
    119a:	95 83       	std	Z+5, r25	; 0x05
    119c:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    119e:	e9 81       	ldd	r30, Y+1	; 0x01
    11a0:	fa 81       	ldd	r31, Y+2	; 0x02
    11a2:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    11a4:	e9 81       	ldd	r30, Y+1	; 0x01
    11a6:	fa 81       	ldd	r31, Y+2	; 0x02
    11a8:	80 81       	ld	r24, Z
    11aa:	91 81       	ldd	r25, Z+1	; 0x01
    11ac:	e9 81       	ldd	r30, Y+1	; 0x01
    11ae:	fa 81       	ldd	r31, Y+2	; 0x02
    11b0:	93 83       	std	Z+3, r25	; 0x03
    11b2:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    11b4:	e9 81       	ldd	r30, Y+1	; 0x01
    11b6:	fa 81       	ldd	r31, Y+2	; 0x02
    11b8:	40 81       	ld	r20, Z
    11ba:	51 81       	ldd	r21, Z+1	; 0x01
    11bc:	e9 81       	ldd	r30, Y+1	; 0x01
    11be:	fa 81       	ldd	r31, Y+2	; 0x02
    11c0:	83 8d       	ldd	r24, Z+27	; 0x1b
    11c2:	88 2f       	mov	r24, r24
    11c4:	90 e0       	ldi	r25, 0x00	; 0
    11c6:	9c 01       	movw	r18, r24
    11c8:	21 50       	subi	r18, 0x01	; 1
    11ca:	30 40       	sbci	r19, 0x00	; 0
    11cc:	e9 81       	ldd	r30, Y+1	; 0x01
    11ce:	fa 81       	ldd	r31, Y+2	; 0x02
    11d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    11d2:	88 2f       	mov	r24, r24
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	bc 01       	movw	r22, r24
    11d8:	26 9f       	mul	r18, r22
    11da:	c0 01       	movw	r24, r0
    11dc:	27 9f       	mul	r18, r23
    11de:	90 0d       	add	r25, r0
    11e0:	36 9f       	mul	r19, r22
    11e2:	90 0d       	add	r25, r0
    11e4:	11 24       	eor	r1, r1
    11e6:	84 0f       	add	r24, r20
    11e8:	95 1f       	adc	r25, r21
    11ea:	e9 81       	ldd	r30, Y+1	; 0x01
    11ec:	fa 81       	ldd	r31, Y+2	; 0x02
    11ee:	97 83       	std	Z+7, r25	; 0x07
    11f0:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    11f2:	e9 81       	ldd	r30, Y+1	; 0x01
    11f4:	fa 81       	ldd	r31, Y+2	; 0x02
    11f6:	8f ef       	ldi	r24, 0xFF	; 255
    11f8:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    11fa:	e9 81       	ldd	r30, Y+1	; 0x01
    11fc:	fa 81       	ldd	r31, Y+2	; 0x02
    11fe:	8f ef       	ldi	r24, 0xFF	; 255
    1200:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1202:	8d 81       	ldd	r24, Y+5	; 0x05
    1204:	88 23       	and	r24, r24
    1206:	79 f4       	brne	.+30     	; 0x1226 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1208:	e9 81       	ldd	r30, Y+1	; 0x01
    120a:	fa 81       	ldd	r31, Y+2	; 0x02
    120c:	80 85       	ldd	r24, Z+8	; 0x08
    120e:	88 23       	and	r24, r24
    1210:	a1 f0       	breq	.+40     	; 0x123a <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1212:	89 81       	ldd	r24, Y+1	; 0x01
    1214:	9a 81       	ldd	r25, Y+2	; 0x02
    1216:	08 96       	adiw	r24, 0x08	; 8
    1218:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <xTaskRemoveFromEventList>
    121c:	88 23       	and	r24, r24
    121e:	69 f0       	breq	.+26     	; 0x123a <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1220:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
    1224:	0a c0       	rjmp	.+20     	; 0x123a <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1226:	89 81       	ldd	r24, Y+1	; 0x01
    1228:	9a 81       	ldd	r25, Y+2	; 0x02
    122a:	08 96       	adiw	r24, 0x08	; 8
    122c:	0e 94 98 04 	call	0x930	; 0x930 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1230:	89 81       	ldd	r24, Y+1	; 0x01
    1232:	9a 81       	ldd	r25, Y+2	; 0x02
    1234:	41 96       	adiw	r24, 0x11	; 17
    1236:	0e 94 98 04 	call	0x930	; 0x930 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    123a:	0f 90       	pop	r0
    123c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    123e:	81 e0       	ldi	r24, 0x01	; 1
}
    1240:	0f 90       	pop	r0
    1242:	0f 90       	pop	r0
    1244:	0f 90       	pop	r0
    1246:	0f 90       	pop	r0
    1248:	0f 90       	pop	r0
    124a:	cf 91       	pop	r28
    124c:	df 91       	pop	r29
    124e:	08 95       	ret

00001250 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1250:	0f 93       	push	r16
    1252:	1f 93       	push	r17
    1254:	df 93       	push	r29
    1256:	cf 93       	push	r28
    1258:	cd b7       	in	r28, 0x3d	; 61
    125a:	de b7       	in	r29, 0x3e	; 62
    125c:	29 97       	sbiw	r28, 0x09	; 9
    125e:	0f b6       	in	r0, 0x3f	; 63
    1260:	f8 94       	cli
    1262:	de bf       	out	0x3e, r29	; 62
    1264:	0f be       	out	0x3f, r0	; 63
    1266:	cd bf       	out	0x3d, r28	; 61
    1268:	8f 83       	std	Y+7, r24	; 0x07
    126a:	68 87       	std	Y+8, r22	; 0x08
    126c:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    126e:	88 85       	ldd	r24, Y+8	; 0x08
    1270:	88 23       	and	r24, r24
    1272:	19 f4       	brne	.+6      	; 0x127a <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1274:	1c 82       	std	Y+4, r1	; 0x04
    1276:	1b 82       	std	Y+3, r1	; 0x03
    1278:	10 c0       	rjmp	.+32     	; 0x129a <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    127a:	8f 81       	ldd	r24, Y+7	; 0x07
    127c:	28 2f       	mov	r18, r24
    127e:	30 e0       	ldi	r19, 0x00	; 0
    1280:	88 85       	ldd	r24, Y+8	; 0x08
    1282:	88 2f       	mov	r24, r24
    1284:	90 e0       	ldi	r25, 0x00	; 0
    1286:	ac 01       	movw	r20, r24
    1288:	24 9f       	mul	r18, r20
    128a:	c0 01       	movw	r24, r0
    128c:	25 9f       	mul	r18, r21
    128e:	90 0d       	add	r25, r0
    1290:	34 9f       	mul	r19, r20
    1292:	90 0d       	add	r25, r0
    1294:	11 24       	eor	r1, r1
    1296:	9c 83       	std	Y+4, r25	; 0x04
    1298:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    129a:	8b 81       	ldd	r24, Y+3	; 0x03
    129c:	9c 81       	ldd	r25, Y+4	; 0x04
    129e:	4f 96       	adiw	r24, 0x1f	; 31
    12a0:	0e 94 1c 04 	call	0x838	; 0x838 <pvPortMalloc>
    12a4:	9e 83       	std	Y+6, r25	; 0x06
    12a6:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    12a8:	8d 81       	ldd	r24, Y+5	; 0x05
    12aa:	9e 81       	ldd	r25, Y+6	; 0x06
    12ac:	00 97       	sbiw	r24, 0x00	; 0
    12ae:	a1 f0       	breq	.+40     	; 0x12d8 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    12b0:	8d 81       	ldd	r24, Y+5	; 0x05
    12b2:	9e 81       	ldd	r25, Y+6	; 0x06
    12b4:	9a 83       	std	Y+2, r25	; 0x02
    12b6:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    12b8:	89 81       	ldd	r24, Y+1	; 0x01
    12ba:	9a 81       	ldd	r25, Y+2	; 0x02
    12bc:	4f 96       	adiw	r24, 0x1f	; 31
    12be:	9a 83       	std	Y+2, r25	; 0x02
    12c0:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    12c2:	29 81       	ldd	r18, Y+1	; 0x01
    12c4:	3a 81       	ldd	r19, Y+2	; 0x02
    12c6:	ed 81       	ldd	r30, Y+5	; 0x05
    12c8:	fe 81       	ldd	r31, Y+6	; 0x06
    12ca:	8f 81       	ldd	r24, Y+7	; 0x07
    12cc:	68 85       	ldd	r22, Y+8	; 0x08
    12ce:	a9 01       	movw	r20, r18
    12d0:	29 85       	ldd	r18, Y+9	; 0x09
    12d2:	8f 01       	movw	r16, r30
    12d4:	0e 94 79 09 	call	0x12f2	; 0x12f2 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    12d8:	8d 81       	ldd	r24, Y+5	; 0x05
    12da:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    12dc:	29 96       	adiw	r28, 0x09	; 9
    12de:	0f b6       	in	r0, 0x3f	; 63
    12e0:	f8 94       	cli
    12e2:	de bf       	out	0x3e, r29	; 62
    12e4:	0f be       	out	0x3f, r0	; 63
    12e6:	cd bf       	out	0x3d, r28	; 61
    12e8:	cf 91       	pop	r28
    12ea:	df 91       	pop	r29
    12ec:	1f 91       	pop	r17
    12ee:	0f 91       	pop	r16
    12f0:	08 95       	ret

000012f2 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    12f2:	0f 93       	push	r16
    12f4:	1f 93       	push	r17
    12f6:	df 93       	push	r29
    12f8:	cf 93       	push	r28
    12fa:	cd b7       	in	r28, 0x3d	; 61
    12fc:	de b7       	in	r29, 0x3e	; 62
    12fe:	27 97       	sbiw	r28, 0x07	; 7
    1300:	0f b6       	in	r0, 0x3f	; 63
    1302:	f8 94       	cli
    1304:	de bf       	out	0x3e, r29	; 62
    1306:	0f be       	out	0x3f, r0	; 63
    1308:	cd bf       	out	0x3d, r28	; 61
    130a:	89 83       	std	Y+1, r24	; 0x01
    130c:	6a 83       	std	Y+2, r22	; 0x02
    130e:	5c 83       	std	Y+4, r21	; 0x04
    1310:	4b 83       	std	Y+3, r20	; 0x03
    1312:	2d 83       	std	Y+5, r18	; 0x05
    1314:	1f 83       	std	Y+7, r17	; 0x07
    1316:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1318:	8a 81       	ldd	r24, Y+2	; 0x02
    131a:	88 23       	and	r24, r24
    131c:	39 f4       	brne	.+14     	; 0x132c <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    131e:	8e 81       	ldd	r24, Y+6	; 0x06
    1320:	9f 81       	ldd	r25, Y+7	; 0x07
    1322:	ee 81       	ldd	r30, Y+6	; 0x06
    1324:	ff 81       	ldd	r31, Y+7	; 0x07
    1326:	91 83       	std	Z+1, r25	; 0x01
    1328:	80 83       	st	Z, r24
    132a:	06 c0       	rjmp	.+12     	; 0x1338 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    132c:	8b 81       	ldd	r24, Y+3	; 0x03
    132e:	9c 81       	ldd	r25, Y+4	; 0x04
    1330:	ee 81       	ldd	r30, Y+6	; 0x06
    1332:	ff 81       	ldd	r31, Y+7	; 0x07
    1334:	91 83       	std	Z+1, r25	; 0x01
    1336:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1338:	ee 81       	ldd	r30, Y+6	; 0x06
    133a:	ff 81       	ldd	r31, Y+7	; 0x07
    133c:	89 81       	ldd	r24, Y+1	; 0x01
    133e:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1340:	ee 81       	ldd	r30, Y+6	; 0x06
    1342:	ff 81       	ldd	r31, Y+7	; 0x07
    1344:	8a 81       	ldd	r24, Y+2	; 0x02
    1346:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1348:	8e 81       	ldd	r24, Y+6	; 0x06
    134a:	9f 81       	ldd	r25, Y+7	; 0x07
    134c:	61 e0       	ldi	r22, 0x01	; 1
    134e:	0e 94 a2 08 	call	0x1144	; 0x1144 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1352:	27 96       	adiw	r28, 0x07	; 7
    1354:	0f b6       	in	r0, 0x3f	; 63
    1356:	f8 94       	cli
    1358:	de bf       	out	0x3e, r29	; 62
    135a:	0f be       	out	0x3f, r0	; 63
    135c:	cd bf       	out	0x3d, r28	; 61
    135e:	cf 91       	pop	r28
    1360:	df 91       	pop	r29
    1362:	1f 91       	pop	r17
    1364:	0f 91       	pop	r16
    1366:	08 95       	ret

00001368 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1368:	df 93       	push	r29
    136a:	cf 93       	push	r28
    136c:	cd b7       	in	r28, 0x3d	; 61
    136e:	de b7       	in	r29, 0x3e	; 62
    1370:	2f 97       	sbiw	r28, 0x0f	; 15
    1372:	0f b6       	in	r0, 0x3f	; 63
    1374:	f8 94       	cli
    1376:	de bf       	out	0x3e, r29	; 62
    1378:	0f be       	out	0x3f, r0	; 63
    137a:	cd bf       	out	0x3d, r28	; 61
    137c:	99 87       	std	Y+9, r25	; 0x09
    137e:	88 87       	std	Y+8, r24	; 0x08
    1380:	7b 87       	std	Y+11, r23	; 0x0b
    1382:	6a 87       	std	Y+10, r22	; 0x0a
    1384:	5d 87       	std	Y+13, r21	; 0x0d
    1386:	4c 87       	std	Y+12, r20	; 0x0c
    1388:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    138a:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    138c:	88 85       	ldd	r24, Y+8	; 0x08
    138e:	99 85       	ldd	r25, Y+9	; 0x09
    1390:	9a 83       	std	Y+2, r25	; 0x02
    1392:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1394:	0f b6       	in	r0, 0x3f	; 63
    1396:	f8 94       	cli
    1398:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    139a:	e9 81       	ldd	r30, Y+1	; 0x01
    139c:	fa 81       	ldd	r31, Y+2	; 0x02
    139e:	92 8d       	ldd	r25, Z+26	; 0x1a
    13a0:	e9 81       	ldd	r30, Y+1	; 0x01
    13a2:	fa 81       	ldd	r31, Y+2	; 0x02
    13a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    13a6:	98 17       	cp	r25, r24
    13a8:	18 f0       	brcs	.+6      	; 0x13b0 <xQueueGenericSend+0x48>
    13aa:	8e 85       	ldd	r24, Y+14	; 0x0e
    13ac:	82 30       	cpi	r24, 0x02	; 2
    13ae:	11 f5       	brne	.+68     	; 0x13f4 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13b0:	89 81       	ldd	r24, Y+1	; 0x01
    13b2:	9a 81       	ldd	r25, Y+2	; 0x02
    13b4:	2a 85       	ldd	r18, Y+10	; 0x0a
    13b6:	3b 85       	ldd	r19, Y+11	; 0x0b
    13b8:	b9 01       	movw	r22, r18
    13ba:	4e 85       	ldd	r20, Y+14	; 0x0e
    13bc:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <prvCopyDataToQueue>
    13c0:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13c2:	e9 81       	ldd	r30, Y+1	; 0x01
    13c4:	fa 81       	ldd	r31, Y+2	; 0x02
    13c6:	81 89       	ldd	r24, Z+17	; 0x11
    13c8:	88 23       	and	r24, r24
    13ca:	51 f0       	breq	.+20     	; 0x13e0 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13cc:	89 81       	ldd	r24, Y+1	; 0x01
    13ce:	9a 81       	ldd	r25, Y+2	; 0x02
    13d0:	41 96       	adiw	r24, 0x11	; 17
    13d2:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <xTaskRemoveFromEventList>
    13d6:	88 23       	and	r24, r24
    13d8:	41 f0       	breq	.+16     	; 0x13ea <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    13da:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
    13de:	05 c0       	rjmp	.+10     	; 0x13ea <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    13e0:	8b 81       	ldd	r24, Y+3	; 0x03
    13e2:	88 23       	and	r24, r24
    13e4:	11 f0       	breq	.+4      	; 0x13ea <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    13e6:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    13ea:	0f 90       	pop	r0
    13ec:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    13ee:	81 e0       	ldi	r24, 0x01	; 1
    13f0:	8f 87       	std	Y+15, r24	; 0x0f
    13f2:	5c c0       	rjmp	.+184    	; 0x14ac <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    13f4:	8c 85       	ldd	r24, Y+12	; 0x0c
    13f6:	9d 85       	ldd	r25, Y+13	; 0x0d
    13f8:	00 97       	sbiw	r24, 0x00	; 0
    13fa:	21 f4       	brne	.+8      	; 0x1404 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    13fc:	0f 90       	pop	r0
    13fe:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1400:	1f 86       	std	Y+15, r1	; 0x0f
    1402:	54 c0       	rjmp	.+168    	; 0x14ac <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1404:	8c 81       	ldd	r24, Y+4	; 0x04
    1406:	88 23       	and	r24, r24
    1408:	31 f4       	brne	.+12     	; 0x1416 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    140a:	ce 01       	movw	r24, r28
    140c:	05 96       	adiw	r24, 0x05	; 5
    140e:	0e 94 3a 16 	call	0x2c74	; 0x2c74 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1416:	0f 90       	pop	r0
    1418:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    141a:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    141e:	0f b6       	in	r0, 0x3f	; 63
    1420:	f8 94       	cli
    1422:	0f 92       	push	r0
    1424:	e9 81       	ldd	r30, Y+1	; 0x01
    1426:	fa 81       	ldd	r31, Y+2	; 0x02
    1428:	85 8d       	ldd	r24, Z+29	; 0x1d
    142a:	8f 3f       	cpi	r24, 0xFF	; 255
    142c:	19 f4       	brne	.+6      	; 0x1434 <xQueueGenericSend+0xcc>
    142e:	e9 81       	ldd	r30, Y+1	; 0x01
    1430:	fa 81       	ldd	r31, Y+2	; 0x02
    1432:	15 8e       	std	Z+29, r1	; 0x1d
    1434:	e9 81       	ldd	r30, Y+1	; 0x01
    1436:	fa 81       	ldd	r31, Y+2	; 0x02
    1438:	86 8d       	ldd	r24, Z+30	; 0x1e
    143a:	8f 3f       	cpi	r24, 0xFF	; 255
    143c:	19 f4       	brne	.+6      	; 0x1444 <xQueueGenericSend+0xdc>
    143e:	e9 81       	ldd	r30, Y+1	; 0x01
    1440:	fa 81       	ldd	r31, Y+2	; 0x02
    1442:	16 8e       	std	Z+30, r1	; 0x1e
    1444:	0f 90       	pop	r0
    1446:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1448:	ce 01       	movw	r24, r28
    144a:	05 96       	adiw	r24, 0x05	; 5
    144c:	9e 01       	movw	r18, r28
    144e:	24 5f       	subi	r18, 0xF4	; 244
    1450:	3f 4f       	sbci	r19, 0xFF	; 255
    1452:	b9 01       	movw	r22, r18
    1454:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <xTaskCheckForTimeOut>
    1458:	88 23       	and	r24, r24
    145a:	09 f5       	brne	.+66     	; 0x149e <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    145c:	89 81       	ldd	r24, Y+1	; 0x01
    145e:	9a 81       	ldd	r25, Y+2	; 0x02
    1460:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <prvIsQueueFull>
    1464:	88 23       	and	r24, r24
    1466:	a1 f0       	breq	.+40     	; 0x1490 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1468:	89 81       	ldd	r24, Y+1	; 0x01
    146a:	9a 81       	ldd	r25, Y+2	; 0x02
    146c:	08 96       	adiw	r24, 0x08	; 8
    146e:	2c 85       	ldd	r18, Y+12	; 0x0c
    1470:	3d 85       	ldd	r19, Y+13	; 0x0d
    1472:	b9 01       	movw	r22, r18
    1474:	0e 94 02 15 	call	0x2a04	; 0x2a04 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1478:	89 81       	ldd	r24, Y+1	; 0x01
    147a:	9a 81       	ldd	r25, Y+2	; 0x02
    147c:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1480:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
    1484:	88 23       	and	r24, r24
    1486:	09 f0       	breq	.+2      	; 0x148a <xQueueGenericSend+0x122>
    1488:	85 cf       	rjmp	.-246    	; 0x1394 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    148a:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
    148e:	82 cf       	rjmp	.-252    	; 0x1394 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1490:	89 81       	ldd	r24, Y+1	; 0x01
    1492:	9a 81       	ldd	r25, Y+2	; 0x02
    1494:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1498:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
    149c:	7b cf       	rjmp	.-266    	; 0x1394 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    149e:	89 81       	ldd	r24, Y+1	; 0x01
    14a0:	9a 81       	ldd	r25, Y+2	; 0x02
    14a2:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14a6:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    14aa:	1f 86       	std	Y+15, r1	; 0x0f
    14ac:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    14ae:	2f 96       	adiw	r28, 0x0f	; 15
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	de bf       	out	0x3e, r29	; 62
    14b6:	0f be       	out	0x3f, r0	; 63
    14b8:	cd bf       	out	0x3d, r28	; 61
    14ba:	cf 91       	pop	r28
    14bc:	df 91       	pop	r29
    14be:	08 95       	ret

000014c0 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    14c0:	df 93       	push	r29
    14c2:	cf 93       	push	r28
    14c4:	cd b7       	in	r28, 0x3d	; 61
    14c6:	de b7       	in	r29, 0x3e	; 62
    14c8:	2c 97       	sbiw	r28, 0x0c	; 12
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	de bf       	out	0x3e, r29	; 62
    14d0:	0f be       	out	0x3f, r0	; 63
    14d2:	cd bf       	out	0x3d, r28	; 61
    14d4:	9f 83       	std	Y+7, r25	; 0x07
    14d6:	8e 83       	std	Y+6, r24	; 0x06
    14d8:	79 87       	std	Y+9, r23	; 0x09
    14da:	68 87       	std	Y+8, r22	; 0x08
    14dc:	5b 87       	std	Y+11, r21	; 0x0b
    14de:	4a 87       	std	Y+10, r20	; 0x0a
    14e0:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    14e2:	8e 81       	ldd	r24, Y+6	; 0x06
    14e4:	9f 81       	ldd	r25, Y+7	; 0x07
    14e6:	9b 83       	std	Y+3, r25	; 0x03
    14e8:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    14ea:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    14ec:	ea 81       	ldd	r30, Y+2	; 0x02
    14ee:	fb 81       	ldd	r31, Y+3	; 0x03
    14f0:	92 8d       	ldd	r25, Z+26	; 0x1a
    14f2:	ea 81       	ldd	r30, Y+2	; 0x02
    14f4:	fb 81       	ldd	r31, Y+3	; 0x03
    14f6:	83 8d       	ldd	r24, Z+27	; 0x1b
    14f8:	98 17       	cp	r25, r24
    14fa:	18 f0       	brcs	.+6      	; 0x1502 <xQueueGenericSendFromISR+0x42>
    14fc:	8c 85       	ldd	r24, Y+12	; 0x0c
    14fe:	82 30       	cpi	r24, 0x02	; 2
    1500:	61 f5       	brne	.+88     	; 0x155a <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1502:	ea 81       	ldd	r30, Y+2	; 0x02
    1504:	fb 81       	ldd	r31, Y+3	; 0x03
    1506:	86 8d       	ldd	r24, Z+30	; 0x1e
    1508:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    150a:	8a 81       	ldd	r24, Y+2	; 0x02
    150c:	9b 81       	ldd	r25, Y+3	; 0x03
    150e:	28 85       	ldd	r18, Y+8	; 0x08
    1510:	39 85       	ldd	r19, Y+9	; 0x09
    1512:	b9 01       	movw	r22, r18
    1514:	4c 85       	ldd	r20, Y+12	; 0x0c
    1516:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    151a:	89 81       	ldd	r24, Y+1	; 0x01
    151c:	8f 3f       	cpi	r24, 0xFF	; 255
    151e:	a9 f4       	brne	.+42     	; 0x154a <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1520:	ea 81       	ldd	r30, Y+2	; 0x02
    1522:	fb 81       	ldd	r31, Y+3	; 0x03
    1524:	81 89       	ldd	r24, Z+17	; 0x11
    1526:	88 23       	and	r24, r24
    1528:	a9 f0       	breq	.+42     	; 0x1554 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    152a:	8a 81       	ldd	r24, Y+2	; 0x02
    152c:	9b 81       	ldd	r25, Y+3	; 0x03
    152e:	41 96       	adiw	r24, 0x11	; 17
    1530:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <xTaskRemoveFromEventList>
    1534:	88 23       	and	r24, r24
    1536:	71 f0       	breq	.+28     	; 0x1554 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1538:	8a 85       	ldd	r24, Y+10	; 0x0a
    153a:	9b 85       	ldd	r25, Y+11	; 0x0b
    153c:	00 97       	sbiw	r24, 0x00	; 0
    153e:	51 f0       	breq	.+20     	; 0x1554 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1540:	ea 85       	ldd	r30, Y+10	; 0x0a
    1542:	fb 85       	ldd	r31, Y+11	; 0x0b
    1544:	81 e0       	ldi	r24, 0x01	; 1
    1546:	80 83       	st	Z, r24
    1548:	05 c0       	rjmp	.+10     	; 0x1554 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    154a:	89 81       	ldd	r24, Y+1	; 0x01
    154c:	8f 5f       	subi	r24, 0xFF	; 255
    154e:	ea 81       	ldd	r30, Y+2	; 0x02
    1550:	fb 81       	ldd	r31, Y+3	; 0x03
    1552:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1554:	81 e0       	ldi	r24, 0x01	; 1
    1556:	8d 83       	std	Y+5, r24	; 0x05
    1558:	01 c0       	rjmp	.+2      	; 0x155c <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    155a:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    155c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    155e:	2c 96       	adiw	r28, 0x0c	; 12
    1560:	0f b6       	in	r0, 0x3f	; 63
    1562:	f8 94       	cli
    1564:	de bf       	out	0x3e, r29	; 62
    1566:	0f be       	out	0x3f, r0	; 63
    1568:	cd bf       	out	0x3d, r28	; 61
    156a:	cf 91       	pop	r28
    156c:	df 91       	pop	r29
    156e:	08 95       	ret

00001570 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1570:	df 93       	push	r29
    1572:	cf 93       	push	r28
    1574:	cd b7       	in	r28, 0x3d	; 61
    1576:	de b7       	in	r29, 0x3e	; 62
    1578:	2a 97       	sbiw	r28, 0x0a	; 10
    157a:	0f b6       	in	r0, 0x3f	; 63
    157c:	f8 94       	cli
    157e:	de bf       	out	0x3e, r29	; 62
    1580:	0f be       	out	0x3f, r0	; 63
    1582:	cd bf       	out	0x3d, r28	; 61
    1584:	98 87       	std	Y+8, r25	; 0x08
    1586:	8f 83       	std	Y+7, r24	; 0x07
    1588:	7a 87       	std	Y+10, r23	; 0x0a
    158a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    158c:	8f 81       	ldd	r24, Y+7	; 0x07
    158e:	98 85       	ldd	r25, Y+8	; 0x08
    1590:	9c 83       	std	Y+4, r25	; 0x04
    1592:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1594:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1596:	eb 81       	ldd	r30, Y+3	; 0x03
    1598:	fc 81       	ldd	r31, Y+4	; 0x04
    159a:	82 8d       	ldd	r24, Z+26	; 0x1a
    159c:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    159e:	eb 81       	ldd	r30, Y+3	; 0x03
    15a0:	fc 81       	ldd	r31, Y+4	; 0x04
    15a2:	93 8d       	ldd	r25, Z+27	; 0x1b
    15a4:	8a 81       	ldd	r24, Y+2	; 0x02
    15a6:	89 17       	cp	r24, r25
    15a8:	48 f5       	brcc	.+82     	; 0x15fc <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    15aa:	eb 81       	ldd	r30, Y+3	; 0x03
    15ac:	fc 81       	ldd	r31, Y+4	; 0x04
    15ae:	86 8d       	ldd	r24, Z+30	; 0x1e
    15b0:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    15b2:	8a 81       	ldd	r24, Y+2	; 0x02
    15b4:	8f 5f       	subi	r24, 0xFF	; 255
    15b6:	eb 81       	ldd	r30, Y+3	; 0x03
    15b8:	fc 81       	ldd	r31, Y+4	; 0x04
    15ba:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    15bc:	89 81       	ldd	r24, Y+1	; 0x01
    15be:	8f 3f       	cpi	r24, 0xFF	; 255
    15c0:	a9 f4       	brne	.+42     	; 0x15ec <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15c2:	eb 81       	ldd	r30, Y+3	; 0x03
    15c4:	fc 81       	ldd	r31, Y+4	; 0x04
    15c6:	81 89       	ldd	r24, Z+17	; 0x11
    15c8:	88 23       	and	r24, r24
    15ca:	a9 f0       	breq	.+42     	; 0x15f6 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15cc:	8b 81       	ldd	r24, Y+3	; 0x03
    15ce:	9c 81       	ldd	r25, Y+4	; 0x04
    15d0:	41 96       	adiw	r24, 0x11	; 17
    15d2:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <xTaskRemoveFromEventList>
    15d6:	88 23       	and	r24, r24
    15d8:	71 f0       	breq	.+28     	; 0x15f6 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    15da:	89 85       	ldd	r24, Y+9	; 0x09
    15dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    15de:	00 97       	sbiw	r24, 0x00	; 0
    15e0:	51 f0       	breq	.+20     	; 0x15f6 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    15e2:	e9 85       	ldd	r30, Y+9	; 0x09
    15e4:	fa 85       	ldd	r31, Y+10	; 0x0a
    15e6:	81 e0       	ldi	r24, 0x01	; 1
    15e8:	80 83       	st	Z, r24
    15ea:	05 c0       	rjmp	.+10     	; 0x15f6 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    15ec:	89 81       	ldd	r24, Y+1	; 0x01
    15ee:	8f 5f       	subi	r24, 0xFF	; 255
    15f0:	eb 81       	ldd	r30, Y+3	; 0x03
    15f2:	fc 81       	ldd	r31, Y+4	; 0x04
    15f4:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    15f6:	81 e0       	ldi	r24, 0x01	; 1
    15f8:	8e 83       	std	Y+6, r24	; 0x06
    15fa:	01 c0       	rjmp	.+2      	; 0x15fe <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    15fc:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    15fe:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1600:	2a 96       	adiw	r28, 0x0a	; 10
    1602:	0f b6       	in	r0, 0x3f	; 63
    1604:	f8 94       	cli
    1606:	de bf       	out	0x3e, r29	; 62
    1608:	0f be       	out	0x3f, r0	; 63
    160a:	cd bf       	out	0x3d, r28	; 61
    160c:	cf 91       	pop	r28
    160e:	df 91       	pop	r29
    1610:	08 95       	ret

00001612 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1612:	df 93       	push	r29
    1614:	cf 93       	push	r28
    1616:	cd b7       	in	r28, 0x3d	; 61
    1618:	de b7       	in	r29, 0x3e	; 62
    161a:	2e 97       	sbiw	r28, 0x0e	; 14
    161c:	0f b6       	in	r0, 0x3f	; 63
    161e:	f8 94       	cli
    1620:	de bf       	out	0x3e, r29	; 62
    1622:	0f be       	out	0x3f, r0	; 63
    1624:	cd bf       	out	0x3d, r28	; 61
    1626:	99 87       	std	Y+9, r25	; 0x09
    1628:	88 87       	std	Y+8, r24	; 0x08
    162a:	7b 87       	std	Y+11, r23	; 0x0b
    162c:	6a 87       	std	Y+10, r22	; 0x0a
    162e:	5d 87       	std	Y+13, r21	; 0x0d
    1630:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1632:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1634:	88 85       	ldd	r24, Y+8	; 0x08
    1636:	99 85       	ldd	r25, Y+9	; 0x09
    1638:	9b 83       	std	Y+3, r25	; 0x03
    163a:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    163c:	0f b6       	in	r0, 0x3f	; 63
    163e:	f8 94       	cli
    1640:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1642:	ea 81       	ldd	r30, Y+2	; 0x02
    1644:	fb 81       	ldd	r31, Y+3	; 0x03
    1646:	82 8d       	ldd	r24, Z+26	; 0x1a
    1648:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    164a:	89 81       	ldd	r24, Y+1	; 0x01
    164c:	88 23       	and	r24, r24
    164e:	f9 f0       	breq	.+62     	; 0x168e <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1650:	8a 81       	ldd	r24, Y+2	; 0x02
    1652:	9b 81       	ldd	r25, Y+3	; 0x03
    1654:	2a 85       	ldd	r18, Y+10	; 0x0a
    1656:	3b 85       	ldd	r19, Y+11	; 0x0b
    1658:	b9 01       	movw	r22, r18
    165a:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    165e:	89 81       	ldd	r24, Y+1	; 0x01
    1660:	81 50       	subi	r24, 0x01	; 1
    1662:	ea 81       	ldd	r30, Y+2	; 0x02
    1664:	fb 81       	ldd	r31, Y+3	; 0x03
    1666:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1668:	ea 81       	ldd	r30, Y+2	; 0x02
    166a:	fb 81       	ldd	r31, Y+3	; 0x03
    166c:	80 85       	ldd	r24, Z+8	; 0x08
    166e:	88 23       	and	r24, r24
    1670:	49 f0       	breq	.+18     	; 0x1684 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1672:	8a 81       	ldd	r24, Y+2	; 0x02
    1674:	9b 81       	ldd	r25, Y+3	; 0x03
    1676:	08 96       	adiw	r24, 0x08	; 8
    1678:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <xTaskRemoveFromEventList>
    167c:	88 23       	and	r24, r24
    167e:	11 f0       	breq	.+4      	; 0x1684 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1680:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1684:	0f 90       	pop	r0
    1686:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1688:	81 e0       	ldi	r24, 0x01	; 1
    168a:	8e 87       	std	Y+14, r24	; 0x0e
    168c:	63 c0       	rjmp	.+198    	; 0x1754 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    168e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1690:	9d 85       	ldd	r25, Y+13	; 0x0d
    1692:	00 97       	sbiw	r24, 0x00	; 0
    1694:	21 f4       	brne	.+8      	; 0x169e <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1696:	0f 90       	pop	r0
    1698:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    169a:	1e 86       	std	Y+14, r1	; 0x0e
    169c:	5b c0       	rjmp	.+182    	; 0x1754 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    169e:	8c 81       	ldd	r24, Y+4	; 0x04
    16a0:	88 23       	and	r24, r24
    16a2:	31 f4       	brne	.+12     	; 0x16b0 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16a4:	ce 01       	movw	r24, r28
    16a6:	05 96       	adiw	r24, 0x05	; 5
    16a8:	0e 94 3a 16 	call	0x2c74	; 0x2c74 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16b0:	0f 90       	pop	r0
    16b2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16b4:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16b8:	0f b6       	in	r0, 0x3f	; 63
    16ba:	f8 94       	cli
    16bc:	0f 92       	push	r0
    16be:	ea 81       	ldd	r30, Y+2	; 0x02
    16c0:	fb 81       	ldd	r31, Y+3	; 0x03
    16c2:	85 8d       	ldd	r24, Z+29	; 0x1d
    16c4:	8f 3f       	cpi	r24, 0xFF	; 255
    16c6:	19 f4       	brne	.+6      	; 0x16ce <xQueueReceive+0xbc>
    16c8:	ea 81       	ldd	r30, Y+2	; 0x02
    16ca:	fb 81       	ldd	r31, Y+3	; 0x03
    16cc:	15 8e       	std	Z+29, r1	; 0x1d
    16ce:	ea 81       	ldd	r30, Y+2	; 0x02
    16d0:	fb 81       	ldd	r31, Y+3	; 0x03
    16d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    16d4:	8f 3f       	cpi	r24, 0xFF	; 255
    16d6:	19 f4       	brne	.+6      	; 0x16de <xQueueReceive+0xcc>
    16d8:	ea 81       	ldd	r30, Y+2	; 0x02
    16da:	fb 81       	ldd	r31, Y+3	; 0x03
    16dc:	16 8e       	std	Z+30, r1	; 0x1e
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16e2:	ce 01       	movw	r24, r28
    16e4:	05 96       	adiw	r24, 0x05	; 5
    16e6:	9e 01       	movw	r18, r28
    16e8:	24 5f       	subi	r18, 0xF4	; 244
    16ea:	3f 4f       	sbci	r19, 0xFF	; 255
    16ec:	b9 01       	movw	r22, r18
    16ee:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <xTaskCheckForTimeOut>
    16f2:	88 23       	and	r24, r24
    16f4:	09 f5       	brne	.+66     	; 0x1738 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16f6:	8a 81       	ldd	r24, Y+2	; 0x02
    16f8:	9b 81       	ldd	r25, Y+3	; 0x03
    16fa:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <prvIsQueueEmpty>
    16fe:	88 23       	and	r24, r24
    1700:	a1 f0       	breq	.+40     	; 0x172a <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1702:	8a 81       	ldd	r24, Y+2	; 0x02
    1704:	9b 81       	ldd	r25, Y+3	; 0x03
    1706:	41 96       	adiw	r24, 0x11	; 17
    1708:	2c 85       	ldd	r18, Y+12	; 0x0c
    170a:	3d 85       	ldd	r19, Y+13	; 0x0d
    170c:	b9 01       	movw	r22, r18
    170e:	0e 94 02 15 	call	0x2a04	; 0x2a04 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1712:	8a 81       	ldd	r24, Y+2	; 0x02
    1714:	9b 81       	ldd	r25, Y+3	; 0x03
    1716:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    171a:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
    171e:	88 23       	and	r24, r24
    1720:	09 f0       	breq	.+2      	; 0x1724 <xQueueReceive+0x112>
    1722:	8c cf       	rjmp	.-232    	; 0x163c <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1724:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
    1728:	89 cf       	rjmp	.-238    	; 0x163c <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    172a:	8a 81       	ldd	r24, Y+2	; 0x02
    172c:	9b 81       	ldd	r25, Y+3	; 0x03
    172e:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1732:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
    1736:	82 cf       	rjmp	.-252    	; 0x163c <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1738:	8a 81       	ldd	r24, Y+2	; 0x02
    173a:	9b 81       	ldd	r25, Y+3	; 0x03
    173c:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1740:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1744:	8a 81       	ldd	r24, Y+2	; 0x02
    1746:	9b 81       	ldd	r25, Y+3	; 0x03
    1748:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <prvIsQueueEmpty>
    174c:	88 23       	and	r24, r24
    174e:	09 f4       	brne	.+2      	; 0x1752 <xQueueReceive+0x140>
    1750:	75 cf       	rjmp	.-278    	; 0x163c <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1752:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1754:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1756:	2e 96       	adiw	r28, 0x0e	; 14
    1758:	0f b6       	in	r0, 0x3f	; 63
    175a:	f8 94       	cli
    175c:	de bf       	out	0x3e, r29	; 62
    175e:	0f be       	out	0x3f, r0	; 63
    1760:	cd bf       	out	0x3d, r28	; 61
    1762:	cf 91       	pop	r28
    1764:	df 91       	pop	r29
    1766:	08 95       	ret

00001768 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1768:	df 93       	push	r29
    176a:	cf 93       	push	r28
    176c:	cd b7       	in	r28, 0x3d	; 61
    176e:	de b7       	in	r29, 0x3e	; 62
    1770:	2c 97       	sbiw	r28, 0x0c	; 12
    1772:	0f b6       	in	r0, 0x3f	; 63
    1774:	f8 94       	cli
    1776:	de bf       	out	0x3e, r29	; 62
    1778:	0f be       	out	0x3f, r0	; 63
    177a:	cd bf       	out	0x3d, r28	; 61
    177c:	99 87       	std	Y+9, r25	; 0x09
    177e:	88 87       	std	Y+8, r24	; 0x08
    1780:	7b 87       	std	Y+11, r23	; 0x0b
    1782:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    1784:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1786:	88 85       	ldd	r24, Y+8	; 0x08
    1788:	99 85       	ldd	r25, Y+9	; 0x09
    178a:	9b 83       	std	Y+3, r25	; 0x03
    178c:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1794:	ea 81       	ldd	r30, Y+2	; 0x02
    1796:	fb 81       	ldd	r31, Y+3	; 0x03
    1798:	82 8d       	ldd	r24, Z+26	; 0x1a
    179a:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    179c:	89 81       	ldd	r24, Y+1	; 0x01
    179e:	88 23       	and	r24, r24
    17a0:	c1 f0       	breq	.+48     	; 0x17d2 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    17a2:	89 81       	ldd	r24, Y+1	; 0x01
    17a4:	81 50       	subi	r24, 0x01	; 1
    17a6:	ea 81       	ldd	r30, Y+2	; 0x02
    17a8:	fb 81       	ldd	r31, Y+3	; 0x03
    17aa:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17ac:	ea 81       	ldd	r30, Y+2	; 0x02
    17ae:	fb 81       	ldd	r31, Y+3	; 0x03
    17b0:	80 85       	ldd	r24, Z+8	; 0x08
    17b2:	88 23       	and	r24, r24
    17b4:	49 f0       	breq	.+18     	; 0x17c8 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17b6:	8a 81       	ldd	r24, Y+2	; 0x02
    17b8:	9b 81       	ldd	r25, Y+3	; 0x03
    17ba:	08 96       	adiw	r24, 0x08	; 8
    17bc:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <xTaskRemoveFromEventList>
    17c0:	88 23       	and	r24, r24
    17c2:	11 f0       	breq	.+4      	; 0x17c8 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    17c4:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    17c8:	0f 90       	pop	r0
    17ca:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    17cc:	81 e0       	ldi	r24, 0x01	; 1
    17ce:	8c 87       	std	Y+12, r24	; 0x0c
    17d0:	63 c0       	rjmp	.+198    	; 0x1898 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    17d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    17d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    17d6:	00 97       	sbiw	r24, 0x00	; 0
    17d8:	21 f4       	brne	.+8      	; 0x17e2 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    17da:	0f 90       	pop	r0
    17dc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    17de:	1c 86       	std	Y+12, r1	; 0x0c
    17e0:	5b c0       	rjmp	.+182    	; 0x1898 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    17e2:	8c 81       	ldd	r24, Y+4	; 0x04
    17e4:	88 23       	and	r24, r24
    17e6:	31 f4       	brne	.+12     	; 0x17f4 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    17e8:	ce 01       	movw	r24, r28
    17ea:	05 96       	adiw	r24, 0x05	; 5
    17ec:	0e 94 3a 16 	call	0x2c74	; 0x2c74 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    17f0:	81 e0       	ldi	r24, 0x01	; 1
    17f2:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    17f4:	0f 90       	pop	r0
    17f6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    17f8:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    17fc:	0f b6       	in	r0, 0x3f	; 63
    17fe:	f8 94       	cli
    1800:	0f 92       	push	r0
    1802:	ea 81       	ldd	r30, Y+2	; 0x02
    1804:	fb 81       	ldd	r31, Y+3	; 0x03
    1806:	85 8d       	ldd	r24, Z+29	; 0x1d
    1808:	8f 3f       	cpi	r24, 0xFF	; 255
    180a:	19 f4       	brne	.+6      	; 0x1812 <xQueueSemaphoreTake+0xaa>
    180c:	ea 81       	ldd	r30, Y+2	; 0x02
    180e:	fb 81       	ldd	r31, Y+3	; 0x03
    1810:	15 8e       	std	Z+29, r1	; 0x1d
    1812:	ea 81       	ldd	r30, Y+2	; 0x02
    1814:	fb 81       	ldd	r31, Y+3	; 0x03
    1816:	86 8d       	ldd	r24, Z+30	; 0x1e
    1818:	8f 3f       	cpi	r24, 0xFF	; 255
    181a:	19 f4       	brne	.+6      	; 0x1822 <xQueueSemaphoreTake+0xba>
    181c:	ea 81       	ldd	r30, Y+2	; 0x02
    181e:	fb 81       	ldd	r31, Y+3	; 0x03
    1820:	16 8e       	std	Z+30, r1	; 0x1e
    1822:	0f 90       	pop	r0
    1824:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1826:	ce 01       	movw	r24, r28
    1828:	05 96       	adiw	r24, 0x05	; 5
    182a:	9e 01       	movw	r18, r28
    182c:	26 5f       	subi	r18, 0xF6	; 246
    182e:	3f 4f       	sbci	r19, 0xFF	; 255
    1830:	b9 01       	movw	r22, r18
    1832:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <xTaskCheckForTimeOut>
    1836:	88 23       	and	r24, r24
    1838:	09 f5       	brne	.+66     	; 0x187c <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    183a:	8a 81       	ldd	r24, Y+2	; 0x02
    183c:	9b 81       	ldd	r25, Y+3	; 0x03
    183e:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <prvIsQueueEmpty>
    1842:	88 23       	and	r24, r24
    1844:	a1 f0       	breq	.+40     	; 0x186e <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1846:	8a 81       	ldd	r24, Y+2	; 0x02
    1848:	9b 81       	ldd	r25, Y+3	; 0x03
    184a:	41 96       	adiw	r24, 0x11	; 17
    184c:	2a 85       	ldd	r18, Y+10	; 0x0a
    184e:	3b 85       	ldd	r19, Y+11	; 0x0b
    1850:	b9 01       	movw	r22, r18
    1852:	0e 94 02 15 	call	0x2a04	; 0x2a04 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1856:	8a 81       	ldd	r24, Y+2	; 0x02
    1858:	9b 81       	ldd	r25, Y+3	; 0x03
    185a:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    185e:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
    1862:	88 23       	and	r24, r24
    1864:	09 f0       	breq	.+2      	; 0x1868 <xQueueSemaphoreTake+0x100>
    1866:	93 cf       	rjmp	.-218    	; 0x178e <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1868:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
    186c:	90 cf       	rjmp	.-224    	; 0x178e <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    186e:	8a 81       	ldd	r24, Y+2	; 0x02
    1870:	9b 81       	ldd	r25, Y+3	; 0x03
    1872:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1876:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
    187a:	89 cf       	rjmp	.-238    	; 0x178e <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    187c:	8a 81       	ldd	r24, Y+2	; 0x02
    187e:	9b 81       	ldd	r25, Y+3	; 0x03
    1880:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1884:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1888:	8a 81       	ldd	r24, Y+2	; 0x02
    188a:	9b 81       	ldd	r25, Y+3	; 0x03
    188c:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <prvIsQueueEmpty>
    1890:	88 23       	and	r24, r24
    1892:	09 f4       	brne	.+2      	; 0x1896 <xQueueSemaphoreTake+0x12e>
    1894:	7c cf       	rjmp	.-264    	; 0x178e <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1896:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1898:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    189a:	2c 96       	adiw	r28, 0x0c	; 12
    189c:	0f b6       	in	r0, 0x3f	; 63
    189e:	f8 94       	cli
    18a0:	de bf       	out	0x3e, r29	; 62
    18a2:	0f be       	out	0x3f, r0	; 63
    18a4:	cd bf       	out	0x3d, r28	; 61
    18a6:	cf 91       	pop	r28
    18a8:	df 91       	pop	r29
    18aa:	08 95       	ret

000018ac <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    18ac:	df 93       	push	r29
    18ae:	cf 93       	push	r28
    18b0:	cd b7       	in	r28, 0x3d	; 61
    18b2:	de b7       	in	r29, 0x3e	; 62
    18b4:	60 97       	sbiw	r28, 0x10	; 16
    18b6:	0f b6       	in	r0, 0x3f	; 63
    18b8:	f8 94       	cli
    18ba:	de bf       	out	0x3e, r29	; 62
    18bc:	0f be       	out	0x3f, r0	; 63
    18be:	cd bf       	out	0x3d, r28	; 61
    18c0:	9b 87       	std	Y+11, r25	; 0x0b
    18c2:	8a 87       	std	Y+10, r24	; 0x0a
    18c4:	7d 87       	std	Y+13, r23	; 0x0d
    18c6:	6c 87       	std	Y+12, r22	; 0x0c
    18c8:	5f 87       	std	Y+15, r21	; 0x0f
    18ca:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    18cc:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    18ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    18d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    18d2:	9b 83       	std	Y+3, r25	; 0x03
    18d4:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18d6:	0f b6       	in	r0, 0x3f	; 63
    18d8:	f8 94       	cli
    18da:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18dc:	ea 81       	ldd	r30, Y+2	; 0x02
    18de:	fb 81       	ldd	r31, Y+3	; 0x03
    18e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    18e2:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    18e4:	89 81       	ldd	r24, Y+1	; 0x01
    18e6:	88 23       	and	r24, r24
    18e8:	31 f1       	breq	.+76     	; 0x1936 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    18ea:	ea 81       	ldd	r30, Y+2	; 0x02
    18ec:	fb 81       	ldd	r31, Y+3	; 0x03
    18ee:	86 81       	ldd	r24, Z+6	; 0x06
    18f0:	97 81       	ldd	r25, Z+7	; 0x07
    18f2:	9d 83       	std	Y+5, r25	; 0x05
    18f4:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    18f6:	8a 81       	ldd	r24, Y+2	; 0x02
    18f8:	9b 81       	ldd	r25, Y+3	; 0x03
    18fa:	2c 85       	ldd	r18, Y+12	; 0x0c
    18fc:	3d 85       	ldd	r19, Y+13	; 0x0d
    18fe:	b9 01       	movw	r22, r18
    1900:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1904:	ea 81       	ldd	r30, Y+2	; 0x02
    1906:	fb 81       	ldd	r31, Y+3	; 0x03
    1908:	8c 81       	ldd	r24, Y+4	; 0x04
    190a:	9d 81       	ldd	r25, Y+5	; 0x05
    190c:	97 83       	std	Z+7, r25	; 0x07
    190e:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1910:	ea 81       	ldd	r30, Y+2	; 0x02
    1912:	fb 81       	ldd	r31, Y+3	; 0x03
    1914:	81 89       	ldd	r24, Z+17	; 0x11
    1916:	88 23       	and	r24, r24
    1918:	49 f0       	breq	.+18     	; 0x192c <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    191a:	8a 81       	ldd	r24, Y+2	; 0x02
    191c:	9b 81       	ldd	r25, Y+3	; 0x03
    191e:	41 96       	adiw	r24, 0x11	; 17
    1920:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <xTaskRemoveFromEventList>
    1924:	88 23       	and	r24, r24
    1926:	11 f0       	breq	.+4      	; 0x192c <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1928:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    192c:	0f 90       	pop	r0
    192e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1930:	81 e0       	ldi	r24, 0x01	; 1
    1932:	88 8b       	std	Y+16, r24	; 0x10
    1934:	63 c0       	rjmp	.+198    	; 0x19fc <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1936:	8e 85       	ldd	r24, Y+14	; 0x0e
    1938:	9f 85       	ldd	r25, Y+15	; 0x0f
    193a:	00 97       	sbiw	r24, 0x00	; 0
    193c:	21 f4       	brne	.+8      	; 0x1946 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    193e:	0f 90       	pop	r0
    1940:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1942:	18 8a       	std	Y+16, r1	; 0x10
    1944:	5b c0       	rjmp	.+182    	; 0x19fc <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1946:	8e 81       	ldd	r24, Y+6	; 0x06
    1948:	88 23       	and	r24, r24
    194a:	31 f4       	brne	.+12     	; 0x1958 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    194c:	ce 01       	movw	r24, r28
    194e:	07 96       	adiw	r24, 0x07	; 7
    1950:	0e 94 3a 16 	call	0x2c74	; 0x2c74 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1954:	81 e0       	ldi	r24, 0x01	; 1
    1956:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1958:	0f 90       	pop	r0
    195a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    195c:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1960:	0f b6       	in	r0, 0x3f	; 63
    1962:	f8 94       	cli
    1964:	0f 92       	push	r0
    1966:	ea 81       	ldd	r30, Y+2	; 0x02
    1968:	fb 81       	ldd	r31, Y+3	; 0x03
    196a:	85 8d       	ldd	r24, Z+29	; 0x1d
    196c:	8f 3f       	cpi	r24, 0xFF	; 255
    196e:	19 f4       	brne	.+6      	; 0x1976 <xQueuePeek+0xca>
    1970:	ea 81       	ldd	r30, Y+2	; 0x02
    1972:	fb 81       	ldd	r31, Y+3	; 0x03
    1974:	15 8e       	std	Z+29, r1	; 0x1d
    1976:	ea 81       	ldd	r30, Y+2	; 0x02
    1978:	fb 81       	ldd	r31, Y+3	; 0x03
    197a:	86 8d       	ldd	r24, Z+30	; 0x1e
    197c:	8f 3f       	cpi	r24, 0xFF	; 255
    197e:	19 f4       	brne	.+6      	; 0x1986 <xQueuePeek+0xda>
    1980:	ea 81       	ldd	r30, Y+2	; 0x02
    1982:	fb 81       	ldd	r31, Y+3	; 0x03
    1984:	16 8e       	std	Z+30, r1	; 0x1e
    1986:	0f 90       	pop	r0
    1988:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    198a:	ce 01       	movw	r24, r28
    198c:	07 96       	adiw	r24, 0x07	; 7
    198e:	9e 01       	movw	r18, r28
    1990:	22 5f       	subi	r18, 0xF2	; 242
    1992:	3f 4f       	sbci	r19, 0xFF	; 255
    1994:	b9 01       	movw	r22, r18
    1996:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <xTaskCheckForTimeOut>
    199a:	88 23       	and	r24, r24
    199c:	09 f5       	brne	.+66     	; 0x19e0 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    199e:	8a 81       	ldd	r24, Y+2	; 0x02
    19a0:	9b 81       	ldd	r25, Y+3	; 0x03
    19a2:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <prvIsQueueEmpty>
    19a6:	88 23       	and	r24, r24
    19a8:	a1 f0       	breq	.+40     	; 0x19d2 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19aa:	8a 81       	ldd	r24, Y+2	; 0x02
    19ac:	9b 81       	ldd	r25, Y+3	; 0x03
    19ae:	41 96       	adiw	r24, 0x11	; 17
    19b0:	2e 85       	ldd	r18, Y+14	; 0x0e
    19b2:	3f 85       	ldd	r19, Y+15	; 0x0f
    19b4:	b9 01       	movw	r22, r18
    19b6:	0e 94 02 15 	call	0x2a04	; 0x2a04 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    19ba:	8a 81       	ldd	r24, Y+2	; 0x02
    19bc:	9b 81       	ldd	r25, Y+3	; 0x03
    19be:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    19c2:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
    19c6:	88 23       	and	r24, r24
    19c8:	09 f0       	breq	.+2      	; 0x19cc <xQueuePeek+0x120>
    19ca:	85 cf       	rjmp	.-246    	; 0x18d6 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    19cc:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
    19d0:	82 cf       	rjmp	.-252    	; 0x18d6 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    19d2:	8a 81       	ldd	r24, Y+2	; 0x02
    19d4:	9b 81       	ldd	r25, Y+3	; 0x03
    19d6:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19da:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
    19de:	7b cf       	rjmp	.-266    	; 0x18d6 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    19e0:	8a 81       	ldd	r24, Y+2	; 0x02
    19e2:	9b 81       	ldd	r25, Y+3	; 0x03
    19e4:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19e8:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    19ec:	8a 81       	ldd	r24, Y+2	; 0x02
    19ee:	9b 81       	ldd	r25, Y+3	; 0x03
    19f0:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <prvIsQueueEmpty>
    19f4:	88 23       	and	r24, r24
    19f6:	09 f4       	brne	.+2      	; 0x19fa <xQueuePeek+0x14e>
    19f8:	6e cf       	rjmp	.-292    	; 0x18d6 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    19fa:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    19fc:	88 89       	ldd	r24, Y+16	; 0x10
}
    19fe:	60 96       	adiw	r28, 0x10	; 16
    1a00:	0f b6       	in	r0, 0x3f	; 63
    1a02:	f8 94       	cli
    1a04:	de bf       	out	0x3e, r29	; 62
    1a06:	0f be       	out	0x3f, r0	; 63
    1a08:	cd bf       	out	0x3d, r28	; 61
    1a0a:	cf 91       	pop	r28
    1a0c:	df 91       	pop	r29
    1a0e:	08 95       	ret

00001a10 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1a10:	df 93       	push	r29
    1a12:	cf 93       	push	r28
    1a14:	cd b7       	in	r28, 0x3d	; 61
    1a16:	de b7       	in	r29, 0x3e	; 62
    1a18:	2c 97       	sbiw	r28, 0x0c	; 12
    1a1a:	0f b6       	in	r0, 0x3f	; 63
    1a1c:	f8 94       	cli
    1a1e:	de bf       	out	0x3e, r29	; 62
    1a20:	0f be       	out	0x3f, r0	; 63
    1a22:	cd bf       	out	0x3d, r28	; 61
    1a24:	98 87       	std	Y+8, r25	; 0x08
    1a26:	8f 83       	std	Y+7, r24	; 0x07
    1a28:	7a 87       	std	Y+10, r23	; 0x0a
    1a2a:	69 87       	std	Y+9, r22	; 0x09
    1a2c:	5c 87       	std	Y+12, r21	; 0x0c
    1a2e:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1a30:	8f 81       	ldd	r24, Y+7	; 0x07
    1a32:	98 85       	ldd	r25, Y+8	; 0x08
    1a34:	9c 83       	std	Y+4, r25	; 0x04
    1a36:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a38:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a3a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a3c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a40:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a42:	8a 81       	ldd	r24, Y+2	; 0x02
    1a44:	88 23       	and	r24, r24
    1a46:	81 f1       	breq	.+96     	; 0x1aa8 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1a48:	eb 81       	ldd	r30, Y+3	; 0x03
    1a4a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a4c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a4e:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a50:	8b 81       	ldd	r24, Y+3	; 0x03
    1a52:	9c 81       	ldd	r25, Y+4	; 0x04
    1a54:	29 85       	ldd	r18, Y+9	; 0x09
    1a56:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a58:	b9 01       	movw	r22, r18
    1a5a:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1a5e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a60:	81 50       	subi	r24, 0x01	; 1
    1a62:	eb 81       	ldd	r30, Y+3	; 0x03
    1a64:	fc 81       	ldd	r31, Y+4	; 0x04
    1a66:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1a68:	89 81       	ldd	r24, Y+1	; 0x01
    1a6a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a6c:	a9 f4       	brne	.+42     	; 0x1a98 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a6e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a70:	fc 81       	ldd	r31, Y+4	; 0x04
    1a72:	80 85       	ldd	r24, Z+8	; 0x08
    1a74:	88 23       	and	r24, r24
    1a76:	a9 f0       	breq	.+42     	; 0x1aa2 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a78:	8b 81       	ldd	r24, Y+3	; 0x03
    1a7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a7c:	08 96       	adiw	r24, 0x08	; 8
    1a7e:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <xTaskRemoveFromEventList>
    1a82:	88 23       	and	r24, r24
    1a84:	71 f0       	breq	.+28     	; 0x1aa2 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1a86:	8b 85       	ldd	r24, Y+11	; 0x0b
    1a88:	9c 85       	ldd	r25, Y+12	; 0x0c
    1a8a:	00 97       	sbiw	r24, 0x00	; 0
    1a8c:	51 f0       	breq	.+20     	; 0x1aa2 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1a8e:	eb 85       	ldd	r30, Y+11	; 0x0b
    1a90:	fc 85       	ldd	r31, Y+12	; 0x0c
    1a92:	81 e0       	ldi	r24, 0x01	; 1
    1a94:	80 83       	st	Z, r24
    1a96:	05 c0       	rjmp	.+10     	; 0x1aa2 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1a98:	89 81       	ldd	r24, Y+1	; 0x01
    1a9a:	8f 5f       	subi	r24, 0xFF	; 255
    1a9c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a9e:	fc 81       	ldd	r31, Y+4	; 0x04
    1aa0:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1aa2:	81 e0       	ldi	r24, 0x01	; 1
    1aa4:	8e 83       	std	Y+6, r24	; 0x06
    1aa6:	01 c0       	rjmp	.+2      	; 0x1aaa <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    1aa8:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1aaa:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1aac:	2c 96       	adiw	r28, 0x0c	; 12
    1aae:	0f b6       	in	r0, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	de bf       	out	0x3e, r29	; 62
    1ab4:	0f be       	out	0x3f, r0	; 63
    1ab6:	cd bf       	out	0x3d, r28	; 61
    1ab8:	cf 91       	pop	r28
    1aba:	df 91       	pop	r29
    1abc:	08 95       	ret

00001abe <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1abe:	df 93       	push	r29
    1ac0:	cf 93       	push	r28
    1ac2:	cd b7       	in	r28, 0x3d	; 61
    1ac4:	de b7       	in	r29, 0x3e	; 62
    1ac6:	2a 97       	sbiw	r28, 0x0a	; 10
    1ac8:	0f b6       	in	r0, 0x3f	; 63
    1aca:	f8 94       	cli
    1acc:	de bf       	out	0x3e, r29	; 62
    1ace:	0f be       	out	0x3f, r0	; 63
    1ad0:	cd bf       	out	0x3d, r28	; 61
    1ad2:	98 87       	std	Y+8, r25	; 0x08
    1ad4:	8f 83       	std	Y+7, r24	; 0x07
    1ad6:	7a 87       	std	Y+10, r23	; 0x0a
    1ad8:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1ada:	8f 81       	ldd	r24, Y+7	; 0x07
    1adc:	98 85       	ldd	r25, Y+8	; 0x08
    1ade:	9a 83       	std	Y+2, r25	; 0x02
    1ae0:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1ae2:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ae4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ae6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ae8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aea:	88 23       	and	r24, r24
    1aec:	b1 f0       	breq	.+44     	; 0x1b1a <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1aee:	e9 81       	ldd	r30, Y+1	; 0x01
    1af0:	fa 81       	ldd	r31, Y+2	; 0x02
    1af2:	86 81       	ldd	r24, Z+6	; 0x06
    1af4:	97 81       	ldd	r25, Z+7	; 0x07
    1af6:	9c 83       	std	Y+4, r25	; 0x04
    1af8:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1afa:	89 81       	ldd	r24, Y+1	; 0x01
    1afc:	9a 81       	ldd	r25, Y+2	; 0x02
    1afe:	29 85       	ldd	r18, Y+9	; 0x09
    1b00:	3a 85       	ldd	r19, Y+10	; 0x0a
    1b02:	b9 01       	movw	r22, r18
    1b04:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1b08:	e9 81       	ldd	r30, Y+1	; 0x01
    1b0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b10:	97 83       	std	Z+7, r25	; 0x07
    1b12:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    1b14:	81 e0       	ldi	r24, 0x01	; 1
    1b16:	8e 83       	std	Y+6, r24	; 0x06
    1b18:	01 c0       	rjmp	.+2      	; 0x1b1c <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    1b1a:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1b1c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1b1e:	2a 96       	adiw	r28, 0x0a	; 10
    1b20:	0f b6       	in	r0, 0x3f	; 63
    1b22:	f8 94       	cli
    1b24:	de bf       	out	0x3e, r29	; 62
    1b26:	0f be       	out	0x3f, r0	; 63
    1b28:	cd bf       	out	0x3d, r28	; 61
    1b2a:	cf 91       	pop	r28
    1b2c:	df 91       	pop	r29
    1b2e:	08 95       	ret

00001b30 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1b30:	df 93       	push	r29
    1b32:	cf 93       	push	r28
    1b34:	00 d0       	rcall	.+0      	; 0x1b36 <uxQueueMessagesWaiting+0x6>
    1b36:	0f 92       	push	r0
    1b38:	cd b7       	in	r28, 0x3d	; 61
    1b3a:	de b7       	in	r29, 0x3e	; 62
    1b3c:	9b 83       	std	Y+3, r25	; 0x03
    1b3e:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1b40:	0f b6       	in	r0, 0x3f	; 63
    1b42:	f8 94       	cli
    1b44:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1b46:	ea 81       	ldd	r30, Y+2	; 0x02
    1b48:	fb 81       	ldd	r31, Y+3	; 0x03
    1b4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b4c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1b4e:	0f 90       	pop	r0
    1b50:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1b52:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b54:	0f 90       	pop	r0
    1b56:	0f 90       	pop	r0
    1b58:	0f 90       	pop	r0
    1b5a:	cf 91       	pop	r28
    1b5c:	df 91       	pop	r29
    1b5e:	08 95       	ret

00001b60 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1b60:	df 93       	push	r29
    1b62:	cf 93       	push	r28
    1b64:	00 d0       	rcall	.+0      	; 0x1b66 <uxQueueSpacesAvailable+0x6>
    1b66:	00 d0       	rcall	.+0      	; 0x1b68 <uxQueueSpacesAvailable+0x8>
    1b68:	0f 92       	push	r0
    1b6a:	cd b7       	in	r28, 0x3d	; 61
    1b6c:	de b7       	in	r29, 0x3e	; 62
    1b6e:	9d 83       	std	Y+5, r25	; 0x05
    1b70:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1b72:	8c 81       	ldd	r24, Y+4	; 0x04
    1b74:	9d 81       	ldd	r25, Y+5	; 0x05
    1b76:	9a 83       	std	Y+2, r25	; 0x02
    1b78:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1b7a:	0f b6       	in	r0, 0x3f	; 63
    1b7c:	f8 94       	cli
    1b7e:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1b80:	e9 81       	ldd	r30, Y+1	; 0x01
    1b82:	fa 81       	ldd	r31, Y+2	; 0x02
    1b84:	93 8d       	ldd	r25, Z+27	; 0x1b
    1b86:	e9 81       	ldd	r30, Y+1	; 0x01
    1b88:	fa 81       	ldd	r31, Y+2	; 0x02
    1b8a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b8c:	29 2f       	mov	r18, r25
    1b8e:	28 1b       	sub	r18, r24
    1b90:	82 2f       	mov	r24, r18
    1b92:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    1b94:	0f 90       	pop	r0
    1b96:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1b98:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b9a:	0f 90       	pop	r0
    1b9c:	0f 90       	pop	r0
    1b9e:	0f 90       	pop	r0
    1ba0:	0f 90       	pop	r0
    1ba2:	0f 90       	pop	r0
    1ba4:	cf 91       	pop	r28
    1ba6:	df 91       	pop	r29
    1ba8:	08 95       	ret

00001baa <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1baa:	df 93       	push	r29
    1bac:	cf 93       	push	r28
    1bae:	00 d0       	rcall	.+0      	; 0x1bb0 <uxQueueMessagesWaitingFromISR+0x6>
    1bb0:	00 d0       	rcall	.+0      	; 0x1bb2 <uxQueueMessagesWaitingFromISR+0x8>
    1bb2:	0f 92       	push	r0
    1bb4:	cd b7       	in	r28, 0x3d	; 61
    1bb6:	de b7       	in	r29, 0x3e	; 62
    1bb8:	9d 83       	std	Y+5, r25	; 0x05
    1bba:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1bbc:	8c 81       	ldd	r24, Y+4	; 0x04
    1bbe:	9d 81       	ldd	r25, Y+5	; 0x05
    1bc0:	9a 83       	std	Y+2, r25	; 0x02
    1bc2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1bc4:	e9 81       	ldd	r30, Y+1	; 0x01
    1bc6:	fa 81       	ldd	r31, Y+2	; 0x02
    1bc8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bca:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    1bcc:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1bce:	0f 90       	pop	r0
    1bd0:	0f 90       	pop	r0
    1bd2:	0f 90       	pop	r0
    1bd4:	0f 90       	pop	r0
    1bd6:	0f 90       	pop	r0
    1bd8:	cf 91       	pop	r28
    1bda:	df 91       	pop	r29
    1bdc:	08 95       	ret

00001bde <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1bde:	df 93       	push	r29
    1be0:	cf 93       	push	r28
    1be2:	00 d0       	rcall	.+0      	; 0x1be4 <vQueueDelete+0x6>
    1be4:	00 d0       	rcall	.+0      	; 0x1be6 <vQueueDelete+0x8>
    1be6:	cd b7       	in	r28, 0x3d	; 61
    1be8:	de b7       	in	r29, 0x3e	; 62
    1bea:	9c 83       	std	Y+4, r25	; 0x04
    1bec:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    1bee:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bf2:	9a 83       	std	Y+2, r25	; 0x02
    1bf4:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1bf6:	89 81       	ldd	r24, Y+1	; 0x01
    1bf8:	9a 81       	ldd	r25, Y+2	; 0x02
    1bfa:	0e 94 72 04 	call	0x8e4	; 0x8e4 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1bfe:	0f 90       	pop	r0
    1c00:	0f 90       	pop	r0
    1c02:	0f 90       	pop	r0
    1c04:	0f 90       	pop	r0
    1c06:	cf 91       	pop	r28
    1c08:	df 91       	pop	r29
    1c0a:	08 95       	ret

00001c0c <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1c0c:	df 93       	push	r29
    1c0e:	cf 93       	push	r28
    1c10:	cd b7       	in	r28, 0x3d	; 61
    1c12:	de b7       	in	r29, 0x3e	; 62
    1c14:	27 97       	sbiw	r28, 0x07	; 7
    1c16:	0f b6       	in	r0, 0x3f	; 63
    1c18:	f8 94       	cli
    1c1a:	de bf       	out	0x3e, r29	; 62
    1c1c:	0f be       	out	0x3f, r0	; 63
    1c1e:	cd bf       	out	0x3d, r28	; 61
    1c20:	9c 83       	std	Y+4, r25	; 0x04
    1c22:	8b 83       	std	Y+3, r24	; 0x03
    1c24:	7e 83       	std	Y+6, r23	; 0x06
    1c26:	6d 83       	std	Y+5, r22	; 0x05
    1c28:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    1c2a:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1c2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c30:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c32:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1c34:	eb 81       	ldd	r30, Y+3	; 0x03
    1c36:	fc 81       	ldd	r31, Y+4	; 0x04
    1c38:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c3a:	88 23       	and	r24, r24
    1c3c:	09 f4       	brne	.+2      	; 0x1c40 <prvCopyDataToQueue+0x34>
    1c3e:	7d c0       	rjmp	.+250    	; 0x1d3a <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1c40:	8f 81       	ldd	r24, Y+7	; 0x07
    1c42:	88 23       	and	r24, r24
    1c44:	99 f5       	brne	.+102    	; 0x1cac <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1c46:	eb 81       	ldd	r30, Y+3	; 0x03
    1c48:	fc 81       	ldd	r31, Y+4	; 0x04
    1c4a:	62 81       	ldd	r22, Z+2	; 0x02
    1c4c:	73 81       	ldd	r23, Z+3	; 0x03
    1c4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c50:	fc 81       	ldd	r31, Y+4	; 0x04
    1c52:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c54:	48 2f       	mov	r20, r24
    1c56:	50 e0       	ldi	r21, 0x00	; 0
    1c58:	2d 81       	ldd	r18, Y+5	; 0x05
    1c5a:	3e 81       	ldd	r19, Y+6	; 0x06
    1c5c:	cb 01       	movw	r24, r22
    1c5e:	b9 01       	movw	r22, r18
    1c60:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1c64:	eb 81       	ldd	r30, Y+3	; 0x03
    1c66:	fc 81       	ldd	r31, Y+4	; 0x04
    1c68:	22 81       	ldd	r18, Z+2	; 0x02
    1c6a:	33 81       	ldd	r19, Z+3	; 0x03
    1c6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c70:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c72:	88 2f       	mov	r24, r24
    1c74:	90 e0       	ldi	r25, 0x00	; 0
    1c76:	82 0f       	add	r24, r18
    1c78:	93 1f       	adc	r25, r19
    1c7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c7e:	93 83       	std	Z+3, r25	; 0x03
    1c80:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1c82:	eb 81       	ldd	r30, Y+3	; 0x03
    1c84:	fc 81       	ldd	r31, Y+4	; 0x04
    1c86:	22 81       	ldd	r18, Z+2	; 0x02
    1c88:	33 81       	ldd	r19, Z+3	; 0x03
    1c8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c8e:	84 81       	ldd	r24, Z+4	; 0x04
    1c90:	95 81       	ldd	r25, Z+5	; 0x05
    1c92:	28 17       	cp	r18, r24
    1c94:	39 07       	cpc	r19, r25
    1c96:	08 f4       	brcc	.+2      	; 0x1c9a <prvCopyDataToQueue+0x8e>
    1c98:	50 c0       	rjmp	.+160    	; 0x1d3a <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1c9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c9e:	80 81       	ld	r24, Z
    1ca0:	91 81       	ldd	r25, Z+1	; 0x01
    1ca2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ca4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca6:	93 83       	std	Z+3, r25	; 0x03
    1ca8:	82 83       	std	Z+2, r24	; 0x02
    1caa:	47 c0       	rjmp	.+142    	; 0x1d3a <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1cac:	eb 81       	ldd	r30, Y+3	; 0x03
    1cae:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb0:	66 81       	ldd	r22, Z+6	; 0x06
    1cb2:	77 81       	ldd	r23, Z+7	; 0x07
    1cb4:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb6:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cba:	48 2f       	mov	r20, r24
    1cbc:	50 e0       	ldi	r21, 0x00	; 0
    1cbe:	2d 81       	ldd	r18, Y+5	; 0x05
    1cc0:	3e 81       	ldd	r19, Y+6	; 0x06
    1cc2:	cb 01       	movw	r24, r22
    1cc4:	b9 01       	movw	r22, r18
    1cc6:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1cca:	eb 81       	ldd	r30, Y+3	; 0x03
    1ccc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cce:	26 81       	ldd	r18, Z+6	; 0x06
    1cd0:	37 81       	ldd	r19, Z+7	; 0x07
    1cd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cd8:	88 2f       	mov	r24, r24
    1cda:	90 e0       	ldi	r25, 0x00	; 0
    1cdc:	90 95       	com	r25
    1cde:	81 95       	neg	r24
    1ce0:	9f 4f       	sbci	r25, 0xFF	; 255
    1ce2:	82 0f       	add	r24, r18
    1ce4:	93 1f       	adc	r25, r19
    1ce6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cea:	97 83       	std	Z+7, r25	; 0x07
    1cec:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1cee:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf2:	26 81       	ldd	r18, Z+6	; 0x06
    1cf4:	37 81       	ldd	r19, Z+7	; 0x07
    1cf6:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cfa:	80 81       	ld	r24, Z
    1cfc:	91 81       	ldd	r25, Z+1	; 0x01
    1cfe:	28 17       	cp	r18, r24
    1d00:	39 07       	cpc	r19, r25
    1d02:	90 f4       	brcc	.+36     	; 0x1d28 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1d04:	eb 81       	ldd	r30, Y+3	; 0x03
    1d06:	fc 81       	ldd	r31, Y+4	; 0x04
    1d08:	24 81       	ldd	r18, Z+4	; 0x04
    1d0a:	35 81       	ldd	r19, Z+5	; 0x05
    1d0c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d0e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d10:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d12:	88 2f       	mov	r24, r24
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	90 95       	com	r25
    1d18:	81 95       	neg	r24
    1d1a:	9f 4f       	sbci	r25, 0xFF	; 255
    1d1c:	82 0f       	add	r24, r18
    1d1e:	93 1f       	adc	r25, r19
    1d20:	eb 81       	ldd	r30, Y+3	; 0x03
    1d22:	fc 81       	ldd	r31, Y+4	; 0x04
    1d24:	97 83       	std	Z+7, r25	; 0x07
    1d26:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1d28:	8f 81       	ldd	r24, Y+7	; 0x07
    1d2a:	82 30       	cpi	r24, 0x02	; 2
    1d2c:	31 f4       	brne	.+12     	; 0x1d3a <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1d2e:	89 81       	ldd	r24, Y+1	; 0x01
    1d30:	88 23       	and	r24, r24
    1d32:	19 f0       	breq	.+6      	; 0x1d3a <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1d34:	89 81       	ldd	r24, Y+1	; 0x01
    1d36:	81 50       	subi	r24, 0x01	; 1
    1d38:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1d3a:	89 81       	ldd	r24, Y+1	; 0x01
    1d3c:	8f 5f       	subi	r24, 0xFF	; 255
    1d3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d40:	fc 81       	ldd	r31, Y+4	; 0x04
    1d42:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    1d44:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1d46:	27 96       	adiw	r28, 0x07	; 7
    1d48:	0f b6       	in	r0, 0x3f	; 63
    1d4a:	f8 94       	cli
    1d4c:	de bf       	out	0x3e, r29	; 62
    1d4e:	0f be       	out	0x3f, r0	; 63
    1d50:	cd bf       	out	0x3d, r28	; 61
    1d52:	cf 91       	pop	r28
    1d54:	df 91       	pop	r29
    1d56:	08 95       	ret

00001d58 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1d58:	df 93       	push	r29
    1d5a:	cf 93       	push	r28
    1d5c:	00 d0       	rcall	.+0      	; 0x1d5e <prvCopyDataFromQueue+0x6>
    1d5e:	00 d0       	rcall	.+0      	; 0x1d60 <prvCopyDataFromQueue+0x8>
    1d60:	cd b7       	in	r28, 0x3d	; 61
    1d62:	de b7       	in	r29, 0x3e	; 62
    1d64:	9a 83       	std	Y+2, r25	; 0x02
    1d66:	89 83       	std	Y+1, r24	; 0x01
    1d68:	7c 83       	std	Y+4, r23	; 0x04
    1d6a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d70:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d72:	88 23       	and	r24, r24
    1d74:	89 f1       	breq	.+98     	; 0x1dd8 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1d76:	e9 81       	ldd	r30, Y+1	; 0x01
    1d78:	fa 81       	ldd	r31, Y+2	; 0x02
    1d7a:	26 81       	ldd	r18, Z+6	; 0x06
    1d7c:	37 81       	ldd	r19, Z+7	; 0x07
    1d7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d80:	fa 81       	ldd	r31, Y+2	; 0x02
    1d82:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d84:	88 2f       	mov	r24, r24
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	82 0f       	add	r24, r18
    1d8a:	93 1f       	adc	r25, r19
    1d8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d90:	97 83       	std	Z+7, r25	; 0x07
    1d92:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1d94:	e9 81       	ldd	r30, Y+1	; 0x01
    1d96:	fa 81       	ldd	r31, Y+2	; 0x02
    1d98:	26 81       	ldd	r18, Z+6	; 0x06
    1d9a:	37 81       	ldd	r19, Z+7	; 0x07
    1d9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1da0:	84 81       	ldd	r24, Z+4	; 0x04
    1da2:	95 81       	ldd	r25, Z+5	; 0x05
    1da4:	28 17       	cp	r18, r24
    1da6:	39 07       	cpc	r19, r25
    1da8:	40 f0       	brcs	.+16     	; 0x1dba <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1daa:	e9 81       	ldd	r30, Y+1	; 0x01
    1dac:	fa 81       	ldd	r31, Y+2	; 0x02
    1dae:	80 81       	ld	r24, Z
    1db0:	91 81       	ldd	r25, Z+1	; 0x01
    1db2:	e9 81       	ldd	r30, Y+1	; 0x01
    1db4:	fa 81       	ldd	r31, Y+2	; 0x02
    1db6:	97 83       	std	Z+7, r25	; 0x07
    1db8:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1dba:	e9 81       	ldd	r30, Y+1	; 0x01
    1dbc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dbe:	46 81       	ldd	r20, Z+6	; 0x06
    1dc0:	57 81       	ldd	r21, Z+7	; 0x07
    1dc2:	e9 81       	ldd	r30, Y+1	; 0x01
    1dc4:	fa 81       	ldd	r31, Y+2	; 0x02
    1dc6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1dc8:	28 2f       	mov	r18, r24
    1dca:	30 e0       	ldi	r19, 0x00	; 0
    1dcc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dce:	9c 81       	ldd	r25, Y+4	; 0x04
    1dd0:	ba 01       	movw	r22, r20
    1dd2:	a9 01       	movw	r20, r18
    1dd4:	0e 94 28 1e 	call	0x3c50	; 0x3c50 <memcpy>
	}
}
    1dd8:	0f 90       	pop	r0
    1dda:	0f 90       	pop	r0
    1ddc:	0f 90       	pop	r0
    1dde:	0f 90       	pop	r0
    1de0:	cf 91       	pop	r28
    1de2:	df 91       	pop	r29
    1de4:	08 95       	ret

00001de6 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1de6:	df 93       	push	r29
    1de8:	cf 93       	push	r28
    1dea:	00 d0       	rcall	.+0      	; 0x1dec <prvUnlockQueue+0x6>
    1dec:	00 d0       	rcall	.+0      	; 0x1dee <prvUnlockQueue+0x8>
    1dee:	cd b7       	in	r28, 0x3d	; 61
    1df0:	de b7       	in	r29, 0x3e	; 62
    1df2:	9c 83       	std	Y+4, r25	; 0x04
    1df4:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1df6:	0f b6       	in	r0, 0x3f	; 63
    1df8:	f8 94       	cli
    1dfa:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1dfc:	eb 81       	ldd	r30, Y+3	; 0x03
    1dfe:	fc 81       	ldd	r31, Y+4	; 0x04
    1e00:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e02:	8a 83       	std	Y+2, r24	; 0x02
    1e04:	11 c0       	rjmp	.+34     	; 0x1e28 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e06:	eb 81       	ldd	r30, Y+3	; 0x03
    1e08:	fc 81       	ldd	r31, Y+4	; 0x04
    1e0a:	81 89       	ldd	r24, Z+17	; 0x11
    1e0c:	88 23       	and	r24, r24
    1e0e:	79 f0       	breq	.+30     	; 0x1e2e <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e10:	8b 81       	ldd	r24, Y+3	; 0x03
    1e12:	9c 81       	ldd	r25, Y+4	; 0x04
    1e14:	41 96       	adiw	r24, 0x11	; 17
    1e16:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <xTaskRemoveFromEventList>
    1e1a:	88 23       	and	r24, r24
    1e1c:	11 f0       	breq	.+4      	; 0x1e22 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1e1e:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1e22:	8a 81       	ldd	r24, Y+2	; 0x02
    1e24:	81 50       	subi	r24, 0x01	; 1
    1e26:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1e28:	8a 81       	ldd	r24, Y+2	; 0x02
    1e2a:	18 16       	cp	r1, r24
    1e2c:	64 f3       	brlt	.-40     	; 0x1e06 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1e2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e30:	fc 81       	ldd	r31, Y+4	; 0x04
    1e32:	8f ef       	ldi	r24, 0xFF	; 255
    1e34:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1e36:	0f 90       	pop	r0
    1e38:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1e3a:	0f b6       	in	r0, 0x3f	; 63
    1e3c:	f8 94       	cli
    1e3e:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1e40:	eb 81       	ldd	r30, Y+3	; 0x03
    1e42:	fc 81       	ldd	r31, Y+4	; 0x04
    1e44:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e46:	89 83       	std	Y+1, r24	; 0x01
    1e48:	11 c0       	rjmp	.+34     	; 0x1e6c <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e4a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e4c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e4e:	80 85       	ldd	r24, Z+8	; 0x08
    1e50:	88 23       	and	r24, r24
    1e52:	79 f0       	breq	.+30     	; 0x1e72 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e54:	8b 81       	ldd	r24, Y+3	; 0x03
    1e56:	9c 81       	ldd	r25, Y+4	; 0x04
    1e58:	08 96       	adiw	r24, 0x08	; 8
    1e5a:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <xTaskRemoveFromEventList>
    1e5e:	88 23       	and	r24, r24
    1e60:	11 f0       	breq	.+4      	; 0x1e66 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    1e62:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    1e66:	89 81       	ldd	r24, Y+1	; 0x01
    1e68:	81 50       	subi	r24, 0x01	; 1
    1e6a:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1e6c:	89 81       	ldd	r24, Y+1	; 0x01
    1e6e:	18 16       	cp	r1, r24
    1e70:	64 f3       	brlt	.-40     	; 0x1e4a <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1e72:	eb 81       	ldd	r30, Y+3	; 0x03
    1e74:	fc 81       	ldd	r31, Y+4	; 0x04
    1e76:	8f ef       	ldi	r24, 0xFF	; 255
    1e78:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1e7a:	0f 90       	pop	r0
    1e7c:	0f be       	out	0x3f, r0	; 63
}
    1e7e:	0f 90       	pop	r0
    1e80:	0f 90       	pop	r0
    1e82:	0f 90       	pop	r0
    1e84:	0f 90       	pop	r0
    1e86:	cf 91       	pop	r28
    1e88:	df 91       	pop	r29
    1e8a:	08 95       	ret

00001e8c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    1e8c:	df 93       	push	r29
    1e8e:	cf 93       	push	r28
    1e90:	00 d0       	rcall	.+0      	; 0x1e92 <prvIsQueueEmpty+0x6>
    1e92:	0f 92       	push	r0
    1e94:	cd b7       	in	r28, 0x3d	; 61
    1e96:	de b7       	in	r29, 0x3e	; 62
    1e98:	9b 83       	std	Y+3, r25	; 0x03
    1e9a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1e9c:	0f b6       	in	r0, 0x3f	; 63
    1e9e:	f8 94       	cli
    1ea0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1ea2:	ea 81       	ldd	r30, Y+2	; 0x02
    1ea4:	fb 81       	ldd	r31, Y+3	; 0x03
    1ea6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ea8:	88 23       	and	r24, r24
    1eaa:	19 f4       	brne	.+6      	; 0x1eb2 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	89 83       	std	Y+1, r24	; 0x01
    1eb0:	01 c0       	rjmp	.+2      	; 0x1eb4 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    1eb2:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1eb4:	0f 90       	pop	r0
    1eb6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1eb8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1eba:	0f 90       	pop	r0
    1ebc:	0f 90       	pop	r0
    1ebe:	0f 90       	pop	r0
    1ec0:	cf 91       	pop	r28
    1ec2:	df 91       	pop	r29
    1ec4:	08 95       	ret

00001ec6 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1ec6:	df 93       	push	r29
    1ec8:	cf 93       	push	r28
    1eca:	00 d0       	rcall	.+0      	; 0x1ecc <xQueueIsQueueEmptyFromISR+0x6>
    1ecc:	00 d0       	rcall	.+0      	; 0x1ece <xQueueIsQueueEmptyFromISR+0x8>
    1ece:	0f 92       	push	r0
    1ed0:	cd b7       	in	r28, 0x3d	; 61
    1ed2:	de b7       	in	r29, 0x3e	; 62
    1ed4:	9d 83       	std	Y+5, r25	; 0x05
    1ed6:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    1ed8:	8c 81       	ldd	r24, Y+4	; 0x04
    1eda:	9d 81       	ldd	r25, Y+5	; 0x05
    1edc:	9a 83       	std	Y+2, r25	; 0x02
    1ede:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1ee0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ee2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ee4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ee6:	88 23       	and	r24, r24
    1ee8:	19 f4       	brne	.+6      	; 0x1ef0 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    1eea:	81 e0       	ldi	r24, 0x01	; 1
    1eec:	8b 83       	std	Y+3, r24	; 0x03
    1eee:	01 c0       	rjmp	.+2      	; 0x1ef2 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    1ef0:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1ef2:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1ef4:	0f 90       	pop	r0
    1ef6:	0f 90       	pop	r0
    1ef8:	0f 90       	pop	r0
    1efa:	0f 90       	pop	r0
    1efc:	0f 90       	pop	r0
    1efe:	cf 91       	pop	r28
    1f00:	df 91       	pop	r29
    1f02:	08 95       	ret

00001f04 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    1f04:	df 93       	push	r29
    1f06:	cf 93       	push	r28
    1f08:	00 d0       	rcall	.+0      	; 0x1f0a <prvIsQueueFull+0x6>
    1f0a:	0f 92       	push	r0
    1f0c:	cd b7       	in	r28, 0x3d	; 61
    1f0e:	de b7       	in	r29, 0x3e	; 62
    1f10:	9b 83       	std	Y+3, r25	; 0x03
    1f12:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1f14:	0f b6       	in	r0, 0x3f	; 63
    1f16:	f8 94       	cli
    1f18:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f1a:	ea 81       	ldd	r30, Y+2	; 0x02
    1f1c:	fb 81       	ldd	r31, Y+3	; 0x03
    1f1e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f20:	ea 81       	ldd	r30, Y+2	; 0x02
    1f22:	fb 81       	ldd	r31, Y+3	; 0x03
    1f24:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f26:	98 17       	cp	r25, r24
    1f28:	19 f4       	brne	.+6      	; 0x1f30 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    1f2a:	81 e0       	ldi	r24, 0x01	; 1
    1f2c:	89 83       	std	Y+1, r24	; 0x01
    1f2e:	01 c0       	rjmp	.+2      	; 0x1f32 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    1f30:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1f32:	0f 90       	pop	r0
    1f34:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1f36:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f38:	0f 90       	pop	r0
    1f3a:	0f 90       	pop	r0
    1f3c:	0f 90       	pop	r0
    1f3e:	cf 91       	pop	r28
    1f40:	df 91       	pop	r29
    1f42:	08 95       	ret

00001f44 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1f44:	df 93       	push	r29
    1f46:	cf 93       	push	r28
    1f48:	00 d0       	rcall	.+0      	; 0x1f4a <xQueueIsQueueFullFromISR+0x6>
    1f4a:	00 d0       	rcall	.+0      	; 0x1f4c <xQueueIsQueueFullFromISR+0x8>
    1f4c:	0f 92       	push	r0
    1f4e:	cd b7       	in	r28, 0x3d	; 61
    1f50:	de b7       	in	r29, 0x3e	; 62
    1f52:	9d 83       	std	Y+5, r25	; 0x05
    1f54:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    1f56:	8c 81       	ldd	r24, Y+4	; 0x04
    1f58:	9d 81       	ldd	r25, Y+5	; 0x05
    1f5a:	9a 83       	std	Y+2, r25	; 0x02
    1f5c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f60:	fa 81       	ldd	r31, Y+2	; 0x02
    1f62:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f64:	e9 81       	ldd	r30, Y+1	; 0x01
    1f66:	fa 81       	ldd	r31, Y+2	; 0x02
    1f68:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f6a:	98 17       	cp	r25, r24
    1f6c:	19 f4       	brne	.+6      	; 0x1f74 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	8b 83       	std	Y+3, r24	; 0x03
    1f72:	01 c0       	rjmp	.+2      	; 0x1f76 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    1f74:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1f76:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1f78:	0f 90       	pop	r0
    1f7a:	0f 90       	pop	r0
    1f7c:	0f 90       	pop	r0
    1f7e:	0f 90       	pop	r0
    1f80:	0f 90       	pop	r0
    1f82:	cf 91       	pop	r28
    1f84:	df 91       	pop	r29
    1f86:	08 95       	ret

00001f88 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    1f88:	8f 92       	push	r8
    1f8a:	9f 92       	push	r9
    1f8c:	af 92       	push	r10
    1f8e:	bf 92       	push	r11
    1f90:	cf 92       	push	r12
    1f92:	df 92       	push	r13
    1f94:	ef 92       	push	r14
    1f96:	ff 92       	push	r15
    1f98:	0f 93       	push	r16
    1f9a:	1f 93       	push	r17
    1f9c:	df 93       	push	r29
    1f9e:	cf 93       	push	r28
    1fa0:	cd b7       	in	r28, 0x3d	; 61
    1fa2:	de b7       	in	r29, 0x3e	; 62
    1fa4:	60 97       	sbiw	r28, 0x10	; 16
    1fa6:	0f b6       	in	r0, 0x3f	; 63
    1fa8:	f8 94       	cli
    1faa:	de bf       	out	0x3e, r29	; 62
    1fac:	0f be       	out	0x3f, r0	; 63
    1fae:	cd bf       	out	0x3d, r28	; 61
    1fb0:	9f 83       	std	Y+7, r25	; 0x07
    1fb2:	8e 83       	std	Y+6, r24	; 0x06
    1fb4:	79 87       	std	Y+9, r23	; 0x09
    1fb6:	68 87       	std	Y+8, r22	; 0x08
    1fb8:	5b 87       	std	Y+11, r21	; 0x0b
    1fba:	4a 87       	std	Y+10, r20	; 0x0a
    1fbc:	3d 87       	std	Y+13, r19	; 0x0d
    1fbe:	2c 87       	std	Y+12, r18	; 0x0c
    1fc0:	0e 87       	std	Y+14, r16	; 0x0e
    1fc2:	f8 8a       	std	Y+16, r15	; 0x10
    1fc4:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    1fc6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1fc8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1fca:	0e 94 1c 04 	call	0x838	; 0x838 <pvPortMalloc>
    1fce:	9a 83       	std	Y+2, r25	; 0x02
    1fd0:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    1fd2:	89 81       	ldd	r24, Y+1	; 0x01
    1fd4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fd6:	00 97       	sbiw	r24, 0x00	; 0
    1fd8:	b1 f0       	breq	.+44     	; 0x2006 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    1fda:	86 e2       	ldi	r24, 0x26	; 38
    1fdc:	90 e0       	ldi	r25, 0x00	; 0
    1fde:	0e 94 1c 04 	call	0x838	; 0x838 <pvPortMalloc>
    1fe2:	9d 83       	std	Y+5, r25	; 0x05
    1fe4:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    1fe6:	8c 81       	ldd	r24, Y+4	; 0x04
    1fe8:	9d 81       	ldd	r25, Y+5	; 0x05
    1fea:	00 97       	sbiw	r24, 0x00	; 0
    1fec:	39 f0       	breq	.+14     	; 0x1ffc <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1fee:	ec 81       	ldd	r30, Y+4	; 0x04
    1ff0:	fd 81       	ldd	r31, Y+5	; 0x05
    1ff2:	89 81       	ldd	r24, Y+1	; 0x01
    1ff4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ff6:	90 8f       	std	Z+24, r25	; 0x18
    1ff8:	87 8b       	std	Z+23, r24	; 0x17
    1ffa:	07 c0       	rjmp	.+14     	; 0x200a <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1ffc:	89 81       	ldd	r24, Y+1	; 0x01
    1ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    2000:	0e 94 72 04 	call	0x8e4	; 0x8e4 <vPortFree>
    2004:	02 c0       	rjmp	.+4      	; 0x200a <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    2006:	1d 82       	std	Y+5, r1	; 0x05
    2008:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    200a:	8c 81       	ldd	r24, Y+4	; 0x04
    200c:	9d 81       	ldd	r25, Y+5	; 0x05
    200e:	00 97       	sbiw	r24, 0x00	; 0
    2010:	e9 f0       	breq	.+58     	; 0x204c <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2012:	8a 85       	ldd	r24, Y+10	; 0x0a
    2014:	9b 85       	ldd	r25, Y+11	; 0x0b
    2016:	9c 01       	movw	r18, r24
    2018:	40 e0       	ldi	r20, 0x00	; 0
    201a:	50 e0       	ldi	r21, 0x00	; 0
    201c:	8e 81       	ldd	r24, Y+6	; 0x06
    201e:	9f 81       	ldd	r25, Y+7	; 0x07
    2020:	68 85       	ldd	r22, Y+8	; 0x08
    2022:	79 85       	ldd	r23, Y+9	; 0x09
    2024:	ec 85       	ldd	r30, Y+12	; 0x0c
    2026:	fd 85       	ldd	r31, Y+13	; 0x0d
    2028:	af 85       	ldd	r26, Y+15	; 0x0f
    202a:	b8 89       	ldd	r27, Y+16	; 0x10
    202c:	ac 80       	ldd	r10, Y+4	; 0x04
    202e:	bd 80       	ldd	r11, Y+5	; 0x05
    2030:	8f 01       	movw	r16, r30
    2032:	ee 84       	ldd	r14, Y+14	; 0x0e
    2034:	6d 01       	movw	r12, r26
    2036:	88 24       	eor	r8, r8
    2038:	99 24       	eor	r9, r9
    203a:	0e 94 3c 10 	call	0x2078	; 0x2078 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    203e:	8c 81       	ldd	r24, Y+4	; 0x04
    2040:	9d 81       	ldd	r25, Y+5	; 0x05
    2042:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    2046:	81 e0       	ldi	r24, 0x01	; 1
    2048:	8b 83       	std	Y+3, r24	; 0x03
    204a:	02 c0       	rjmp	.+4      	; 0x2050 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    204c:	8f ef       	ldi	r24, 0xFF	; 255
    204e:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    2050:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2052:	60 96       	adiw	r28, 0x10	; 16
    2054:	0f b6       	in	r0, 0x3f	; 63
    2056:	f8 94       	cli
    2058:	de bf       	out	0x3e, r29	; 62
    205a:	0f be       	out	0x3f, r0	; 63
    205c:	cd bf       	out	0x3d, r28	; 61
    205e:	cf 91       	pop	r28
    2060:	df 91       	pop	r29
    2062:	1f 91       	pop	r17
    2064:	0f 91       	pop	r16
    2066:	ff 90       	pop	r15
    2068:	ef 90       	pop	r14
    206a:	df 90       	pop	r13
    206c:	cf 90       	pop	r12
    206e:	bf 90       	pop	r11
    2070:	af 90       	pop	r10
    2072:	9f 90       	pop	r9
    2074:	8f 90       	pop	r8
    2076:	08 95       	ret

00002078 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    2078:	8f 92       	push	r8
    207a:	9f 92       	push	r9
    207c:	af 92       	push	r10
    207e:	bf 92       	push	r11
    2080:	cf 92       	push	r12
    2082:	df 92       	push	r13
    2084:	ef 92       	push	r14
    2086:	0f 93       	push	r16
    2088:	1f 93       	push	r17
    208a:	df 93       	push	r29
    208c:	cf 93       	push	r28
    208e:	cd b7       	in	r28, 0x3d	; 61
    2090:	de b7       	in	r29, 0x3e	; 62
    2092:	64 97       	sbiw	r28, 0x14	; 20
    2094:	0f b6       	in	r0, 0x3f	; 63
    2096:	f8 94       	cli
    2098:	de bf       	out	0x3e, r29	; 62
    209a:	0f be       	out	0x3f, r0	; 63
    209c:	cd bf       	out	0x3d, r28	; 61
    209e:	9d 83       	std	Y+5, r25	; 0x05
    20a0:	8c 83       	std	Y+4, r24	; 0x04
    20a2:	7f 83       	std	Y+7, r23	; 0x07
    20a4:	6e 83       	std	Y+6, r22	; 0x06
    20a6:	28 87       	std	Y+8, r18	; 0x08
    20a8:	39 87       	std	Y+9, r19	; 0x09
    20aa:	4a 87       	std	Y+10, r20	; 0x0a
    20ac:	5b 87       	std	Y+11, r21	; 0x0b
    20ae:	1d 87       	std	Y+13, r17	; 0x0d
    20b0:	0c 87       	std	Y+12, r16	; 0x0c
    20b2:	ee 86       	std	Y+14, r14	; 0x0e
    20b4:	d8 8a       	std	Y+16, r13	; 0x10
    20b6:	cf 86       	std	Y+15, r12	; 0x0f
    20b8:	ba 8a       	std	Y+18, r11	; 0x12
    20ba:	a9 8a       	std	Y+17, r10	; 0x11
    20bc:	9c 8a       	std	Y+20, r9	; 0x14
    20be:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    20c0:	e9 89       	ldd	r30, Y+17	; 0x11
    20c2:	fa 89       	ldd	r31, Y+18	; 0x12
    20c4:	27 89       	ldd	r18, Z+23	; 0x17
    20c6:	30 8d       	ldd	r19, Z+24	; 0x18
    20c8:	88 85       	ldd	r24, Y+8	; 0x08
    20ca:	99 85       	ldd	r25, Y+9	; 0x09
    20cc:	01 97       	sbiw	r24, 0x01	; 1
    20ce:	82 0f       	add	r24, r18
    20d0:	93 1f       	adc	r25, r19
    20d2:	9b 83       	std	Y+3, r25	; 0x03
    20d4:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    20d6:	8e 81       	ldd	r24, Y+6	; 0x06
    20d8:	9f 81       	ldd	r25, Y+7	; 0x07
    20da:	00 97       	sbiw	r24, 0x00	; 0
    20dc:	51 f1       	breq	.+84     	; 0x2132 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    20de:	19 82       	std	Y+1, r1	; 0x01
    20e0:	21 c0       	rjmp	.+66     	; 0x2124 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    20e2:	89 81       	ldd	r24, Y+1	; 0x01
    20e4:	48 2f       	mov	r20, r24
    20e6:	50 e0       	ldi	r21, 0x00	; 0
    20e8:	89 81       	ldd	r24, Y+1	; 0x01
    20ea:	28 2f       	mov	r18, r24
    20ec:	30 e0       	ldi	r19, 0x00	; 0
    20ee:	8e 81       	ldd	r24, Y+6	; 0x06
    20f0:	9f 81       	ldd	r25, Y+7	; 0x07
    20f2:	fc 01       	movw	r30, r24
    20f4:	e2 0f       	add	r30, r18
    20f6:	f3 1f       	adc	r31, r19
    20f8:	20 81       	ld	r18, Z
    20fa:	89 89       	ldd	r24, Y+17	; 0x11
    20fc:	9a 89       	ldd	r25, Y+18	; 0x12
    20fe:	84 0f       	add	r24, r20
    2100:	95 1f       	adc	r25, r21
    2102:	fc 01       	movw	r30, r24
    2104:	79 96       	adiw	r30, 0x19	; 25
    2106:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    2108:	89 81       	ldd	r24, Y+1	; 0x01
    210a:	28 2f       	mov	r18, r24
    210c:	30 e0       	ldi	r19, 0x00	; 0
    210e:	8e 81       	ldd	r24, Y+6	; 0x06
    2110:	9f 81       	ldd	r25, Y+7	; 0x07
    2112:	fc 01       	movw	r30, r24
    2114:	e2 0f       	add	r30, r18
    2116:	f3 1f       	adc	r31, r19
    2118:	80 81       	ld	r24, Z
    211a:	88 23       	and	r24, r24
    211c:	31 f0       	breq	.+12     	; 0x212a <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    211e:	89 81       	ldd	r24, Y+1	; 0x01
    2120:	8f 5f       	subi	r24, 0xFF	; 255
    2122:	89 83       	std	Y+1, r24	; 0x01
    2124:	89 81       	ldd	r24, Y+1	; 0x01
    2126:	88 30       	cpi	r24, 0x08	; 8
    2128:	e0 f2       	brcs	.-72     	; 0x20e2 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    212a:	e9 89       	ldd	r30, Y+17	; 0x11
    212c:	fa 89       	ldd	r31, Y+18	; 0x12
    212e:	10 a2       	std	Z+32, r1	; 0x20
    2130:	03 c0       	rjmp	.+6      	; 0x2138 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    2132:	e9 89       	ldd	r30, Y+17	; 0x11
    2134:	fa 89       	ldd	r31, Y+18	; 0x12
    2136:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2138:	8e 85       	ldd	r24, Y+14	; 0x0e
    213a:	84 30       	cpi	r24, 0x04	; 4
    213c:	10 f0       	brcs	.+4      	; 0x2142 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    213e:	83 e0       	ldi	r24, 0x03	; 3
    2140:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    2142:	e9 89       	ldd	r30, Y+17	; 0x11
    2144:	fa 89       	ldd	r31, Y+18	; 0x12
    2146:	8e 85       	ldd	r24, Y+14	; 0x0e
    2148:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    214a:	89 89       	ldd	r24, Y+17	; 0x11
    214c:	9a 89       	ldd	r25, Y+18	; 0x12
    214e:	02 96       	adiw	r24, 0x02	; 2
    2150:	0e 94 c2 04 	call	0x984	; 0x984 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    2154:	89 89       	ldd	r24, Y+17	; 0x11
    2156:	9a 89       	ldd	r25, Y+18	; 0x12
    2158:	0c 96       	adiw	r24, 0x0c	; 12
    215a:	0e 94 c2 04 	call	0x984	; 0x984 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    215e:	e9 89       	ldd	r30, Y+17	; 0x11
    2160:	fa 89       	ldd	r31, Y+18	; 0x12
    2162:	89 89       	ldd	r24, Y+17	; 0x11
    2164:	9a 89       	ldd	r25, Y+18	; 0x12
    2166:	91 87       	std	Z+9, r25	; 0x09
    2168:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    216a:	8e 85       	ldd	r24, Y+14	; 0x0e
    216c:	28 2f       	mov	r18, r24
    216e:	30 e0       	ldi	r19, 0x00	; 0
    2170:	84 e0       	ldi	r24, 0x04	; 4
    2172:	90 e0       	ldi	r25, 0x00	; 0
    2174:	82 1b       	sub	r24, r18
    2176:	93 0b       	sbc	r25, r19
    2178:	e9 89       	ldd	r30, Y+17	; 0x11
    217a:	fa 89       	ldd	r31, Y+18	; 0x12
    217c:	95 87       	std	Z+13, r25	; 0x0d
    217e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2180:	e9 89       	ldd	r30, Y+17	; 0x11
    2182:	fa 89       	ldd	r31, Y+18	; 0x12
    2184:	89 89       	ldd	r24, Y+17	; 0x11
    2186:	9a 89       	ldd	r25, Y+18	; 0x12
    2188:	93 8b       	std	Z+19, r25	; 0x13
    218a:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    218c:	e9 89       	ldd	r30, Y+17	; 0x11
    218e:	fa 89       	ldd	r31, Y+18	; 0x12
    2190:	11 a2       	std	Z+33, r1	; 0x21
    2192:	12 a2       	std	Z+34, r1	; 0x22
    2194:	13 a2       	std	Z+35, r1	; 0x23
    2196:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2198:	e9 89       	ldd	r30, Y+17	; 0x11
    219a:	fa 89       	ldd	r31, Y+18	; 0x12
    219c:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    219e:	8a 81       	ldd	r24, Y+2	; 0x02
    21a0:	9b 81       	ldd	r25, Y+3	; 0x03
    21a2:	2c 81       	ldd	r18, Y+4	; 0x04
    21a4:	3d 81       	ldd	r19, Y+5	; 0x05
    21a6:	4c 85       	ldd	r20, Y+12	; 0x0c
    21a8:	5d 85       	ldd	r21, Y+13	; 0x0d
    21aa:	b9 01       	movw	r22, r18
    21ac:	0e 94 ce 05 	call	0xb9c	; 0xb9c <pxPortInitialiseStack>
    21b0:	e9 89       	ldd	r30, Y+17	; 0x11
    21b2:	fa 89       	ldd	r31, Y+18	; 0x12
    21b4:	91 83       	std	Z+1, r25	; 0x01
    21b6:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    21b8:	8f 85       	ldd	r24, Y+15	; 0x0f
    21ba:	98 89       	ldd	r25, Y+16	; 0x10
    21bc:	00 97       	sbiw	r24, 0x00	; 0
    21be:	31 f0       	breq	.+12     	; 0x21cc <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    21c0:	ef 85       	ldd	r30, Y+15	; 0x0f
    21c2:	f8 89       	ldd	r31, Y+16	; 0x10
    21c4:	89 89       	ldd	r24, Y+17	; 0x11
    21c6:	9a 89       	ldd	r25, Y+18	; 0x12
    21c8:	91 83       	std	Z+1, r25	; 0x01
    21ca:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    21cc:	64 96       	adiw	r28, 0x14	; 20
    21ce:	0f b6       	in	r0, 0x3f	; 63
    21d0:	f8 94       	cli
    21d2:	de bf       	out	0x3e, r29	; 62
    21d4:	0f be       	out	0x3f, r0	; 63
    21d6:	cd bf       	out	0x3d, r28	; 61
    21d8:	cf 91       	pop	r28
    21da:	df 91       	pop	r29
    21dc:	1f 91       	pop	r17
    21de:	0f 91       	pop	r16
    21e0:	ef 90       	pop	r14
    21e2:	df 90       	pop	r13
    21e4:	cf 90       	pop	r12
    21e6:	bf 90       	pop	r11
    21e8:	af 90       	pop	r10
    21ea:	9f 90       	pop	r9
    21ec:	8f 90       	pop	r8
    21ee:	08 95       	ret

000021f0 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    21f0:	df 93       	push	r29
    21f2:	cf 93       	push	r28
    21f4:	00 d0       	rcall	.+0      	; 0x21f6 <prvAddNewTaskToReadyList+0x6>
    21f6:	cd b7       	in	r28, 0x3d	; 61
    21f8:	de b7       	in	r29, 0x3e	; 62
    21fa:	9a 83       	std	Y+2, r25	; 0x02
    21fc:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    21fe:	0f b6       	in	r0, 0x3f	; 63
    2200:	f8 94       	cli
    2202:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    2204:	80 91 e7 02 	lds	r24, 0x02E7
    2208:	8f 5f       	subi	r24, 0xFF	; 255
    220a:	80 93 e7 02 	sts	0x02E7, r24
		if( pxCurrentTCB == NULL )
    220e:	80 91 e4 02 	lds	r24, 0x02E4
    2212:	90 91 e5 02 	lds	r25, 0x02E5
    2216:	00 97       	sbiw	r24, 0x00	; 0
    2218:	69 f4       	brne	.+26     	; 0x2234 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    221a:	89 81       	ldd	r24, Y+1	; 0x01
    221c:	9a 81       	ldd	r25, Y+2	; 0x02
    221e:	90 93 e5 02 	sts	0x02E5, r25
    2222:	80 93 e4 02 	sts	0x02E4, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2226:	80 91 e7 02 	lds	r24, 0x02E7
    222a:	81 30       	cpi	r24, 0x01	; 1
    222c:	b9 f4       	brne	.+46     	; 0x225c <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    222e:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <prvInitialiseTaskLists>
    2232:	14 c0       	rjmp	.+40     	; 0x225c <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    2234:	80 91 eb 02 	lds	r24, 0x02EB
    2238:	88 23       	and	r24, r24
    223a:	81 f4       	brne	.+32     	; 0x225c <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    223c:	e0 91 e4 02 	lds	r30, 0x02E4
    2240:	f0 91 e5 02 	lds	r31, 0x02E5
    2244:	96 89       	ldd	r25, Z+22	; 0x16
    2246:	e9 81       	ldd	r30, Y+1	; 0x01
    2248:	fa 81       	ldd	r31, Y+2	; 0x02
    224a:	86 89       	ldd	r24, Z+22	; 0x16
    224c:	89 17       	cp	r24, r25
    224e:	30 f0       	brcs	.+12     	; 0x225c <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    2250:	89 81       	ldd	r24, Y+1	; 0x01
    2252:	9a 81       	ldd	r25, Y+2	; 0x02
    2254:	90 93 e5 02 	sts	0x02E5, r25
    2258:	80 93 e4 02 	sts	0x02E4, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    225c:	80 91 ef 02 	lds	r24, 0x02EF
    2260:	8f 5f       	subi	r24, 0xFF	; 255
    2262:	80 93 ef 02 	sts	0x02EF, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    2266:	e9 81       	ldd	r30, Y+1	; 0x01
    2268:	fa 81       	ldd	r31, Y+2	; 0x02
    226a:	96 89       	ldd	r25, Z+22	; 0x16
    226c:	80 91 ea 02 	lds	r24, 0x02EA
    2270:	89 17       	cp	r24, r25
    2272:	28 f4       	brcc	.+10     	; 0x227e <prvAddNewTaskToReadyList+0x8e>
    2274:	e9 81       	ldd	r30, Y+1	; 0x01
    2276:	fa 81       	ldd	r31, Y+2	; 0x02
    2278:	86 89       	ldd	r24, Z+22	; 0x16
    227a:	80 93 ea 02 	sts	0x02EA, r24
    227e:	e9 81       	ldd	r30, Y+1	; 0x01
    2280:	fa 81       	ldd	r31, Y+2	; 0x02
    2282:	86 89       	ldd	r24, Z+22	; 0x16
    2284:	28 2f       	mov	r18, r24
    2286:	30 e0       	ldi	r19, 0x00	; 0
    2288:	c9 01       	movw	r24, r18
    228a:	88 0f       	add	r24, r24
    228c:	99 1f       	adc	r25, r25
    228e:	88 0f       	add	r24, r24
    2290:	99 1f       	adc	r25, r25
    2292:	88 0f       	add	r24, r24
    2294:	99 1f       	adc	r25, r25
    2296:	82 0f       	add	r24, r18
    2298:	93 1f       	adc	r25, r19
    229a:	ac 01       	movw	r20, r24
    229c:	4b 50       	subi	r20, 0x0B	; 11
    229e:	5d 4f       	sbci	r21, 0xFD	; 253
    22a0:	89 81       	ldd	r24, Y+1	; 0x01
    22a2:	9a 81       	ldd	r25, Y+2	; 0x02
    22a4:	9c 01       	movw	r18, r24
    22a6:	2e 5f       	subi	r18, 0xFE	; 254
    22a8:	3f 4f       	sbci	r19, 0xFF	; 255
    22aa:	ca 01       	movw	r24, r20
    22ac:	b9 01       	movw	r22, r18
    22ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    22b2:	0f 90       	pop	r0
    22b4:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    22b6:	80 91 eb 02 	lds	r24, 0x02EB
    22ba:	88 23       	and	r24, r24
    22bc:	61 f0       	breq	.+24     	; 0x22d6 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    22be:	e0 91 e4 02 	lds	r30, 0x02E4
    22c2:	f0 91 e5 02 	lds	r31, 0x02E5
    22c6:	96 89       	ldd	r25, Z+22	; 0x16
    22c8:	e9 81       	ldd	r30, Y+1	; 0x01
    22ca:	fa 81       	ldd	r31, Y+2	; 0x02
    22cc:	86 89       	ldd	r24, Z+22	; 0x16
    22ce:	98 17       	cp	r25, r24
    22d0:	10 f4       	brcc	.+4      	; 0x22d6 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    22d2:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    22d6:	0f 90       	pop	r0
    22d8:	0f 90       	pop	r0
    22da:	cf 91       	pop	r28
    22dc:	df 91       	pop	r29
    22de:	08 95       	ret

000022e0 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    22e0:	df 93       	push	r29
    22e2:	cf 93       	push	r28
    22e4:	00 d0       	rcall	.+0      	; 0x22e6 <vTaskDelete+0x6>
    22e6:	00 d0       	rcall	.+0      	; 0x22e8 <vTaskDelete+0x8>
    22e8:	00 d0       	rcall	.+0      	; 0x22ea <vTaskDelete+0xa>
    22ea:	cd b7       	in	r28, 0x3d	; 61
    22ec:	de b7       	in	r29, 0x3e	; 62
    22ee:	9c 83       	std	Y+4, r25	; 0x04
    22f0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    22f2:	0f b6       	in	r0, 0x3f	; 63
    22f4:	f8 94       	cli
    22f6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    22f8:	8b 81       	ldd	r24, Y+3	; 0x03
    22fa:	9c 81       	ldd	r25, Y+4	; 0x04
    22fc:	00 97       	sbiw	r24, 0x00	; 0
    22fe:	39 f4       	brne	.+14     	; 0x230e <vTaskDelete+0x2e>
    2300:	80 91 e4 02 	lds	r24, 0x02E4
    2304:	90 91 e5 02 	lds	r25, 0x02E5
    2308:	9e 83       	std	Y+6, r25	; 0x06
    230a:	8d 83       	std	Y+5, r24	; 0x05
    230c:	04 c0       	rjmp	.+8      	; 0x2316 <vTaskDelete+0x36>
    230e:	8b 81       	ldd	r24, Y+3	; 0x03
    2310:	9c 81       	ldd	r25, Y+4	; 0x04
    2312:	9e 83       	std	Y+6, r25	; 0x06
    2314:	8d 83       	std	Y+5, r24	; 0x05
    2316:	8d 81       	ldd	r24, Y+5	; 0x05
    2318:	9e 81       	ldd	r25, Y+6	; 0x06
    231a:	9a 83       	std	Y+2, r25	; 0x02
    231c:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    231e:	89 81       	ldd	r24, Y+1	; 0x01
    2320:	9a 81       	ldd	r25, Y+2	; 0x02
    2322:	02 96       	adiw	r24, 0x02	; 2
    2324:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2328:	e9 81       	ldd	r30, Y+1	; 0x01
    232a:	fa 81       	ldd	r31, Y+2	; 0x02
    232c:	84 89       	ldd	r24, Z+20	; 0x14
    232e:	95 89       	ldd	r25, Z+21	; 0x15
    2330:	00 97       	sbiw	r24, 0x00	; 0
    2332:	29 f0       	breq	.+10     	; 0x233e <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2334:	89 81       	ldd	r24, Y+1	; 0x01
    2336:	9a 81       	ldd	r25, Y+2	; 0x02
    2338:	0c 96       	adiw	r24, 0x0c	; 12
    233a:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    233e:	80 91 ef 02 	lds	r24, 0x02EF
    2342:	8f 5f       	subi	r24, 0xFF	; 255
    2344:	80 93 ef 02 	sts	0x02EF, r24

			if( pxTCB == pxCurrentTCB )
    2348:	20 91 e4 02 	lds	r18, 0x02E4
    234c:	30 91 e5 02 	lds	r19, 0x02E5
    2350:	89 81       	ldd	r24, Y+1	; 0x01
    2352:	9a 81       	ldd	r25, Y+2	; 0x02
    2354:	82 17       	cp	r24, r18
    2356:	93 07       	cpc	r25, r19
    2358:	81 f4       	brne	.+32     	; 0x237a <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    235a:	89 81       	ldd	r24, Y+1	; 0x01
    235c:	9a 81       	ldd	r25, Y+2	; 0x02
    235e:	9c 01       	movw	r18, r24
    2360:	2e 5f       	subi	r18, 0xFE	; 254
    2362:	3f 4f       	sbci	r19, 0xFF	; 255
    2364:	88 e3       	ldi	r24, 0x38	; 56
    2366:	93 e0       	ldi	r25, 0x03	; 3
    2368:	b9 01       	movw	r22, r18
    236a:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    236e:	80 91 e6 02 	lds	r24, 0x02E6
    2372:	8f 5f       	subi	r24, 0xFF	; 255
    2374:	80 93 e6 02 	sts	0x02E6, r24
    2378:	0b c0       	rjmp	.+22     	; 0x2390 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    237a:	80 91 e7 02 	lds	r24, 0x02E7
    237e:	81 50       	subi	r24, 0x01	; 1
    2380:	80 93 e7 02 	sts	0x02E7, r24
				prvDeleteTCB( pxTCB );
    2384:	89 81       	ldd	r24, Y+1	; 0x01
    2386:	9a 81       	ldd	r25, Y+2	; 0x02
    2388:	0e 94 36 17 	call	0x2e6c	; 0x2e6c <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    238c:	0e 94 4c 17 	call	0x2e98	; 0x2e98 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2390:	0f 90       	pop	r0
    2392:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    2394:	80 91 eb 02 	lds	r24, 0x02EB
    2398:	88 23       	and	r24, r24
    239a:	59 f0       	breq	.+22     	; 0x23b2 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    239c:	20 91 e4 02 	lds	r18, 0x02E4
    23a0:	30 91 e5 02 	lds	r19, 0x02E5
    23a4:	89 81       	ldd	r24, Y+1	; 0x01
    23a6:	9a 81       	ldd	r25, Y+2	; 0x02
    23a8:	82 17       	cp	r24, r18
    23aa:	93 07       	cpc	r25, r19
    23ac:	11 f4       	brne	.+4      	; 0x23b2 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    23ae:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    23b2:	26 96       	adiw	r28, 0x06	; 6
    23b4:	0f b6       	in	r0, 0x3f	; 63
    23b6:	f8 94       	cli
    23b8:	de bf       	out	0x3e, r29	; 62
    23ba:	0f be       	out	0x3f, r0	; 63
    23bc:	cd bf       	out	0x3d, r28	; 61
    23be:	cf 91       	pop	r28
    23c0:	df 91       	pop	r29
    23c2:	08 95       	ret

000023c4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    23c4:	df 93       	push	r29
    23c6:	cf 93       	push	r28
    23c8:	cd b7       	in	r28, 0x3d	; 61
    23ca:	de b7       	in	r29, 0x3e	; 62
    23cc:	2a 97       	sbiw	r28, 0x0a	; 10
    23ce:	0f b6       	in	r0, 0x3f	; 63
    23d0:	f8 94       	cli
    23d2:	de bf       	out	0x3e, r29	; 62
    23d4:	0f be       	out	0x3f, r0	; 63
    23d6:	cd bf       	out	0x3d, r28	; 61
    23d8:	98 87       	std	Y+8, r25	; 0x08
    23da:	8f 83       	std	Y+7, r24	; 0x07
    23dc:	7a 87       	std	Y+10, r23	; 0x0a
    23de:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    23e0:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    23e2:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    23e6:	80 91 e8 02 	lds	r24, 0x02E8
    23ea:	90 91 e9 02 	lds	r25, 0x02E9
    23ee:	9a 83       	std	Y+2, r25	; 0x02
    23f0:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    23f2:	ef 81       	ldd	r30, Y+7	; 0x07
    23f4:	f8 85       	ldd	r31, Y+8	; 0x08
    23f6:	20 81       	ld	r18, Z
    23f8:	31 81       	ldd	r19, Z+1	; 0x01
    23fa:	89 85       	ldd	r24, Y+9	; 0x09
    23fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    23fe:	82 0f       	add	r24, r18
    2400:	93 1f       	adc	r25, r19
    2402:	9e 83       	std	Y+6, r25	; 0x06
    2404:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    2406:	ef 81       	ldd	r30, Y+7	; 0x07
    2408:	f8 85       	ldd	r31, Y+8	; 0x08
    240a:	20 81       	ld	r18, Z
    240c:	31 81       	ldd	r19, Z+1	; 0x01
    240e:	89 81       	ldd	r24, Y+1	; 0x01
    2410:	9a 81       	ldd	r25, Y+2	; 0x02
    2412:	82 17       	cp	r24, r18
    2414:	93 07       	cpc	r25, r19
    2416:	98 f4       	brcc	.+38     	; 0x243e <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2418:	ef 81       	ldd	r30, Y+7	; 0x07
    241a:	f8 85       	ldd	r31, Y+8	; 0x08
    241c:	20 81       	ld	r18, Z
    241e:	31 81       	ldd	r19, Z+1	; 0x01
    2420:	8d 81       	ldd	r24, Y+5	; 0x05
    2422:	9e 81       	ldd	r25, Y+6	; 0x06
    2424:	82 17       	cp	r24, r18
    2426:	93 07       	cpc	r25, r19
    2428:	e0 f4       	brcc	.+56     	; 0x2462 <vTaskDelayUntil+0x9e>
    242a:	2d 81       	ldd	r18, Y+5	; 0x05
    242c:	3e 81       	ldd	r19, Y+6	; 0x06
    242e:	89 81       	ldd	r24, Y+1	; 0x01
    2430:	9a 81       	ldd	r25, Y+2	; 0x02
    2432:	82 17       	cp	r24, r18
    2434:	93 07       	cpc	r25, r19
    2436:	a8 f4       	brcc	.+42     	; 0x2462 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2438:	81 e0       	ldi	r24, 0x01	; 1
    243a:	8b 83       	std	Y+3, r24	; 0x03
    243c:	12 c0       	rjmp	.+36     	; 0x2462 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    243e:	ef 81       	ldd	r30, Y+7	; 0x07
    2440:	f8 85       	ldd	r31, Y+8	; 0x08
    2442:	20 81       	ld	r18, Z
    2444:	31 81       	ldd	r19, Z+1	; 0x01
    2446:	8d 81       	ldd	r24, Y+5	; 0x05
    2448:	9e 81       	ldd	r25, Y+6	; 0x06
    244a:	82 17       	cp	r24, r18
    244c:	93 07       	cpc	r25, r19
    244e:	38 f0       	brcs	.+14     	; 0x245e <vTaskDelayUntil+0x9a>
    2450:	2d 81       	ldd	r18, Y+5	; 0x05
    2452:	3e 81       	ldd	r19, Y+6	; 0x06
    2454:	89 81       	ldd	r24, Y+1	; 0x01
    2456:	9a 81       	ldd	r25, Y+2	; 0x02
    2458:	82 17       	cp	r24, r18
    245a:	93 07       	cpc	r25, r19
    245c:	10 f4       	brcc	.+4      	; 0x2462 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    245e:	81 e0       	ldi	r24, 0x01	; 1
    2460:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2462:	ef 81       	ldd	r30, Y+7	; 0x07
    2464:	f8 85       	ldd	r31, Y+8	; 0x08
    2466:	8d 81       	ldd	r24, Y+5	; 0x05
    2468:	9e 81       	ldd	r25, Y+6	; 0x06
    246a:	91 83       	std	Z+1, r25	; 0x01
    246c:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    246e:	8b 81       	ldd	r24, Y+3	; 0x03
    2470:	88 23       	and	r24, r24
    2472:	49 f0       	breq	.+18     	; 0x2486 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2474:	8d 81       	ldd	r24, Y+5	; 0x05
    2476:	9e 81       	ldd	r25, Y+6	; 0x06
    2478:	29 81       	ldd	r18, Y+1	; 0x01
    247a:	3a 81       	ldd	r19, Y+2	; 0x02
    247c:	82 1b       	sub	r24, r18
    247e:	93 0b       	sbc	r25, r19
    2480:	60 e0       	ldi	r22, 0x00	; 0
    2482:	0e 94 46 1b 	call	0x368c	; 0x368c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2486:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
    248a:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    248c:	8c 81       	ldd	r24, Y+4	; 0x04
    248e:	88 23       	and	r24, r24
    2490:	11 f4       	brne	.+4      	; 0x2496 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    2492:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2496:	2a 96       	adiw	r28, 0x0a	; 10
    2498:	0f b6       	in	r0, 0x3f	; 63
    249a:	f8 94       	cli
    249c:	de bf       	out	0x3e, r29	; 62
    249e:	0f be       	out	0x3f, r0	; 63
    24a0:	cd bf       	out	0x3d, r28	; 61
    24a2:	cf 91       	pop	r28
    24a4:	df 91       	pop	r29
    24a6:	08 95       	ret

000024a8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    24a8:	df 93       	push	r29
    24aa:	cf 93       	push	r28
    24ac:	00 d0       	rcall	.+0      	; 0x24ae <vTaskDelay+0x6>
    24ae:	0f 92       	push	r0
    24b0:	cd b7       	in	r28, 0x3d	; 61
    24b2:	de b7       	in	r29, 0x3e	; 62
    24b4:	9b 83       	std	Y+3, r25	; 0x03
    24b6:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    24b8:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    24ba:	8a 81       	ldd	r24, Y+2	; 0x02
    24bc:	9b 81       	ldd	r25, Y+3	; 0x03
    24be:	00 97       	sbiw	r24, 0x00	; 0
    24c0:	51 f0       	breq	.+20     	; 0x24d6 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    24c2:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    24c6:	8a 81       	ldd	r24, Y+2	; 0x02
    24c8:	9b 81       	ldd	r25, Y+3	; 0x03
    24ca:	60 e0       	ldi	r22, 0x00	; 0
    24cc:	0e 94 46 1b 	call	0x368c	; 0x368c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    24d0:	0e 94 c0 12 	call	0x2580	; 0x2580 <xTaskResumeAll>
    24d4:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24d6:	89 81       	ldd	r24, Y+1	; 0x01
    24d8:	88 23       	and	r24, r24
    24da:	11 f4       	brne	.+4      	; 0x24e0 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    24dc:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    24e0:	0f 90       	pop	r0
    24e2:	0f 90       	pop	r0
    24e4:	0f 90       	pop	r0
    24e6:	cf 91       	pop	r28
    24e8:	df 91       	pop	r29
    24ea:	08 95       	ret

000024ec <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    24ec:	ef 92       	push	r14
    24ee:	ff 92       	push	r15
    24f0:	0f 93       	push	r16
    24f2:	df 93       	push	r29
    24f4:	cf 93       	push	r28
    24f6:	0f 92       	push	r0
    24f8:	cd b7       	in	r28, 0x3d	; 61
    24fa:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    24fc:	80 ec       	ldi	r24, 0xC0	; 192
    24fe:	96 e1       	ldi	r25, 0x16	; 22
    2500:	2b e6       	ldi	r18, 0x6B	; 107
    2502:	30 e0       	ldi	r19, 0x00	; 0
    2504:	e2 ef       	ldi	r30, 0xF2	; 242
    2506:	f2 e0       	ldi	r31, 0x02	; 2
    2508:	b9 01       	movw	r22, r18
    250a:	45 e5       	ldi	r20, 0x55	; 85
    250c:	50 e0       	ldi	r21, 0x00	; 0
    250e:	20 e0       	ldi	r18, 0x00	; 0
    2510:	30 e0       	ldi	r19, 0x00	; 0
    2512:	00 e0       	ldi	r16, 0x00	; 0
    2514:	7f 01       	movw	r14, r30
    2516:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <xTaskCreate>
    251a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    251c:	89 81       	ldd	r24, Y+1	; 0x01
    251e:	81 30       	cpi	r24, 0x01	; 1
    2520:	81 f4       	brne	.+32     	; 0x2542 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    2522:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2524:	8f ef       	ldi	r24, 0xFF	; 255
    2526:	9f ef       	ldi	r25, 0xFF	; 255
    2528:	90 93 f1 02 	sts	0x02F1, r25
    252c:	80 93 f0 02 	sts	0x02F0, r24
		xSchedulerRunning = pdTRUE;
    2530:	81 e0       	ldi	r24, 0x01	; 1
    2532:	80 93 eb 02 	sts	0x02EB, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2536:	10 92 e9 02 	sts	0x02E9, r1
    253a:	10 92 e8 02 	sts	0x02E8, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    253e:	0e 94 51 07 	call	0xea2	; 0xea2 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    2542:	0f 90       	pop	r0
    2544:	cf 91       	pop	r28
    2546:	df 91       	pop	r29
    2548:	0f 91       	pop	r16
    254a:	ff 90       	pop	r15
    254c:	ef 90       	pop	r14
    254e:	08 95       	ret

00002550 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2550:	df 93       	push	r29
    2552:	cf 93       	push	r28
    2554:	cd b7       	in	r28, 0x3d	; 61
    2556:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2558:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    255a:	10 92 eb 02 	sts	0x02EB, r1
	vPortEndScheduler();
    255e:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortEndScheduler>
}
    2562:	cf 91       	pop	r28
    2564:	df 91       	pop	r29
    2566:	08 95       	ret

00002568 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2568:	df 93       	push	r29
    256a:	cf 93       	push	r28
    256c:	cd b7       	in	r28, 0x3d	; 61
    256e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2570:	80 91 f4 02 	lds	r24, 0x02F4
    2574:	8f 5f       	subi	r24, 0xFF	; 255
    2576:	80 93 f4 02 	sts	0x02F4, r24
	portMEMORY_BARRIER();
}
    257a:	cf 91       	pop	r28
    257c:	df 91       	pop	r29
    257e:	08 95       	ret

00002580 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2580:	df 93       	push	r29
    2582:	cf 93       	push	r28
    2584:	00 d0       	rcall	.+0      	; 0x2586 <xTaskResumeAll+0x6>
    2586:	00 d0       	rcall	.+0      	; 0x2588 <xTaskResumeAll+0x8>
    2588:	cd b7       	in	r28, 0x3d	; 61
    258a:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    258c:	1c 82       	std	Y+4, r1	; 0x04
    258e:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    2590:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2592:	0f b6       	in	r0, 0x3f	; 63
    2594:	f8 94       	cli
    2596:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2598:	80 91 f4 02 	lds	r24, 0x02F4
    259c:	81 50       	subi	r24, 0x01	; 1
    259e:	80 93 f4 02 	sts	0x02F4, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    25a2:	80 91 f4 02 	lds	r24, 0x02F4
    25a6:	88 23       	and	r24, r24
    25a8:	09 f0       	breq	.+2      	; 0x25ac <xTaskResumeAll+0x2c>
    25aa:	73 c0       	rjmp	.+230    	; 0x2692 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    25ac:	80 91 e7 02 	lds	r24, 0x02E7
    25b0:	88 23       	and	r24, r24
    25b2:	09 f4       	brne	.+2      	; 0x25b6 <xTaskResumeAll+0x36>
    25b4:	6e c0       	rjmp	.+220    	; 0x2692 <xTaskResumeAll+0x112>
    25b6:	45 c0       	rjmp	.+138    	; 0x2642 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    25b8:	e0 91 34 03 	lds	r30, 0x0334
    25bc:	f0 91 35 03 	lds	r31, 0x0335
    25c0:	86 81       	ldd	r24, Z+6	; 0x06
    25c2:	97 81       	ldd	r25, Z+7	; 0x07
    25c4:	9c 83       	std	Y+4, r25	; 0x04
    25c6:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    25c8:	8b 81       	ldd	r24, Y+3	; 0x03
    25ca:	9c 81       	ldd	r25, Y+4	; 0x04
    25cc:	0c 96       	adiw	r24, 0x0c	; 12
    25ce:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    25d2:	8b 81       	ldd	r24, Y+3	; 0x03
    25d4:	9c 81       	ldd	r25, Y+4	; 0x04
    25d6:	02 96       	adiw	r24, 0x02	; 2
    25d8:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    25dc:	eb 81       	ldd	r30, Y+3	; 0x03
    25de:	fc 81       	ldd	r31, Y+4	; 0x04
    25e0:	96 89       	ldd	r25, Z+22	; 0x16
    25e2:	80 91 ea 02 	lds	r24, 0x02EA
    25e6:	89 17       	cp	r24, r25
    25e8:	28 f4       	brcc	.+10     	; 0x25f4 <xTaskResumeAll+0x74>
    25ea:	eb 81       	ldd	r30, Y+3	; 0x03
    25ec:	fc 81       	ldd	r31, Y+4	; 0x04
    25ee:	86 89       	ldd	r24, Z+22	; 0x16
    25f0:	80 93 ea 02 	sts	0x02EA, r24
    25f4:	eb 81       	ldd	r30, Y+3	; 0x03
    25f6:	fc 81       	ldd	r31, Y+4	; 0x04
    25f8:	86 89       	ldd	r24, Z+22	; 0x16
    25fa:	28 2f       	mov	r18, r24
    25fc:	30 e0       	ldi	r19, 0x00	; 0
    25fe:	c9 01       	movw	r24, r18
    2600:	88 0f       	add	r24, r24
    2602:	99 1f       	adc	r25, r25
    2604:	88 0f       	add	r24, r24
    2606:	99 1f       	adc	r25, r25
    2608:	88 0f       	add	r24, r24
    260a:	99 1f       	adc	r25, r25
    260c:	82 0f       	add	r24, r18
    260e:	93 1f       	adc	r25, r19
    2610:	ac 01       	movw	r20, r24
    2612:	4b 50       	subi	r20, 0x0B	; 11
    2614:	5d 4f       	sbci	r21, 0xFD	; 253
    2616:	8b 81       	ldd	r24, Y+3	; 0x03
    2618:	9c 81       	ldd	r25, Y+4	; 0x04
    261a:	9c 01       	movw	r18, r24
    261c:	2e 5f       	subi	r18, 0xFE	; 254
    261e:	3f 4f       	sbci	r19, 0xFF	; 255
    2620:	ca 01       	movw	r24, r20
    2622:	b9 01       	movw	r22, r18
    2624:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2628:	eb 81       	ldd	r30, Y+3	; 0x03
    262a:	fc 81       	ldd	r31, Y+4	; 0x04
    262c:	96 89       	ldd	r25, Z+22	; 0x16
    262e:	e0 91 e4 02 	lds	r30, 0x02E4
    2632:	f0 91 e5 02 	lds	r31, 0x02E5
    2636:	86 89       	ldd	r24, Z+22	; 0x16
    2638:	98 17       	cp	r25, r24
    263a:	18 f0       	brcs	.+6      	; 0x2642 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    263c:	81 e0       	ldi	r24, 0x01	; 1
    263e:	80 93 ed 02 	sts	0x02ED, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2642:	80 91 2f 03 	lds	r24, 0x032F
    2646:	88 23       	and	r24, r24
    2648:	09 f0       	breq	.+2      	; 0x264c <xTaskResumeAll+0xcc>
    264a:	b6 cf       	rjmp	.-148    	; 0x25b8 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    264c:	8b 81       	ldd	r24, Y+3	; 0x03
    264e:	9c 81       	ldd	r25, Y+4	; 0x04
    2650:	00 97       	sbiw	r24, 0x00	; 0
    2652:	11 f0       	breq	.+4      	; 0x2658 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    2654:	0e 94 4c 17 	call	0x2e98	; 0x2e98 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    2658:	80 91 ec 02 	lds	r24, 0x02EC
    265c:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    265e:	89 81       	ldd	r24, Y+1	; 0x01
    2660:	88 23       	and	r24, r24
    2662:	79 f0       	breq	.+30     	; 0x2682 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    2664:	0e 94 b0 13 	call	0x2760	; 0x2760 <xTaskIncrementTick>
    2668:	88 23       	and	r24, r24
    266a:	19 f0       	breq	.+6      	; 0x2672 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    266c:	81 e0       	ldi	r24, 0x01	; 1
    266e:	80 93 ed 02 	sts	0x02ED, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    2672:	89 81       	ldd	r24, Y+1	; 0x01
    2674:	81 50       	subi	r24, 0x01	; 1
    2676:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	88 23       	and	r24, r24
    267c:	99 f7       	brne	.-26     	; 0x2664 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    267e:	10 92 ec 02 	sts	0x02EC, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    2682:	80 91 ed 02 	lds	r24, 0x02ED
    2686:	88 23       	and	r24, r24
    2688:	21 f0       	breq	.+8      	; 0x2692 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    268a:	81 e0       	ldi	r24, 0x01	; 1
    268c:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    268e:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2692:	0f 90       	pop	r0
    2694:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2696:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2698:	0f 90       	pop	r0
    269a:	0f 90       	pop	r0
    269c:	0f 90       	pop	r0
    269e:	0f 90       	pop	r0
    26a0:	cf 91       	pop	r28
    26a2:	df 91       	pop	r29
    26a4:	08 95       	ret

000026a6 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    26a6:	df 93       	push	r29
    26a8:	cf 93       	push	r28
    26aa:	00 d0       	rcall	.+0      	; 0x26ac <xTaskGetTickCount+0x6>
    26ac:	cd b7       	in	r28, 0x3d	; 61
    26ae:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    26b0:	0f b6       	in	r0, 0x3f	; 63
    26b2:	f8 94       	cli
    26b4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    26b6:	80 91 e8 02 	lds	r24, 0x02E8
    26ba:	90 91 e9 02 	lds	r25, 0x02E9
    26be:	9a 83       	std	Y+2, r25	; 0x02
    26c0:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    26c2:	0f 90       	pop	r0
    26c4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    26c6:	89 81       	ldd	r24, Y+1	; 0x01
    26c8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    26ca:	0f 90       	pop	r0
    26cc:	0f 90       	pop	r0
    26ce:	cf 91       	pop	r28
    26d0:	df 91       	pop	r29
    26d2:	08 95       	ret

000026d4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    26d4:	df 93       	push	r29
    26d6:	cf 93       	push	r28
    26d8:	00 d0       	rcall	.+0      	; 0x26da <xTaskGetTickCountFromISR+0x6>
    26da:	0f 92       	push	r0
    26dc:	cd b7       	in	r28, 0x3d	; 61
    26de:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    26e0:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    26e2:	80 91 e8 02 	lds	r24, 0x02E8
    26e6:	90 91 e9 02 	lds	r25, 0x02E9
    26ea:	9b 83       	std	Y+3, r25	; 0x03
    26ec:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    26ee:	8a 81       	ldd	r24, Y+2	; 0x02
    26f0:	9b 81       	ldd	r25, Y+3	; 0x03
}
    26f2:	0f 90       	pop	r0
    26f4:	0f 90       	pop	r0
    26f6:	0f 90       	pop	r0
    26f8:	cf 91       	pop	r28
    26fa:	df 91       	pop	r29
    26fc:	08 95       	ret

000026fe <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    26fe:	df 93       	push	r29
    2700:	cf 93       	push	r28
    2702:	cd b7       	in	r28, 0x3d	; 61
    2704:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2706:	80 91 e7 02 	lds	r24, 0x02E7
}
    270a:	cf 91       	pop	r28
    270c:	df 91       	pop	r29
    270e:	08 95       	ret

00002710 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2710:	df 93       	push	r29
    2712:	cf 93       	push	r28
    2714:	00 d0       	rcall	.+0      	; 0x2716 <pcTaskGetName+0x6>
    2716:	00 d0       	rcall	.+0      	; 0x2718 <pcTaskGetName+0x8>
    2718:	00 d0       	rcall	.+0      	; 0x271a <pcTaskGetName+0xa>
    271a:	cd b7       	in	r28, 0x3d	; 61
    271c:	de b7       	in	r29, 0x3e	; 62
    271e:	9c 83       	std	Y+4, r25	; 0x04
    2720:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2722:	8b 81       	ldd	r24, Y+3	; 0x03
    2724:	9c 81       	ldd	r25, Y+4	; 0x04
    2726:	00 97       	sbiw	r24, 0x00	; 0
    2728:	39 f4       	brne	.+14     	; 0x2738 <pcTaskGetName+0x28>
    272a:	80 91 e4 02 	lds	r24, 0x02E4
    272e:	90 91 e5 02 	lds	r25, 0x02E5
    2732:	9e 83       	std	Y+6, r25	; 0x06
    2734:	8d 83       	std	Y+5, r24	; 0x05
    2736:	04 c0       	rjmp	.+8      	; 0x2740 <pcTaskGetName+0x30>
    2738:	8b 81       	ldd	r24, Y+3	; 0x03
    273a:	9c 81       	ldd	r25, Y+4	; 0x04
    273c:	9e 83       	std	Y+6, r25	; 0x06
    273e:	8d 83       	std	Y+5, r24	; 0x05
    2740:	8d 81       	ldd	r24, Y+5	; 0x05
    2742:	9e 81       	ldd	r25, Y+6	; 0x06
    2744:	9a 83       	std	Y+2, r25	; 0x02
    2746:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    2748:	89 81       	ldd	r24, Y+1	; 0x01
    274a:	9a 81       	ldd	r25, Y+2	; 0x02
    274c:	49 96       	adiw	r24, 0x19	; 25
}
    274e:	26 96       	adiw	r28, 0x06	; 6
    2750:	0f b6       	in	r0, 0x3f	; 63
    2752:	f8 94       	cli
    2754:	de bf       	out	0x3e, r29	; 62
    2756:	0f be       	out	0x3f, r0	; 63
    2758:	cd bf       	out	0x3d, r28	; 61
    275a:	cf 91       	pop	r28
    275c:	df 91       	pop	r29
    275e:	08 95       	ret

00002760 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2760:	df 93       	push	r29
    2762:	cf 93       	push	r28
    2764:	cd b7       	in	r28, 0x3d	; 61
    2766:	de b7       	in	r29, 0x3e	; 62
    2768:	29 97       	sbiw	r28, 0x09	; 9
    276a:	0f b6       	in	r0, 0x3f	; 63
    276c:	f8 94       	cli
    276e:	de bf       	out	0x3e, r29	; 62
    2770:	0f be       	out	0x3f, r0	; 63
    2772:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2774:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2776:	80 91 f4 02 	lds	r24, 0x02F4
    277a:	88 23       	and	r24, r24
    277c:	09 f0       	breq	.+2      	; 0x2780 <xTaskIncrementTick+0x20>
    277e:	c0 c0       	rjmp	.+384    	; 0x2900 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    2780:	80 91 e8 02 	lds	r24, 0x02E8
    2784:	90 91 e9 02 	lds	r25, 0x02E9
    2788:	01 96       	adiw	r24, 0x01	; 1
    278a:	9c 83       	std	Y+4, r25	; 0x04
    278c:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    278e:	8b 81       	ldd	r24, Y+3	; 0x03
    2790:	9c 81       	ldd	r25, Y+4	; 0x04
    2792:	90 93 e9 02 	sts	0x02E9, r25
    2796:	80 93 e8 02 	sts	0x02E8, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    279a:	8b 81       	ldd	r24, Y+3	; 0x03
    279c:	9c 81       	ldd	r25, Y+4	; 0x04
    279e:	00 97       	sbiw	r24, 0x00	; 0
    27a0:	d9 f4       	brne	.+54     	; 0x27d8 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    27a2:	80 91 2b 03 	lds	r24, 0x032B
    27a6:	90 91 2c 03 	lds	r25, 0x032C
    27aa:	9a 83       	std	Y+2, r25	; 0x02
    27ac:	89 83       	std	Y+1, r24	; 0x01
    27ae:	80 91 2d 03 	lds	r24, 0x032D
    27b2:	90 91 2e 03 	lds	r25, 0x032E
    27b6:	90 93 2c 03 	sts	0x032C, r25
    27ba:	80 93 2b 03 	sts	0x032B, r24
    27be:	89 81       	ldd	r24, Y+1	; 0x01
    27c0:	9a 81       	ldd	r25, Y+2	; 0x02
    27c2:	90 93 2e 03 	sts	0x032E, r25
    27c6:	80 93 2d 03 	sts	0x032D, r24
    27ca:	80 91 ee 02 	lds	r24, 0x02EE
    27ce:	8f 5f       	subi	r24, 0xFF	; 255
    27d0:	80 93 ee 02 	sts	0x02EE, r24
    27d4:	0e 94 4c 17 	call	0x2e98	; 0x2e98 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    27d8:	20 91 f0 02 	lds	r18, 0x02F0
    27dc:	30 91 f1 02 	lds	r19, 0x02F1
    27e0:	8b 81       	ldd	r24, Y+3	; 0x03
    27e2:	9c 81       	ldd	r25, Y+4	; 0x04
    27e4:	82 17       	cp	r24, r18
    27e6:	93 07       	cpc	r25, r19
    27e8:	08 f4       	brcc	.+2      	; 0x27ec <xTaskIncrementTick+0x8c>
    27ea:	71 c0       	rjmp	.+226    	; 0x28ce <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    27ec:	e0 91 2b 03 	lds	r30, 0x032B
    27f0:	f0 91 2c 03 	lds	r31, 0x032C
    27f4:	80 81       	ld	r24, Z
    27f6:	88 23       	and	r24, r24
    27f8:	39 f4       	brne	.+14     	; 0x2808 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    27fa:	8f ef       	ldi	r24, 0xFF	; 255
    27fc:	9f ef       	ldi	r25, 0xFF	; 255
    27fe:	90 93 f1 02 	sts	0x02F1, r25
    2802:	80 93 f0 02 	sts	0x02F0, r24
    2806:	63 c0       	rjmp	.+198    	; 0x28ce <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2808:	e0 91 2b 03 	lds	r30, 0x032B
    280c:	f0 91 2c 03 	lds	r31, 0x032C
    2810:	05 80       	ldd	r0, Z+5	; 0x05
    2812:	f6 81       	ldd	r31, Z+6	; 0x06
    2814:	e0 2d       	mov	r30, r0
    2816:	86 81       	ldd	r24, Z+6	; 0x06
    2818:	97 81       	ldd	r25, Z+7	; 0x07
    281a:	99 87       	std	Y+9, r25	; 0x09
    281c:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    281e:	e8 85       	ldd	r30, Y+8	; 0x08
    2820:	f9 85       	ldd	r31, Y+9	; 0x09
    2822:	82 81       	ldd	r24, Z+2	; 0x02
    2824:	93 81       	ldd	r25, Z+3	; 0x03
    2826:	9f 83       	std	Y+7, r25	; 0x07
    2828:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    282a:	2b 81       	ldd	r18, Y+3	; 0x03
    282c:	3c 81       	ldd	r19, Y+4	; 0x04
    282e:	8e 81       	ldd	r24, Y+6	; 0x06
    2830:	9f 81       	ldd	r25, Y+7	; 0x07
    2832:	28 17       	cp	r18, r24
    2834:	39 07       	cpc	r19, r25
    2836:	38 f4       	brcc	.+14     	; 0x2846 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    2838:	8e 81       	ldd	r24, Y+6	; 0x06
    283a:	9f 81       	ldd	r25, Y+7	; 0x07
    283c:	90 93 f1 02 	sts	0x02F1, r25
    2840:	80 93 f0 02 	sts	0x02F0, r24
    2844:	44 c0       	rjmp	.+136    	; 0x28ce <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2846:	88 85       	ldd	r24, Y+8	; 0x08
    2848:	99 85       	ldd	r25, Y+9	; 0x09
    284a:	02 96       	adiw	r24, 0x02	; 2
    284c:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2850:	e8 85       	ldd	r30, Y+8	; 0x08
    2852:	f9 85       	ldd	r31, Y+9	; 0x09
    2854:	84 89       	ldd	r24, Z+20	; 0x14
    2856:	95 89       	ldd	r25, Z+21	; 0x15
    2858:	00 97       	sbiw	r24, 0x00	; 0
    285a:	29 f0       	breq	.+10     	; 0x2866 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    285c:	88 85       	ldd	r24, Y+8	; 0x08
    285e:	99 85       	ldd	r25, Y+9	; 0x09
    2860:	0c 96       	adiw	r24, 0x0c	; 12
    2862:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    2866:	e8 85       	ldd	r30, Y+8	; 0x08
    2868:	f9 85       	ldd	r31, Y+9	; 0x09
    286a:	96 89       	ldd	r25, Z+22	; 0x16
    286c:	80 91 ea 02 	lds	r24, 0x02EA
    2870:	89 17       	cp	r24, r25
    2872:	28 f4       	brcc	.+10     	; 0x287e <xTaskIncrementTick+0x11e>
    2874:	e8 85       	ldd	r30, Y+8	; 0x08
    2876:	f9 85       	ldd	r31, Y+9	; 0x09
    2878:	86 89       	ldd	r24, Z+22	; 0x16
    287a:	80 93 ea 02 	sts	0x02EA, r24
    287e:	e8 85       	ldd	r30, Y+8	; 0x08
    2880:	f9 85       	ldd	r31, Y+9	; 0x09
    2882:	86 89       	ldd	r24, Z+22	; 0x16
    2884:	28 2f       	mov	r18, r24
    2886:	30 e0       	ldi	r19, 0x00	; 0
    2888:	c9 01       	movw	r24, r18
    288a:	88 0f       	add	r24, r24
    288c:	99 1f       	adc	r25, r25
    288e:	88 0f       	add	r24, r24
    2890:	99 1f       	adc	r25, r25
    2892:	88 0f       	add	r24, r24
    2894:	99 1f       	adc	r25, r25
    2896:	82 0f       	add	r24, r18
    2898:	93 1f       	adc	r25, r19
    289a:	ac 01       	movw	r20, r24
    289c:	4b 50       	subi	r20, 0x0B	; 11
    289e:	5d 4f       	sbci	r21, 0xFD	; 253
    28a0:	88 85       	ldd	r24, Y+8	; 0x08
    28a2:	99 85       	ldd	r25, Y+9	; 0x09
    28a4:	9c 01       	movw	r18, r24
    28a6:	2e 5f       	subi	r18, 0xFE	; 254
    28a8:	3f 4f       	sbci	r19, 0xFF	; 255
    28aa:	ca 01       	movw	r24, r20
    28ac:	b9 01       	movw	r22, r18
    28ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    28b2:	e8 85       	ldd	r30, Y+8	; 0x08
    28b4:	f9 85       	ldd	r31, Y+9	; 0x09
    28b6:	96 89       	ldd	r25, Z+22	; 0x16
    28b8:	e0 91 e4 02 	lds	r30, 0x02E4
    28bc:	f0 91 e5 02 	lds	r31, 0x02E5
    28c0:	86 89       	ldd	r24, Z+22	; 0x16
    28c2:	98 17       	cp	r25, r24
    28c4:	08 f4       	brcc	.+2      	; 0x28c8 <xTaskIncrementTick+0x168>
    28c6:	92 cf       	rjmp	.-220    	; 0x27ec <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    28c8:	81 e0       	ldi	r24, 0x01	; 1
    28ca:	8d 83       	std	Y+5, r24	; 0x05
    28cc:	8f cf       	rjmp	.-226    	; 0x27ec <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    28ce:	e0 91 e4 02 	lds	r30, 0x02E4
    28d2:	f0 91 e5 02 	lds	r31, 0x02E5
    28d6:	86 89       	ldd	r24, Z+22	; 0x16
    28d8:	28 2f       	mov	r18, r24
    28da:	30 e0       	ldi	r19, 0x00	; 0
    28dc:	c9 01       	movw	r24, r18
    28de:	88 0f       	add	r24, r24
    28e0:	99 1f       	adc	r25, r25
    28e2:	88 0f       	add	r24, r24
    28e4:	99 1f       	adc	r25, r25
    28e6:	88 0f       	add	r24, r24
    28e8:	99 1f       	adc	r25, r25
    28ea:	82 0f       	add	r24, r18
    28ec:	93 1f       	adc	r25, r19
    28ee:	fc 01       	movw	r30, r24
    28f0:	eb 50       	subi	r30, 0x0B	; 11
    28f2:	fd 4f       	sbci	r31, 0xFD	; 253
    28f4:	80 81       	ld	r24, Z
    28f6:	82 30       	cpi	r24, 0x02	; 2
    28f8:	40 f0       	brcs	.+16     	; 0x290a <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    28fa:	81 e0       	ldi	r24, 0x01	; 1
    28fc:	8d 83       	std	Y+5, r24	; 0x05
    28fe:	05 c0       	rjmp	.+10     	; 0x290a <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2900:	80 91 ec 02 	lds	r24, 0x02EC
    2904:	8f 5f       	subi	r24, 0xFF	; 255
    2906:	80 93 ec 02 	sts	0x02EC, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    290a:	80 91 ed 02 	lds	r24, 0x02ED
    290e:	88 23       	and	r24, r24
    2910:	11 f0       	breq	.+4      	; 0x2916 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    2912:	81 e0       	ldi	r24, 0x01	; 1
    2914:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2916:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2918:	29 96       	adiw	r28, 0x09	; 9
    291a:	0f b6       	in	r0, 0x3f	; 63
    291c:	f8 94       	cli
    291e:	de bf       	out	0x3e, r29	; 62
    2920:	0f be       	out	0x3f, r0	; 63
    2922:	cd bf       	out	0x3d, r28	; 61
    2924:	cf 91       	pop	r28
    2926:	df 91       	pop	r29
    2928:	08 95       	ret

0000292a <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    292a:	df 93       	push	r29
    292c:	cf 93       	push	r28
    292e:	00 d0       	rcall	.+0      	; 0x2930 <vTaskSwitchContext+0x6>
    2930:	0f 92       	push	r0
    2932:	cd b7       	in	r28, 0x3d	; 61
    2934:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2936:	80 91 f4 02 	lds	r24, 0x02F4
    293a:	88 23       	and	r24, r24
    293c:	21 f0       	breq	.+8      	; 0x2946 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    293e:	81 e0       	ldi	r24, 0x01	; 1
    2940:	80 93 ed 02 	sts	0x02ED, r24
    2944:	59 c0       	rjmp	.+178    	; 0x29f8 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    2946:	10 92 ed 02 	sts	0x02ED, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    294a:	80 91 ea 02 	lds	r24, 0x02EA
    294e:	8b 83       	std	Y+3, r24	; 0x03
    2950:	03 c0       	rjmp	.+6      	; 0x2958 <vTaskSwitchContext+0x2e>
    2952:	8b 81       	ldd	r24, Y+3	; 0x03
    2954:	81 50       	subi	r24, 0x01	; 1
    2956:	8b 83       	std	Y+3, r24	; 0x03
    2958:	8b 81       	ldd	r24, Y+3	; 0x03
    295a:	28 2f       	mov	r18, r24
    295c:	30 e0       	ldi	r19, 0x00	; 0
    295e:	c9 01       	movw	r24, r18
    2960:	88 0f       	add	r24, r24
    2962:	99 1f       	adc	r25, r25
    2964:	88 0f       	add	r24, r24
    2966:	99 1f       	adc	r25, r25
    2968:	88 0f       	add	r24, r24
    296a:	99 1f       	adc	r25, r25
    296c:	82 0f       	add	r24, r18
    296e:	93 1f       	adc	r25, r19
    2970:	fc 01       	movw	r30, r24
    2972:	eb 50       	subi	r30, 0x0B	; 11
    2974:	fd 4f       	sbci	r31, 0xFD	; 253
    2976:	80 81       	ld	r24, Z
    2978:	88 23       	and	r24, r24
    297a:	59 f3       	breq	.-42     	; 0x2952 <vTaskSwitchContext+0x28>
    297c:	8b 81       	ldd	r24, Y+3	; 0x03
    297e:	28 2f       	mov	r18, r24
    2980:	30 e0       	ldi	r19, 0x00	; 0
    2982:	c9 01       	movw	r24, r18
    2984:	88 0f       	add	r24, r24
    2986:	99 1f       	adc	r25, r25
    2988:	88 0f       	add	r24, r24
    298a:	99 1f       	adc	r25, r25
    298c:	88 0f       	add	r24, r24
    298e:	99 1f       	adc	r25, r25
    2990:	82 0f       	add	r24, r18
    2992:	93 1f       	adc	r25, r19
    2994:	8b 50       	subi	r24, 0x0B	; 11
    2996:	9d 4f       	sbci	r25, 0xFD	; 253
    2998:	9a 83       	std	Y+2, r25	; 0x02
    299a:	89 83       	std	Y+1, r24	; 0x01
    299c:	e9 81       	ldd	r30, Y+1	; 0x01
    299e:	fa 81       	ldd	r31, Y+2	; 0x02
    29a0:	01 80       	ldd	r0, Z+1	; 0x01
    29a2:	f2 81       	ldd	r31, Z+2	; 0x02
    29a4:	e0 2d       	mov	r30, r0
    29a6:	82 81       	ldd	r24, Z+2	; 0x02
    29a8:	93 81       	ldd	r25, Z+3	; 0x03
    29aa:	e9 81       	ldd	r30, Y+1	; 0x01
    29ac:	fa 81       	ldd	r31, Y+2	; 0x02
    29ae:	92 83       	std	Z+2, r25	; 0x02
    29b0:	81 83       	std	Z+1, r24	; 0x01
    29b2:	e9 81       	ldd	r30, Y+1	; 0x01
    29b4:	fa 81       	ldd	r31, Y+2	; 0x02
    29b6:	21 81       	ldd	r18, Z+1	; 0x01
    29b8:	32 81       	ldd	r19, Z+2	; 0x02
    29ba:	89 81       	ldd	r24, Y+1	; 0x01
    29bc:	9a 81       	ldd	r25, Y+2	; 0x02
    29be:	03 96       	adiw	r24, 0x03	; 3
    29c0:	28 17       	cp	r18, r24
    29c2:	39 07       	cpc	r19, r25
    29c4:	59 f4       	brne	.+22     	; 0x29dc <vTaskSwitchContext+0xb2>
    29c6:	e9 81       	ldd	r30, Y+1	; 0x01
    29c8:	fa 81       	ldd	r31, Y+2	; 0x02
    29ca:	01 80       	ldd	r0, Z+1	; 0x01
    29cc:	f2 81       	ldd	r31, Z+2	; 0x02
    29ce:	e0 2d       	mov	r30, r0
    29d0:	82 81       	ldd	r24, Z+2	; 0x02
    29d2:	93 81       	ldd	r25, Z+3	; 0x03
    29d4:	e9 81       	ldd	r30, Y+1	; 0x01
    29d6:	fa 81       	ldd	r31, Y+2	; 0x02
    29d8:	92 83       	std	Z+2, r25	; 0x02
    29da:	81 83       	std	Z+1, r24	; 0x01
    29dc:	e9 81       	ldd	r30, Y+1	; 0x01
    29de:	fa 81       	ldd	r31, Y+2	; 0x02
    29e0:	01 80       	ldd	r0, Z+1	; 0x01
    29e2:	f2 81       	ldd	r31, Z+2	; 0x02
    29e4:	e0 2d       	mov	r30, r0
    29e6:	86 81       	ldd	r24, Z+6	; 0x06
    29e8:	97 81       	ldd	r25, Z+7	; 0x07
    29ea:	90 93 e5 02 	sts	0x02E5, r25
    29ee:	80 93 e4 02 	sts	0x02E4, r24
    29f2:	8b 81       	ldd	r24, Y+3	; 0x03
    29f4:	80 93 ea 02 	sts	0x02EA, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    29f8:	0f 90       	pop	r0
    29fa:	0f 90       	pop	r0
    29fc:	0f 90       	pop	r0
    29fe:	cf 91       	pop	r28
    2a00:	df 91       	pop	r29
    2a02:	08 95       	ret

00002a04 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2a04:	df 93       	push	r29
    2a06:	cf 93       	push	r28
    2a08:	00 d0       	rcall	.+0      	; 0x2a0a <vTaskPlaceOnEventList+0x6>
    2a0a:	00 d0       	rcall	.+0      	; 0x2a0c <vTaskPlaceOnEventList+0x8>
    2a0c:	cd b7       	in	r28, 0x3d	; 61
    2a0e:	de b7       	in	r29, 0x3e	; 62
    2a10:	9a 83       	std	Y+2, r25	; 0x02
    2a12:	89 83       	std	Y+1, r24	; 0x01
    2a14:	7c 83       	std	Y+4, r23	; 0x04
    2a16:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2a18:	80 91 e4 02 	lds	r24, 0x02E4
    2a1c:	90 91 e5 02 	lds	r25, 0x02E5
    2a20:	9c 01       	movw	r18, r24
    2a22:	24 5f       	subi	r18, 0xF4	; 244
    2a24:	3f 4f       	sbci	r19, 0xFF	; 255
    2a26:	89 81       	ldd	r24, Y+1	; 0x01
    2a28:	9a 81       	ldd	r25, Y+2	; 0x02
    2a2a:	b9 01       	movw	r22, r18
    2a2c:	0e 94 16 05 	call	0xa2c	; 0xa2c <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2a30:	8b 81       	ldd	r24, Y+3	; 0x03
    2a32:	9c 81       	ldd	r25, Y+4	; 0x04
    2a34:	61 e0       	ldi	r22, 0x01	; 1
    2a36:	0e 94 46 1b 	call	0x368c	; 0x368c <prvAddCurrentTaskToDelayedList>
}
    2a3a:	0f 90       	pop	r0
    2a3c:	0f 90       	pop	r0
    2a3e:	0f 90       	pop	r0
    2a40:	0f 90       	pop	r0
    2a42:	cf 91       	pop	r28
    2a44:	df 91       	pop	r29
    2a46:	08 95       	ret

00002a48 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    2a48:	df 93       	push	r29
    2a4a:	cf 93       	push	r28
    2a4c:	00 d0       	rcall	.+0      	; 0x2a4e <vTaskPlaceOnUnorderedEventList+0x6>
    2a4e:	00 d0       	rcall	.+0      	; 0x2a50 <vTaskPlaceOnUnorderedEventList+0x8>
    2a50:	00 d0       	rcall	.+0      	; 0x2a52 <vTaskPlaceOnUnorderedEventList+0xa>
    2a52:	cd b7       	in	r28, 0x3d	; 61
    2a54:	de b7       	in	r29, 0x3e	; 62
    2a56:	9a 83       	std	Y+2, r25	; 0x02
    2a58:	89 83       	std	Y+1, r24	; 0x01
    2a5a:	7c 83       	std	Y+4, r23	; 0x04
    2a5c:	6b 83       	std	Y+3, r22	; 0x03
    2a5e:	5e 83       	std	Y+6, r21	; 0x06
    2a60:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2a62:	e0 91 e4 02 	lds	r30, 0x02E4
    2a66:	f0 91 e5 02 	lds	r31, 0x02E5
    2a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6e:	90 68       	ori	r25, 0x80	; 128
    2a70:	95 87       	std	Z+13, r25	; 0x0d
    2a72:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2a74:	80 91 e4 02 	lds	r24, 0x02E4
    2a78:	90 91 e5 02 	lds	r25, 0x02E5
    2a7c:	9c 01       	movw	r18, r24
    2a7e:	24 5f       	subi	r18, 0xF4	; 244
    2a80:	3f 4f       	sbci	r19, 0xFF	; 255
    2a82:	89 81       	ldd	r24, Y+1	; 0x01
    2a84:	9a 81       	ldd	r25, Y+2	; 0x02
    2a86:	b9 01       	movw	r22, r18
    2a88:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2a8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a8e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a90:	61 e0       	ldi	r22, 0x01	; 1
    2a92:	0e 94 46 1b 	call	0x368c	; 0x368c <prvAddCurrentTaskToDelayedList>
}
    2a96:	26 96       	adiw	r28, 0x06	; 6
    2a98:	0f b6       	in	r0, 0x3f	; 63
    2a9a:	f8 94       	cli
    2a9c:	de bf       	out	0x3e, r29	; 62
    2a9e:	0f be       	out	0x3f, r0	; 63
    2aa0:	cd bf       	out	0x3d, r28	; 61
    2aa2:	cf 91       	pop	r28
    2aa4:	df 91       	pop	r29
    2aa6:	08 95       	ret

00002aa8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2aa8:	df 93       	push	r29
    2aaa:	cf 93       	push	r28
    2aac:	00 d0       	rcall	.+0      	; 0x2aae <xTaskRemoveFromEventList+0x6>
    2aae:	00 d0       	rcall	.+0      	; 0x2ab0 <xTaskRemoveFromEventList+0x8>
    2ab0:	0f 92       	push	r0
    2ab2:	cd b7       	in	r28, 0x3d	; 61
    2ab4:	de b7       	in	r29, 0x3e	; 62
    2ab6:	9d 83       	std	Y+5, r25	; 0x05
    2ab8:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2aba:	ec 81       	ldd	r30, Y+4	; 0x04
    2abc:	fd 81       	ldd	r31, Y+5	; 0x05
    2abe:	05 80       	ldd	r0, Z+5	; 0x05
    2ac0:	f6 81       	ldd	r31, Z+6	; 0x06
    2ac2:	e0 2d       	mov	r30, r0
    2ac4:	86 81       	ldd	r24, Z+6	; 0x06
    2ac6:	97 81       	ldd	r25, Z+7	; 0x07
    2ac8:	9b 83       	std	Y+3, r25	; 0x03
    2aca:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2acc:	8a 81       	ldd	r24, Y+2	; 0x02
    2ace:	9b 81       	ldd	r25, Y+3	; 0x03
    2ad0:	0c 96       	adiw	r24, 0x0c	; 12
    2ad2:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2ad6:	80 91 f4 02 	lds	r24, 0x02F4
    2ada:	88 23       	and	r24, r24
    2adc:	61 f5       	brne	.+88     	; 0x2b36 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2ade:	8a 81       	ldd	r24, Y+2	; 0x02
    2ae0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ae2:	02 96       	adiw	r24, 0x02	; 2
    2ae4:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    2ae8:	ea 81       	ldd	r30, Y+2	; 0x02
    2aea:	fb 81       	ldd	r31, Y+3	; 0x03
    2aec:	96 89       	ldd	r25, Z+22	; 0x16
    2aee:	80 91 ea 02 	lds	r24, 0x02EA
    2af2:	89 17       	cp	r24, r25
    2af4:	28 f4       	brcc	.+10     	; 0x2b00 <xTaskRemoveFromEventList+0x58>
    2af6:	ea 81       	ldd	r30, Y+2	; 0x02
    2af8:	fb 81       	ldd	r31, Y+3	; 0x03
    2afa:	86 89       	ldd	r24, Z+22	; 0x16
    2afc:	80 93 ea 02 	sts	0x02EA, r24
    2b00:	ea 81       	ldd	r30, Y+2	; 0x02
    2b02:	fb 81       	ldd	r31, Y+3	; 0x03
    2b04:	86 89       	ldd	r24, Z+22	; 0x16
    2b06:	28 2f       	mov	r18, r24
    2b08:	30 e0       	ldi	r19, 0x00	; 0
    2b0a:	c9 01       	movw	r24, r18
    2b0c:	88 0f       	add	r24, r24
    2b0e:	99 1f       	adc	r25, r25
    2b10:	88 0f       	add	r24, r24
    2b12:	99 1f       	adc	r25, r25
    2b14:	88 0f       	add	r24, r24
    2b16:	99 1f       	adc	r25, r25
    2b18:	82 0f       	add	r24, r18
    2b1a:	93 1f       	adc	r25, r19
    2b1c:	ac 01       	movw	r20, r24
    2b1e:	4b 50       	subi	r20, 0x0B	; 11
    2b20:	5d 4f       	sbci	r21, 0xFD	; 253
    2b22:	8a 81       	ldd	r24, Y+2	; 0x02
    2b24:	9b 81       	ldd	r25, Y+3	; 0x03
    2b26:	9c 01       	movw	r18, r24
    2b28:	2e 5f       	subi	r18, 0xFE	; 254
    2b2a:	3f 4f       	sbci	r19, 0xFF	; 255
    2b2c:	ca 01       	movw	r24, r20
    2b2e:	b9 01       	movw	r22, r18
    2b30:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>
    2b34:	0a c0       	rjmp	.+20     	; 0x2b4a <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2b36:	8a 81       	ldd	r24, Y+2	; 0x02
    2b38:	9b 81       	ldd	r25, Y+3	; 0x03
    2b3a:	9c 01       	movw	r18, r24
    2b3c:	24 5f       	subi	r18, 0xF4	; 244
    2b3e:	3f 4f       	sbci	r19, 0xFF	; 255
    2b40:	8f e2       	ldi	r24, 0x2F	; 47
    2b42:	93 e0       	ldi	r25, 0x03	; 3
    2b44:	b9 01       	movw	r22, r18
    2b46:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2b4a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b4c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b4e:	96 89       	ldd	r25, Z+22	; 0x16
    2b50:	e0 91 e4 02 	lds	r30, 0x02E4
    2b54:	f0 91 e5 02 	lds	r31, 0x02E5
    2b58:	86 89       	ldd	r24, Z+22	; 0x16
    2b5a:	89 17       	cp	r24, r25
    2b5c:	30 f4       	brcc	.+12     	; 0x2b6a <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    2b5e:	81 e0       	ldi	r24, 0x01	; 1
    2b60:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2b62:	81 e0       	ldi	r24, 0x01	; 1
    2b64:	80 93 ed 02 	sts	0x02ED, r24
    2b68:	01 c0       	rjmp	.+2      	; 0x2b6c <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    2b6a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2b6c:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b6e:	0f 90       	pop	r0
    2b70:	0f 90       	pop	r0
    2b72:	0f 90       	pop	r0
    2b74:	0f 90       	pop	r0
    2b76:	0f 90       	pop	r0
    2b78:	cf 91       	pop	r28
    2b7a:	df 91       	pop	r29
    2b7c:	08 95       	ret

00002b7e <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    2b7e:	df 93       	push	r29
    2b80:	cf 93       	push	r28
    2b82:	00 d0       	rcall	.+0      	; 0x2b84 <vTaskRemoveFromUnorderedEventList+0x6>
    2b84:	00 d0       	rcall	.+0      	; 0x2b86 <vTaskRemoveFromUnorderedEventList+0x8>
    2b86:	00 d0       	rcall	.+0      	; 0x2b88 <vTaskRemoveFromUnorderedEventList+0xa>
    2b88:	cd b7       	in	r28, 0x3d	; 61
    2b8a:	de b7       	in	r29, 0x3e	; 62
    2b8c:	9c 83       	std	Y+4, r25	; 0x04
    2b8e:	8b 83       	std	Y+3, r24	; 0x03
    2b90:	7e 83       	std	Y+6, r23	; 0x06
    2b92:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2b94:	8d 81       	ldd	r24, Y+5	; 0x05
    2b96:	9e 81       	ldd	r25, Y+6	; 0x06
    2b98:	90 68       	ori	r25, 0x80	; 128
    2b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b9e:	91 83       	std	Z+1, r25	; 0x01
    2ba0:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2ba2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ba4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ba6:	86 81       	ldd	r24, Z+6	; 0x06
    2ba8:	97 81       	ldd	r25, Z+7	; 0x07
    2baa:	9a 83       	std	Y+2, r25	; 0x02
    2bac:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2bae:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb2:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2bb6:	89 81       	ldd	r24, Y+1	; 0x01
    2bb8:	9a 81       	ldd	r25, Y+2	; 0x02
    2bba:	02 96       	adiw	r24, 0x02	; 2
    2bbc:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2bc0:	e9 81       	ldd	r30, Y+1	; 0x01
    2bc2:	fa 81       	ldd	r31, Y+2	; 0x02
    2bc4:	96 89       	ldd	r25, Z+22	; 0x16
    2bc6:	80 91 ea 02 	lds	r24, 0x02EA
    2bca:	89 17       	cp	r24, r25
    2bcc:	28 f4       	brcc	.+10     	; 0x2bd8 <vTaskRemoveFromUnorderedEventList+0x5a>
    2bce:	e9 81       	ldd	r30, Y+1	; 0x01
    2bd0:	fa 81       	ldd	r31, Y+2	; 0x02
    2bd2:	86 89       	ldd	r24, Z+22	; 0x16
    2bd4:	80 93 ea 02 	sts	0x02EA, r24
    2bd8:	e9 81       	ldd	r30, Y+1	; 0x01
    2bda:	fa 81       	ldd	r31, Y+2	; 0x02
    2bdc:	86 89       	ldd	r24, Z+22	; 0x16
    2bde:	28 2f       	mov	r18, r24
    2be0:	30 e0       	ldi	r19, 0x00	; 0
    2be2:	c9 01       	movw	r24, r18
    2be4:	88 0f       	add	r24, r24
    2be6:	99 1f       	adc	r25, r25
    2be8:	88 0f       	add	r24, r24
    2bea:	99 1f       	adc	r25, r25
    2bec:	88 0f       	add	r24, r24
    2bee:	99 1f       	adc	r25, r25
    2bf0:	82 0f       	add	r24, r18
    2bf2:	93 1f       	adc	r25, r19
    2bf4:	ac 01       	movw	r20, r24
    2bf6:	4b 50       	subi	r20, 0x0B	; 11
    2bf8:	5d 4f       	sbci	r21, 0xFD	; 253
    2bfa:	89 81       	ldd	r24, Y+1	; 0x01
    2bfc:	9a 81       	ldd	r25, Y+2	; 0x02
    2bfe:	9c 01       	movw	r18, r24
    2c00:	2e 5f       	subi	r18, 0xFE	; 254
    2c02:	3f 4f       	sbci	r19, 0xFF	; 255
    2c04:	ca 01       	movw	r24, r20
    2c06:	b9 01       	movw	r22, r18
    2c08:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2c0c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c0e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c10:	96 89       	ldd	r25, Z+22	; 0x16
    2c12:	e0 91 e4 02 	lds	r30, 0x02E4
    2c16:	f0 91 e5 02 	lds	r31, 0x02E5
    2c1a:	86 89       	ldd	r24, Z+22	; 0x16
    2c1c:	89 17       	cp	r24, r25
    2c1e:	18 f4       	brcc	.+6      	; 0x2c26 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    2c20:	81 e0       	ldi	r24, 0x01	; 1
    2c22:	80 93 ed 02 	sts	0x02ED, r24
	}
}
    2c26:	26 96       	adiw	r28, 0x06	; 6
    2c28:	0f b6       	in	r0, 0x3f	; 63
    2c2a:	f8 94       	cli
    2c2c:	de bf       	out	0x3e, r29	; 62
    2c2e:	0f be       	out	0x3f, r0	; 63
    2c30:	cd bf       	out	0x3d, r28	; 61
    2c32:	cf 91       	pop	r28
    2c34:	df 91       	pop	r29
    2c36:	08 95       	ret

00002c38 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2c38:	df 93       	push	r29
    2c3a:	cf 93       	push	r28
    2c3c:	00 d0       	rcall	.+0      	; 0x2c3e <vTaskSetTimeOutState+0x6>
    2c3e:	cd b7       	in	r28, 0x3d	; 61
    2c40:	de b7       	in	r29, 0x3e	; 62
    2c42:	9a 83       	std	Y+2, r25	; 0x02
    2c44:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    2c46:	0f b6       	in	r0, 0x3f	; 63
    2c48:	f8 94       	cli
    2c4a:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    2c4c:	80 91 ee 02 	lds	r24, 0x02EE
    2c50:	e9 81       	ldd	r30, Y+1	; 0x01
    2c52:	fa 81       	ldd	r31, Y+2	; 0x02
    2c54:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    2c56:	80 91 e8 02 	lds	r24, 0x02E8
    2c5a:	90 91 e9 02 	lds	r25, 0x02E9
    2c5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c60:	fa 81       	ldd	r31, Y+2	; 0x02
    2c62:	92 83       	std	Z+2, r25	; 0x02
    2c64:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2c66:	0f 90       	pop	r0
    2c68:	0f be       	out	0x3f, r0	; 63
}
    2c6a:	0f 90       	pop	r0
    2c6c:	0f 90       	pop	r0
    2c6e:	cf 91       	pop	r28
    2c70:	df 91       	pop	r29
    2c72:	08 95       	ret

00002c74 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2c74:	df 93       	push	r29
    2c76:	cf 93       	push	r28
    2c78:	00 d0       	rcall	.+0      	; 0x2c7a <vTaskInternalSetTimeOutState+0x6>
    2c7a:	cd b7       	in	r28, 0x3d	; 61
    2c7c:	de b7       	in	r29, 0x3e	; 62
    2c7e:	9a 83       	std	Y+2, r25	; 0x02
    2c80:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2c82:	80 91 ee 02 	lds	r24, 0x02EE
    2c86:	e9 81       	ldd	r30, Y+1	; 0x01
    2c88:	fa 81       	ldd	r31, Y+2	; 0x02
    2c8a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2c8c:	80 91 e8 02 	lds	r24, 0x02E8
    2c90:	90 91 e9 02 	lds	r25, 0x02E9
    2c94:	e9 81       	ldd	r30, Y+1	; 0x01
    2c96:	fa 81       	ldd	r31, Y+2	; 0x02
    2c98:	92 83       	std	Z+2, r25	; 0x02
    2c9a:	81 83       	std	Z+1, r24	; 0x01
}
    2c9c:	0f 90       	pop	r0
    2c9e:	0f 90       	pop	r0
    2ca0:	cf 91       	pop	r28
    2ca2:	df 91       	pop	r29
    2ca4:	08 95       	ret

00002ca6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2ca6:	df 93       	push	r29
    2ca8:	cf 93       	push	r28
    2caa:	cd b7       	in	r28, 0x3d	; 61
    2cac:	de b7       	in	r29, 0x3e	; 62
    2cae:	29 97       	sbiw	r28, 0x09	; 9
    2cb0:	0f b6       	in	r0, 0x3f	; 63
    2cb2:	f8 94       	cli
    2cb4:	de bf       	out	0x3e, r29	; 62
    2cb6:	0f be       	out	0x3f, r0	; 63
    2cb8:	cd bf       	out	0x3d, r28	; 61
    2cba:	9f 83       	std	Y+7, r25	; 0x07
    2cbc:	8e 83       	std	Y+6, r24	; 0x06
    2cbe:	79 87       	std	Y+9, r23	; 0x09
    2cc0:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2cc2:	0f b6       	in	r0, 0x3f	; 63
    2cc4:	f8 94       	cli
    2cc6:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2cc8:	80 91 e8 02 	lds	r24, 0x02E8
    2ccc:	90 91 e9 02 	lds	r25, 0x02E9
    2cd0:	9c 83       	std	Y+4, r25	; 0x04
    2cd2:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2cd4:	ee 81       	ldd	r30, Y+6	; 0x06
    2cd6:	ff 81       	ldd	r31, Y+7	; 0x07
    2cd8:	21 81       	ldd	r18, Z+1	; 0x01
    2cda:	32 81       	ldd	r19, Z+2	; 0x02
    2cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cde:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce0:	82 1b       	sub	r24, r18
    2ce2:	93 0b       	sbc	r25, r19
    2ce4:	9a 83       	std	Y+2, r25	; 0x02
    2ce6:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2ce8:	ee 81       	ldd	r30, Y+6	; 0x06
    2cea:	ff 81       	ldd	r31, Y+7	; 0x07
    2cec:	90 81       	ld	r25, Z
    2cee:	80 91 ee 02 	lds	r24, 0x02EE
    2cf2:	98 17       	cp	r25, r24
    2cf4:	61 f0       	breq	.+24     	; 0x2d0e <xTaskCheckForTimeOut+0x68>
    2cf6:	ee 81       	ldd	r30, Y+6	; 0x06
    2cf8:	ff 81       	ldd	r31, Y+7	; 0x07
    2cfa:	21 81       	ldd	r18, Z+1	; 0x01
    2cfc:	32 81       	ldd	r19, Z+2	; 0x02
    2cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2d00:	9c 81       	ldd	r25, Y+4	; 0x04
    2d02:	82 17       	cp	r24, r18
    2d04:	93 07       	cpc	r25, r19
    2d06:	18 f0       	brcs	.+6      	; 0x2d0e <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2d08:	81 e0       	ldi	r24, 0x01	; 1
    2d0a:	8d 83       	std	Y+5, r24	; 0x05
    2d0c:	23 c0       	rjmp	.+70     	; 0x2d54 <xTaskCheckForTimeOut+0xae>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    2d0e:	e8 85       	ldd	r30, Y+8	; 0x08
    2d10:	f9 85       	ldd	r31, Y+9	; 0x09
    2d12:	20 81       	ld	r18, Z
    2d14:	31 81       	ldd	r19, Z+1	; 0x01
    2d16:	89 81       	ldd	r24, Y+1	; 0x01
    2d18:	9a 81       	ldd	r25, Y+2	; 0x02
    2d1a:	82 17       	cp	r24, r18
    2d1c:	93 07       	cpc	r25, r19
    2d1e:	a0 f4       	brcc	.+40     	; 0x2d48 <xTaskCheckForTimeOut+0xa2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    2d20:	e8 85       	ldd	r30, Y+8	; 0x08
    2d22:	f9 85       	ldd	r31, Y+9	; 0x09
    2d24:	20 81       	ld	r18, Z
    2d26:	31 81       	ldd	r19, Z+1	; 0x01
    2d28:	89 81       	ldd	r24, Y+1	; 0x01
    2d2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d2c:	a9 01       	movw	r20, r18
    2d2e:	48 1b       	sub	r20, r24
    2d30:	59 0b       	sbc	r21, r25
    2d32:	ca 01       	movw	r24, r20
    2d34:	e8 85       	ldd	r30, Y+8	; 0x08
    2d36:	f9 85       	ldd	r31, Y+9	; 0x09
    2d38:	91 83       	std	Z+1, r25	; 0x01
    2d3a:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    2d3c:	8e 81       	ldd	r24, Y+6	; 0x06
    2d3e:	9f 81       	ldd	r25, Y+7	; 0x07
    2d40:	0e 94 3a 16 	call	0x2c74	; 0x2c74 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    2d44:	1d 82       	std	Y+5, r1	; 0x05
    2d46:	06 c0       	rjmp	.+12     	; 0x2d54 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			*pxTicksToWait = 0;
    2d48:	e8 85       	ldd	r30, Y+8	; 0x08
    2d4a:	f9 85       	ldd	r31, Y+9	; 0x09
    2d4c:	11 82       	std	Z+1, r1	; 0x01
    2d4e:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    2d50:	81 e0       	ldi	r24, 0x01	; 1
    2d52:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    2d54:	0f 90       	pop	r0
    2d56:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2d58:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2d5a:	29 96       	adiw	r28, 0x09	; 9
    2d5c:	0f b6       	in	r0, 0x3f	; 63
    2d5e:	f8 94       	cli
    2d60:	de bf       	out	0x3e, r29	; 62
    2d62:	0f be       	out	0x3f, r0	; 63
    2d64:	cd bf       	out	0x3d, r28	; 61
    2d66:	cf 91       	pop	r28
    2d68:	df 91       	pop	r29
    2d6a:	08 95       	ret

00002d6c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2d6c:	df 93       	push	r29
    2d6e:	cf 93       	push	r28
    2d70:	cd b7       	in	r28, 0x3d	; 61
    2d72:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    2d74:	81 e0       	ldi	r24, 0x01	; 1
    2d76:	80 93 ed 02 	sts	0x02ED, r24
}
    2d7a:	cf 91       	pop	r28
    2d7c:	df 91       	pop	r29
    2d7e:	08 95       	ret

00002d80 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2d80:	df 93       	push	r29
    2d82:	cf 93       	push	r28
    2d84:	00 d0       	rcall	.+0      	; 0x2d86 <prvIdleTask+0x6>
    2d86:	cd b7       	in	r28, 0x3d	; 61
    2d88:	de b7       	in	r29, 0x3e	; 62
    2d8a:	9a 83       	std	Y+2, r25	; 0x02
    2d8c:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    2d8e:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <prvCheckTasksWaitingTermination>
    2d92:	fd cf       	rjmp	.-6      	; 0x2d8e <prvIdleTask+0xe>

00002d94 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    2d94:	df 93       	push	r29
    2d96:	cf 93       	push	r28
    2d98:	0f 92       	push	r0
    2d9a:	cd b7       	in	r28, 0x3d	; 61
    2d9c:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2d9e:	19 82       	std	Y+1, r1	; 0x01
    2da0:	13 c0       	rjmp	.+38     	; 0x2dc8 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    2da2:	89 81       	ldd	r24, Y+1	; 0x01
    2da4:	28 2f       	mov	r18, r24
    2da6:	30 e0       	ldi	r19, 0x00	; 0
    2da8:	c9 01       	movw	r24, r18
    2daa:	88 0f       	add	r24, r24
    2dac:	99 1f       	adc	r25, r25
    2dae:	88 0f       	add	r24, r24
    2db0:	99 1f       	adc	r25, r25
    2db2:	88 0f       	add	r24, r24
    2db4:	99 1f       	adc	r25, r25
    2db6:	82 0f       	add	r24, r18
    2db8:	93 1f       	adc	r25, r19
    2dba:	8b 50       	subi	r24, 0x0B	; 11
    2dbc:	9d 4f       	sbci	r25, 0xFD	; 253
    2dbe:	0e 94 98 04 	call	0x930	; 0x930 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2dc2:	89 81       	ldd	r24, Y+1	; 0x01
    2dc4:	8f 5f       	subi	r24, 0xFF	; 255
    2dc6:	89 83       	std	Y+1, r24	; 0x01
    2dc8:	89 81       	ldd	r24, Y+1	; 0x01
    2dca:	84 30       	cpi	r24, 0x04	; 4
    2dcc:	50 f3       	brcs	.-44     	; 0x2da2 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    2dce:	89 e1       	ldi	r24, 0x19	; 25
    2dd0:	93 e0       	ldi	r25, 0x03	; 3
    2dd2:	0e 94 98 04 	call	0x930	; 0x930 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    2dd6:	82 e2       	ldi	r24, 0x22	; 34
    2dd8:	93 e0       	ldi	r25, 0x03	; 3
    2dda:	0e 94 98 04 	call	0x930	; 0x930 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    2dde:	8f e2       	ldi	r24, 0x2F	; 47
    2de0:	93 e0       	ldi	r25, 0x03	; 3
    2de2:	0e 94 98 04 	call	0x930	; 0x930 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    2de6:	88 e3       	ldi	r24, 0x38	; 56
    2de8:	93 e0       	ldi	r25, 0x03	; 3
    2dea:	0e 94 98 04 	call	0x930	; 0x930 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2dee:	89 e1       	ldi	r24, 0x19	; 25
    2df0:	93 e0       	ldi	r25, 0x03	; 3
    2df2:	90 93 2c 03 	sts	0x032C, r25
    2df6:	80 93 2b 03 	sts	0x032B, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2dfa:	82 e2       	ldi	r24, 0x22	; 34
    2dfc:	93 e0       	ldi	r25, 0x03	; 3
    2dfe:	90 93 2e 03 	sts	0x032E, r25
    2e02:	80 93 2d 03 	sts	0x032D, r24
}
    2e06:	0f 90       	pop	r0
    2e08:	cf 91       	pop	r28
    2e0a:	df 91       	pop	r29
    2e0c:	08 95       	ret

00002e0e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2e0e:	df 93       	push	r29
    2e10:	cf 93       	push	r28
    2e12:	00 d0       	rcall	.+0      	; 0x2e14 <prvCheckTasksWaitingTermination+0x6>
    2e14:	cd b7       	in	r28, 0x3d	; 61
    2e16:	de b7       	in	r29, 0x3e	; 62
    2e18:	20 c0       	rjmp	.+64     	; 0x2e5a <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    2e1a:	0f b6       	in	r0, 0x3f	; 63
    2e1c:	f8 94       	cli
    2e1e:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2e20:	e0 91 3d 03 	lds	r30, 0x033D
    2e24:	f0 91 3e 03 	lds	r31, 0x033E
    2e28:	86 81       	ldd	r24, Z+6	; 0x06
    2e2a:	97 81       	ldd	r25, Z+7	; 0x07
    2e2c:	9a 83       	std	Y+2, r25	; 0x02
    2e2e:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2e30:	89 81       	ldd	r24, Y+1	; 0x01
    2e32:	9a 81       	ldd	r25, Y+2	; 0x02
    2e34:	02 96       	adiw	r24, 0x02	; 2
    2e36:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
				--uxCurrentNumberOfTasks;
    2e3a:	80 91 e7 02 	lds	r24, 0x02E7
    2e3e:	81 50       	subi	r24, 0x01	; 1
    2e40:	80 93 e7 02 	sts	0x02E7, r24
				--uxDeletedTasksWaitingCleanUp;
    2e44:	80 91 e6 02 	lds	r24, 0x02E6
    2e48:	81 50       	subi	r24, 0x01	; 1
    2e4a:	80 93 e6 02 	sts	0x02E6, r24
			}
			taskEXIT_CRITICAL();
    2e4e:	0f 90       	pop	r0
    2e50:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    2e52:	89 81       	ldd	r24, Y+1	; 0x01
    2e54:	9a 81       	ldd	r25, Y+2	; 0x02
    2e56:	0e 94 36 17 	call	0x2e6c	; 0x2e6c <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    2e5a:	80 91 e6 02 	lds	r24, 0x02E6
    2e5e:	88 23       	and	r24, r24
    2e60:	e1 f6       	brne	.-72     	; 0x2e1a <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    2e62:	0f 90       	pop	r0
    2e64:	0f 90       	pop	r0
    2e66:	cf 91       	pop	r28
    2e68:	df 91       	pop	r29
    2e6a:	08 95       	ret

00002e6c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    2e6c:	df 93       	push	r29
    2e6e:	cf 93       	push	r28
    2e70:	00 d0       	rcall	.+0      	; 0x2e72 <prvDeleteTCB+0x6>
    2e72:	cd b7       	in	r28, 0x3d	; 61
    2e74:	de b7       	in	r29, 0x3e	; 62
    2e76:	9a 83       	std	Y+2, r25	; 0x02
    2e78:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    2e7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e7e:	87 89       	ldd	r24, Z+23	; 0x17
    2e80:	90 8d       	ldd	r25, Z+24	; 0x18
    2e82:	0e 94 72 04 	call	0x8e4	; 0x8e4 <vPortFree>
			vPortFree( pxTCB );
    2e86:	89 81       	ldd	r24, Y+1	; 0x01
    2e88:	9a 81       	ldd	r25, Y+2	; 0x02
    2e8a:	0e 94 72 04 	call	0x8e4	; 0x8e4 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    2e8e:	0f 90       	pop	r0
    2e90:	0f 90       	pop	r0
    2e92:	cf 91       	pop	r28
    2e94:	df 91       	pop	r29
    2e96:	08 95       	ret

00002e98 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    2e98:	df 93       	push	r29
    2e9a:	cf 93       	push	r28
    2e9c:	00 d0       	rcall	.+0      	; 0x2e9e <prvResetNextTaskUnblockTime+0x6>
    2e9e:	cd b7       	in	r28, 0x3d	; 61
    2ea0:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2ea2:	e0 91 2b 03 	lds	r30, 0x032B
    2ea6:	f0 91 2c 03 	lds	r31, 0x032C
    2eaa:	80 81       	ld	r24, Z
    2eac:	88 23       	and	r24, r24
    2eae:	39 f4       	brne	.+14     	; 0x2ebe <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    2eb0:	8f ef       	ldi	r24, 0xFF	; 255
    2eb2:	9f ef       	ldi	r25, 0xFF	; 255
    2eb4:	90 93 f1 02 	sts	0x02F1, r25
    2eb8:	80 93 f0 02 	sts	0x02F0, r24
    2ebc:	13 c0       	rjmp	.+38     	; 0x2ee4 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2ebe:	e0 91 2b 03 	lds	r30, 0x032B
    2ec2:	f0 91 2c 03 	lds	r31, 0x032C
    2ec6:	05 80       	ldd	r0, Z+5	; 0x05
    2ec8:	f6 81       	ldd	r31, Z+6	; 0x06
    2eca:	e0 2d       	mov	r30, r0
    2ecc:	86 81       	ldd	r24, Z+6	; 0x06
    2ece:	97 81       	ldd	r25, Z+7	; 0x07
    2ed0:	9a 83       	std	Y+2, r25	; 0x02
    2ed2:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    2ed4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ed6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed8:	82 81       	ldd	r24, Z+2	; 0x02
    2eda:	93 81       	ldd	r25, Z+3	; 0x03
    2edc:	90 93 f1 02 	sts	0x02F1, r25
    2ee0:	80 93 f0 02 	sts	0x02F0, r24
	}
}
    2ee4:	0f 90       	pop	r0
    2ee6:	0f 90       	pop	r0
    2ee8:	cf 91       	pop	r28
    2eea:	df 91       	pop	r29
    2eec:	08 95       	ret

00002eee <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    2eee:	df 93       	push	r29
    2ef0:	cf 93       	push	r28
    2ef2:	00 d0       	rcall	.+0      	; 0x2ef4 <uxTaskResetEventItemValue+0x6>
    2ef4:	cd b7       	in	r28, 0x3d	; 61
    2ef6:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2ef8:	e0 91 e4 02 	lds	r30, 0x02E4
    2efc:	f0 91 e5 02 	lds	r31, 0x02E5
    2f00:	84 85       	ldd	r24, Z+12	; 0x0c
    2f02:	95 85       	ldd	r25, Z+13	; 0x0d
    2f04:	9a 83       	std	Y+2, r25	; 0x02
    2f06:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2f08:	a0 91 e4 02 	lds	r26, 0x02E4
    2f0c:	b0 91 e5 02 	lds	r27, 0x02E5
    2f10:	e0 91 e4 02 	lds	r30, 0x02E4
    2f14:	f0 91 e5 02 	lds	r31, 0x02E5
    2f18:	86 89       	ldd	r24, Z+22	; 0x16
    2f1a:	28 2f       	mov	r18, r24
    2f1c:	30 e0       	ldi	r19, 0x00	; 0
    2f1e:	84 e0       	ldi	r24, 0x04	; 4
    2f20:	90 e0       	ldi	r25, 0x00	; 0
    2f22:	82 1b       	sub	r24, r18
    2f24:	93 0b       	sbc	r25, r19
    2f26:	1d 96       	adiw	r26, 0x0d	; 13
    2f28:	9c 93       	st	X, r25
    2f2a:	8e 93       	st	-X, r24
    2f2c:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    2f2e:	89 81       	ldd	r24, Y+1	; 0x01
    2f30:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f32:	0f 90       	pop	r0
    2f34:	0f 90       	pop	r0
    2f36:	cf 91       	pop	r28
    2f38:	df 91       	pop	r29
    2f3a:	08 95       	ret

00002f3c <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    2f3c:	df 93       	push	r29
    2f3e:	cf 93       	push	r28
    2f40:	cd b7       	in	r28, 0x3d	; 61
    2f42:	de b7       	in	r29, 0x3e	; 62
    2f44:	27 97       	sbiw	r28, 0x07	; 7
    2f46:	0f b6       	in	r0, 0x3f	; 63
    2f48:	f8 94       	cli
    2f4a:	de bf       	out	0x3e, r29	; 62
    2f4c:	0f be       	out	0x3f, r0	; 63
    2f4e:	cd bf       	out	0x3d, r28	; 61
    2f50:	8d 83       	std	Y+5, r24	; 0x05
    2f52:	7f 83       	std	Y+7, r23	; 0x07
    2f54:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    2f56:	0f b6       	in	r0, 0x3f	; 63
    2f58:	f8 94       	cli
    2f5a:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    2f5c:	e0 91 e4 02 	lds	r30, 0x02E4
    2f60:	f0 91 e5 02 	lds	r31, 0x02E5
    2f64:	81 a1       	ldd	r24, Z+33	; 0x21
    2f66:	92 a1       	ldd	r25, Z+34	; 0x22
    2f68:	a3 a1       	ldd	r26, Z+35	; 0x23
    2f6a:	b4 a1       	ldd	r27, Z+36	; 0x24
    2f6c:	00 97       	sbiw	r24, 0x00	; 0
    2f6e:	a1 05       	cpc	r26, r1
    2f70:	b1 05       	cpc	r27, r1
    2f72:	89 f4       	brne	.+34     	; 0x2f96 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2f74:	e0 91 e4 02 	lds	r30, 0x02E4
    2f78:	f0 91 e5 02 	lds	r31, 0x02E5
    2f7c:	81 e0       	ldi	r24, 0x01	; 1
    2f7e:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    2f80:	8e 81       	ldd	r24, Y+6	; 0x06
    2f82:	9f 81       	ldd	r25, Y+7	; 0x07
    2f84:	00 97       	sbiw	r24, 0x00	; 0
    2f86:	39 f0       	breq	.+14     	; 0x2f96 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2f88:	8e 81       	ldd	r24, Y+6	; 0x06
    2f8a:	9f 81       	ldd	r25, Y+7	; 0x07
    2f8c:	61 e0       	ldi	r22, 0x01	; 1
    2f8e:	0e 94 46 1b 	call	0x368c	; 0x368c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2f92:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2f96:	0f 90       	pop	r0
    2f98:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2f9a:	0f b6       	in	r0, 0x3f	; 63
    2f9c:	f8 94       	cli
    2f9e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    2fa0:	e0 91 e4 02 	lds	r30, 0x02E4
    2fa4:	f0 91 e5 02 	lds	r31, 0x02E5
    2fa8:	81 a1       	ldd	r24, Z+33	; 0x21
    2faa:	92 a1       	ldd	r25, Z+34	; 0x22
    2fac:	a3 a1       	ldd	r26, Z+35	; 0x23
    2fae:	b4 a1       	ldd	r27, Z+36	; 0x24
    2fb0:	89 83       	std	Y+1, r24	; 0x01
    2fb2:	9a 83       	std	Y+2, r25	; 0x02
    2fb4:	ab 83       	std	Y+3, r26	; 0x03
    2fb6:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    2fb8:	89 81       	ldd	r24, Y+1	; 0x01
    2fba:	9a 81       	ldd	r25, Y+2	; 0x02
    2fbc:	ab 81       	ldd	r26, Y+3	; 0x03
    2fbe:	bc 81       	ldd	r27, Y+4	; 0x04
    2fc0:	00 97       	sbiw	r24, 0x00	; 0
    2fc2:	a1 05       	cpc	r26, r1
    2fc4:	b1 05       	cpc	r27, r1
    2fc6:	d9 f0       	breq	.+54     	; 0x2ffe <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    2fc8:	8d 81       	ldd	r24, Y+5	; 0x05
    2fca:	88 23       	and	r24, r24
    2fcc:	49 f0       	breq	.+18     	; 0x2fe0 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    2fce:	e0 91 e4 02 	lds	r30, 0x02E4
    2fd2:	f0 91 e5 02 	lds	r31, 0x02E5
    2fd6:	11 a2       	std	Z+33, r1	; 0x21
    2fd8:	12 a2       	std	Z+34, r1	; 0x22
    2fda:	13 a2       	std	Z+35, r1	; 0x23
    2fdc:	14 a2       	std	Z+36, r1	; 0x24
    2fde:	0f c0       	rjmp	.+30     	; 0x2ffe <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    2fe0:	e0 91 e4 02 	lds	r30, 0x02E4
    2fe4:	f0 91 e5 02 	lds	r31, 0x02E5
    2fe8:	89 81       	ldd	r24, Y+1	; 0x01
    2fea:	9a 81       	ldd	r25, Y+2	; 0x02
    2fec:	ab 81       	ldd	r26, Y+3	; 0x03
    2fee:	bc 81       	ldd	r27, Y+4	; 0x04
    2ff0:	01 97       	sbiw	r24, 0x01	; 1
    2ff2:	a1 09       	sbc	r26, r1
    2ff4:	b1 09       	sbc	r27, r1
    2ff6:	81 a3       	std	Z+33, r24	; 0x21
    2ff8:	92 a3       	std	Z+34, r25	; 0x22
    2ffa:	a3 a3       	std	Z+35, r26	; 0x23
    2ffc:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2ffe:	e0 91 e4 02 	lds	r30, 0x02E4
    3002:	f0 91 e5 02 	lds	r31, 0x02E5
    3006:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3008:	0f 90       	pop	r0
    300a:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    300c:	89 81       	ldd	r24, Y+1	; 0x01
    300e:	9a 81       	ldd	r25, Y+2	; 0x02
    3010:	ab 81       	ldd	r26, Y+3	; 0x03
    3012:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    3014:	bc 01       	movw	r22, r24
    3016:	cd 01       	movw	r24, r26
    3018:	27 96       	adiw	r28, 0x07	; 7
    301a:	0f b6       	in	r0, 0x3f	; 63
    301c:	f8 94       	cli
    301e:	de bf       	out	0x3e, r29	; 62
    3020:	0f be       	out	0x3f, r0	; 63
    3022:	cd bf       	out	0x3d, r28	; 61
    3024:	cf 91       	pop	r28
    3026:	df 91       	pop	r29
    3028:	08 95       	ret

0000302a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    302a:	ef 92       	push	r14
    302c:	ff 92       	push	r15
    302e:	0f 93       	push	r16
    3030:	1f 93       	push	r17
    3032:	df 93       	push	r29
    3034:	cf 93       	push	r28
    3036:	cd b7       	in	r28, 0x3d	; 61
    3038:	de b7       	in	r29, 0x3e	; 62
    303a:	2d 97       	sbiw	r28, 0x0d	; 13
    303c:	0f b6       	in	r0, 0x3f	; 63
    303e:	f8 94       	cli
    3040:	de bf       	out	0x3e, r29	; 62
    3042:	0f be       	out	0x3f, r0	; 63
    3044:	cd bf       	out	0x3d, r28	; 61
    3046:	6a 83       	std	Y+2, r22	; 0x02
    3048:	7b 83       	std	Y+3, r23	; 0x03
    304a:	8c 83       	std	Y+4, r24	; 0x04
    304c:	9d 83       	std	Y+5, r25	; 0x05
    304e:	2e 83       	std	Y+6, r18	; 0x06
    3050:	3f 83       	std	Y+7, r19	; 0x07
    3052:	48 87       	std	Y+8, r20	; 0x08
    3054:	59 87       	std	Y+9, r21	; 0x09
    3056:	1b 87       	std	Y+11, r17	; 0x0b
    3058:	0a 87       	std	Y+10, r16	; 0x0a
    305a:	fd 86       	std	Y+13, r15	; 0x0d
    305c:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    305e:	0f b6       	in	r0, 0x3f	; 63
    3060:	f8 94       	cli
    3062:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    3064:	e0 91 e4 02 	lds	r30, 0x02E4
    3068:	f0 91 e5 02 	lds	r31, 0x02E5
    306c:	85 a1       	ldd	r24, Z+37	; 0x25
    306e:	82 30       	cpi	r24, 0x02	; 2
    3070:	49 f1       	breq	.+82     	; 0x30c4 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    3072:	e0 91 e4 02 	lds	r30, 0x02E4
    3076:	f0 91 e5 02 	lds	r31, 0x02E5
    307a:	21 a1       	ldd	r18, Z+33	; 0x21
    307c:	32 a1       	ldd	r19, Z+34	; 0x22
    307e:	43 a1       	ldd	r20, Z+35	; 0x23
    3080:	54 a1       	ldd	r21, Z+36	; 0x24
    3082:	8a 81       	ldd	r24, Y+2	; 0x02
    3084:	9b 81       	ldd	r25, Y+3	; 0x03
    3086:	ac 81       	ldd	r26, Y+4	; 0x04
    3088:	bd 81       	ldd	r27, Y+5	; 0x05
    308a:	80 95       	com	r24
    308c:	90 95       	com	r25
    308e:	a0 95       	com	r26
    3090:	b0 95       	com	r27
    3092:	82 23       	and	r24, r18
    3094:	93 23       	and	r25, r19
    3096:	a4 23       	and	r26, r20
    3098:	b5 23       	and	r27, r21
    309a:	81 a3       	std	Z+33, r24	; 0x21
    309c:	92 a3       	std	Z+34, r25	; 0x22
    309e:	a3 a3       	std	Z+35, r26	; 0x23
    30a0:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    30a2:	e0 91 e4 02 	lds	r30, 0x02E4
    30a6:	f0 91 e5 02 	lds	r31, 0x02E5
    30aa:	81 e0       	ldi	r24, 0x01	; 1
    30ac:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    30ae:	8c 85       	ldd	r24, Y+12	; 0x0c
    30b0:	9d 85       	ldd	r25, Y+13	; 0x0d
    30b2:	00 97       	sbiw	r24, 0x00	; 0
    30b4:	39 f0       	breq	.+14     	; 0x30c4 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    30b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    30b8:	9d 85       	ldd	r25, Y+13	; 0x0d
    30ba:	61 e0       	ldi	r22, 0x01	; 1
    30bc:	0e 94 46 1b 	call	0x368c	; 0x368c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    30c0:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    30c4:	0f 90       	pop	r0
    30c6:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    30c8:	0f b6       	in	r0, 0x3f	; 63
    30ca:	f8 94       	cli
    30cc:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    30ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    30d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    30d2:	00 97       	sbiw	r24, 0x00	; 0
    30d4:	71 f0       	breq	.+28     	; 0x30f2 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    30d6:	e0 91 e4 02 	lds	r30, 0x02E4
    30da:	f0 91 e5 02 	lds	r31, 0x02E5
    30de:	81 a1       	ldd	r24, Z+33	; 0x21
    30e0:	92 a1       	ldd	r25, Z+34	; 0x22
    30e2:	a3 a1       	ldd	r26, Z+35	; 0x23
    30e4:	b4 a1       	ldd	r27, Z+36	; 0x24
    30e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    30e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    30ea:	80 83       	st	Z, r24
    30ec:	91 83       	std	Z+1, r25	; 0x01
    30ee:	a2 83       	std	Z+2, r26	; 0x02
    30f0:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    30f2:	e0 91 e4 02 	lds	r30, 0x02E4
    30f6:	f0 91 e5 02 	lds	r31, 0x02E5
    30fa:	85 a1       	ldd	r24, Z+37	; 0x25
    30fc:	82 30       	cpi	r24, 0x02	; 2
    30fe:	11 f0       	breq	.+4      	; 0x3104 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    3100:	19 82       	std	Y+1, r1	; 0x01
    3102:	1a c0       	rjmp	.+52     	; 0x3138 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    3104:	e0 91 e4 02 	lds	r30, 0x02E4
    3108:	f0 91 e5 02 	lds	r31, 0x02E5
    310c:	21 a1       	ldd	r18, Z+33	; 0x21
    310e:	32 a1       	ldd	r19, Z+34	; 0x22
    3110:	43 a1       	ldd	r20, Z+35	; 0x23
    3112:	54 a1       	ldd	r21, Z+36	; 0x24
    3114:	8e 81       	ldd	r24, Y+6	; 0x06
    3116:	9f 81       	ldd	r25, Y+7	; 0x07
    3118:	a8 85       	ldd	r26, Y+8	; 0x08
    311a:	b9 85       	ldd	r27, Y+9	; 0x09
    311c:	80 95       	com	r24
    311e:	90 95       	com	r25
    3120:	a0 95       	com	r26
    3122:	b0 95       	com	r27
    3124:	82 23       	and	r24, r18
    3126:	93 23       	and	r25, r19
    3128:	a4 23       	and	r26, r20
    312a:	b5 23       	and	r27, r21
    312c:	81 a3       	std	Z+33, r24	; 0x21
    312e:	92 a3       	std	Z+34, r25	; 0x22
    3130:	a3 a3       	std	Z+35, r26	; 0x23
    3132:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    3134:	81 e0       	ldi	r24, 0x01	; 1
    3136:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3138:	e0 91 e4 02 	lds	r30, 0x02E4
    313c:	f0 91 e5 02 	lds	r31, 0x02E5
    3140:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3142:	0f 90       	pop	r0
    3144:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3146:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3148:	2d 96       	adiw	r28, 0x0d	; 13
    314a:	0f b6       	in	r0, 0x3f	; 63
    314c:	f8 94       	cli
    314e:	de bf       	out	0x3e, r29	; 62
    3150:	0f be       	out	0x3f, r0	; 63
    3152:	cd bf       	out	0x3d, r28	; 61
    3154:	cf 91       	pop	r28
    3156:	df 91       	pop	r29
    3158:	1f 91       	pop	r17
    315a:	0f 91       	pop	r16
    315c:	ff 90       	pop	r15
    315e:	ef 90       	pop	r14
    3160:	08 95       	ret

00003162 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    3162:	0f 93       	push	r16
    3164:	1f 93       	push	r17
    3166:	df 93       	push	r29
    3168:	cf 93       	push	r28
    316a:	cd b7       	in	r28, 0x3d	; 61
    316c:	de b7       	in	r29, 0x3e	; 62
    316e:	2f 97       	sbiw	r28, 0x0f	; 15
    3170:	0f b6       	in	r0, 0x3f	; 63
    3172:	f8 94       	cli
    3174:	de bf       	out	0x3e, r29	; 62
    3176:	0f be       	out	0x3f, r0	; 63
    3178:	cd bf       	out	0x3d, r28	; 61
    317a:	9e 83       	std	Y+6, r25	; 0x06
    317c:	8d 83       	std	Y+5, r24	; 0x05
    317e:	4f 83       	std	Y+7, r20	; 0x07
    3180:	58 87       	std	Y+8, r21	; 0x08
    3182:	69 87       	std	Y+9, r22	; 0x09
    3184:	7a 87       	std	Y+10, r23	; 0x0a
    3186:	2b 87       	std	Y+11, r18	; 0x0b
    3188:	1d 87       	std	Y+13, r17	; 0x0d
    318a:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    318c:	81 e0       	ldi	r24, 0x01	; 1
    318e:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    3190:	8d 81       	ldd	r24, Y+5	; 0x05
    3192:	9e 81       	ldd	r25, Y+6	; 0x06
    3194:	9c 83       	std	Y+4, r25	; 0x04
    3196:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    3198:	0f b6       	in	r0, 0x3f	; 63
    319a:	f8 94       	cli
    319c:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    319e:	8c 85       	ldd	r24, Y+12	; 0x0c
    31a0:	9d 85       	ldd	r25, Y+13	; 0x0d
    31a2:	00 97       	sbiw	r24, 0x00	; 0
    31a4:	61 f0       	breq	.+24     	; 0x31be <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    31a6:	eb 81       	ldd	r30, Y+3	; 0x03
    31a8:	fc 81       	ldd	r31, Y+4	; 0x04
    31aa:	81 a1       	ldd	r24, Z+33	; 0x21
    31ac:	92 a1       	ldd	r25, Z+34	; 0x22
    31ae:	a3 a1       	ldd	r26, Z+35	; 0x23
    31b0:	b4 a1       	ldd	r27, Z+36	; 0x24
    31b2:	ec 85       	ldd	r30, Y+12	; 0x0c
    31b4:	fd 85       	ldd	r31, Y+13	; 0x0d
    31b6:	80 83       	st	Z, r24
    31b8:	91 83       	std	Z+1, r25	; 0x01
    31ba:	a2 83       	std	Z+2, r26	; 0x02
    31bc:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    31be:	eb 81       	ldd	r30, Y+3	; 0x03
    31c0:	fc 81       	ldd	r31, Y+4	; 0x04
    31c2:	85 a1       	ldd	r24, Z+37	; 0x25
    31c4:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    31c6:	eb 81       	ldd	r30, Y+3	; 0x03
    31c8:	fc 81       	ldd	r31, Y+4	; 0x04
    31ca:	82 e0       	ldi	r24, 0x02	; 2
    31cc:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    31ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    31d0:	28 2f       	mov	r18, r24
    31d2:	30 e0       	ldi	r19, 0x00	; 0
    31d4:	3f 87       	std	Y+15, r19	; 0x0f
    31d6:	2e 87       	std	Y+14, r18	; 0x0e
    31d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    31da:	9f 85       	ldd	r25, Y+15	; 0x0f
    31dc:	82 30       	cpi	r24, 0x02	; 2
    31de:	91 05       	cpc	r25, r1
    31e0:	59 f1       	breq	.+86     	; 0x3238 <xTaskGenericNotify+0xd6>
    31e2:	2e 85       	ldd	r18, Y+14	; 0x0e
    31e4:	3f 85       	ldd	r19, Y+15	; 0x0f
    31e6:	23 30       	cpi	r18, 0x03	; 3
    31e8:	31 05       	cpc	r19, r1
    31ea:	34 f4       	brge	.+12     	; 0x31f8 <xTaskGenericNotify+0x96>
    31ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    31ee:	9f 85       	ldd	r25, Y+15	; 0x0f
    31f0:	81 30       	cpi	r24, 0x01	; 1
    31f2:	91 05       	cpc	r25, r1
    31f4:	61 f0       	breq	.+24     	; 0x320e <xTaskGenericNotify+0xac>
    31f6:	4a c0       	rjmp	.+148    	; 0x328c <xTaskGenericNotify+0x12a>
    31f8:	2e 85       	ldd	r18, Y+14	; 0x0e
    31fa:	3f 85       	ldd	r19, Y+15	; 0x0f
    31fc:	23 30       	cpi	r18, 0x03	; 3
    31fe:	31 05       	cpc	r19, r1
    3200:	59 f1       	breq	.+86     	; 0x3258 <xTaskGenericNotify+0xf6>
    3202:	8e 85       	ldd	r24, Y+14	; 0x0e
    3204:	9f 85       	ldd	r25, Y+15	; 0x0f
    3206:	84 30       	cpi	r24, 0x04	; 4
    3208:	91 05       	cpc	r25, r1
    320a:	89 f1       	breq	.+98     	; 0x326e <xTaskGenericNotify+0x10c>
    320c:	3f c0       	rjmp	.+126    	; 0x328c <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    320e:	eb 81       	ldd	r30, Y+3	; 0x03
    3210:	fc 81       	ldd	r31, Y+4	; 0x04
    3212:	21 a1       	ldd	r18, Z+33	; 0x21
    3214:	32 a1       	ldd	r19, Z+34	; 0x22
    3216:	43 a1       	ldd	r20, Z+35	; 0x23
    3218:	54 a1       	ldd	r21, Z+36	; 0x24
    321a:	8f 81       	ldd	r24, Y+7	; 0x07
    321c:	98 85       	ldd	r25, Y+8	; 0x08
    321e:	a9 85       	ldd	r26, Y+9	; 0x09
    3220:	ba 85       	ldd	r27, Y+10	; 0x0a
    3222:	82 2b       	or	r24, r18
    3224:	93 2b       	or	r25, r19
    3226:	a4 2b       	or	r26, r20
    3228:	b5 2b       	or	r27, r21
    322a:	eb 81       	ldd	r30, Y+3	; 0x03
    322c:	fc 81       	ldd	r31, Y+4	; 0x04
    322e:	81 a3       	std	Z+33, r24	; 0x21
    3230:	92 a3       	std	Z+34, r25	; 0x22
    3232:	a3 a3       	std	Z+35, r26	; 0x23
    3234:	b4 a3       	std	Z+36, r27	; 0x24
    3236:	2a c0       	rjmp	.+84     	; 0x328c <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3238:	eb 81       	ldd	r30, Y+3	; 0x03
    323a:	fc 81       	ldd	r31, Y+4	; 0x04
    323c:	81 a1       	ldd	r24, Z+33	; 0x21
    323e:	92 a1       	ldd	r25, Z+34	; 0x22
    3240:	a3 a1       	ldd	r26, Z+35	; 0x23
    3242:	b4 a1       	ldd	r27, Z+36	; 0x24
    3244:	01 96       	adiw	r24, 0x01	; 1
    3246:	a1 1d       	adc	r26, r1
    3248:	b1 1d       	adc	r27, r1
    324a:	eb 81       	ldd	r30, Y+3	; 0x03
    324c:	fc 81       	ldd	r31, Y+4	; 0x04
    324e:	81 a3       	std	Z+33, r24	; 0x21
    3250:	92 a3       	std	Z+34, r25	; 0x22
    3252:	a3 a3       	std	Z+35, r26	; 0x23
    3254:	b4 a3       	std	Z+36, r27	; 0x24
    3256:	1a c0       	rjmp	.+52     	; 0x328c <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3258:	eb 81       	ldd	r30, Y+3	; 0x03
    325a:	fc 81       	ldd	r31, Y+4	; 0x04
    325c:	8f 81       	ldd	r24, Y+7	; 0x07
    325e:	98 85       	ldd	r25, Y+8	; 0x08
    3260:	a9 85       	ldd	r26, Y+9	; 0x09
    3262:	ba 85       	ldd	r27, Y+10	; 0x0a
    3264:	81 a3       	std	Z+33, r24	; 0x21
    3266:	92 a3       	std	Z+34, r25	; 0x22
    3268:	a3 a3       	std	Z+35, r26	; 0x23
    326a:	b4 a3       	std	Z+36, r27	; 0x24
    326c:	0f c0       	rjmp	.+30     	; 0x328c <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    326e:	89 81       	ldd	r24, Y+1	; 0x01
    3270:	82 30       	cpi	r24, 0x02	; 2
    3272:	59 f0       	breq	.+22     	; 0x328a <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3274:	eb 81       	ldd	r30, Y+3	; 0x03
    3276:	fc 81       	ldd	r31, Y+4	; 0x04
    3278:	8f 81       	ldd	r24, Y+7	; 0x07
    327a:	98 85       	ldd	r25, Y+8	; 0x08
    327c:	a9 85       	ldd	r26, Y+9	; 0x09
    327e:	ba 85       	ldd	r27, Y+10	; 0x0a
    3280:	81 a3       	std	Z+33, r24	; 0x21
    3282:	92 a3       	std	Z+34, r25	; 0x22
    3284:	a3 a3       	std	Z+35, r26	; 0x23
    3286:	b4 a3       	std	Z+36, r27	; 0x24
    3288:	01 c0       	rjmp	.+2      	; 0x328c <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    328a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    328c:	89 81       	ldd	r24, Y+1	; 0x01
    328e:	81 30       	cpi	r24, 0x01	; 1
    3290:	b9 f5       	brne	.+110    	; 0x3300 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3292:	8b 81       	ldd	r24, Y+3	; 0x03
    3294:	9c 81       	ldd	r25, Y+4	; 0x04
    3296:	02 96       	adiw	r24, 0x02	; 2
    3298:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    329c:	eb 81       	ldd	r30, Y+3	; 0x03
    329e:	fc 81       	ldd	r31, Y+4	; 0x04
    32a0:	96 89       	ldd	r25, Z+22	; 0x16
    32a2:	80 91 ea 02 	lds	r24, 0x02EA
    32a6:	89 17       	cp	r24, r25
    32a8:	28 f4       	brcc	.+10     	; 0x32b4 <xTaskGenericNotify+0x152>
    32aa:	eb 81       	ldd	r30, Y+3	; 0x03
    32ac:	fc 81       	ldd	r31, Y+4	; 0x04
    32ae:	86 89       	ldd	r24, Z+22	; 0x16
    32b0:	80 93 ea 02 	sts	0x02EA, r24
    32b4:	eb 81       	ldd	r30, Y+3	; 0x03
    32b6:	fc 81       	ldd	r31, Y+4	; 0x04
    32b8:	86 89       	ldd	r24, Z+22	; 0x16
    32ba:	28 2f       	mov	r18, r24
    32bc:	30 e0       	ldi	r19, 0x00	; 0
    32be:	c9 01       	movw	r24, r18
    32c0:	88 0f       	add	r24, r24
    32c2:	99 1f       	adc	r25, r25
    32c4:	88 0f       	add	r24, r24
    32c6:	99 1f       	adc	r25, r25
    32c8:	88 0f       	add	r24, r24
    32ca:	99 1f       	adc	r25, r25
    32cc:	82 0f       	add	r24, r18
    32ce:	93 1f       	adc	r25, r19
    32d0:	ac 01       	movw	r20, r24
    32d2:	4b 50       	subi	r20, 0x0B	; 11
    32d4:	5d 4f       	sbci	r21, 0xFD	; 253
    32d6:	8b 81       	ldd	r24, Y+3	; 0x03
    32d8:	9c 81       	ldd	r25, Y+4	; 0x04
    32da:	9c 01       	movw	r18, r24
    32dc:	2e 5f       	subi	r18, 0xFE	; 254
    32de:	3f 4f       	sbci	r19, 0xFF	; 255
    32e0:	ca 01       	movw	r24, r20
    32e2:	b9 01       	movw	r22, r18
    32e4:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    32e8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ea:	fc 81       	ldd	r31, Y+4	; 0x04
    32ec:	96 89       	ldd	r25, Z+22	; 0x16
    32ee:	e0 91 e4 02 	lds	r30, 0x02E4
    32f2:	f0 91 e5 02 	lds	r31, 0x02E5
    32f6:	86 89       	ldd	r24, Z+22	; 0x16
    32f8:	89 17       	cp	r24, r25
    32fa:	10 f4       	brcc	.+4      	; 0x3300 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    32fc:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3300:	0f 90       	pop	r0
    3302:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3304:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    3306:	2f 96       	adiw	r28, 0x0f	; 15
    3308:	0f b6       	in	r0, 0x3f	; 63
    330a:	f8 94       	cli
    330c:	de bf       	out	0x3e, r29	; 62
    330e:	0f be       	out	0x3f, r0	; 63
    3310:	cd bf       	out	0x3d, r28	; 61
    3312:	cf 91       	pop	r28
    3314:	df 91       	pop	r29
    3316:	1f 91       	pop	r17
    3318:	0f 91       	pop	r16
    331a:	08 95       	ret

0000331c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    331c:	ef 92       	push	r14
    331e:	ff 92       	push	r15
    3320:	0f 93       	push	r16
    3322:	1f 93       	push	r17
    3324:	df 93       	push	r29
    3326:	cf 93       	push	r28
    3328:	cd b7       	in	r28, 0x3d	; 61
    332a:	de b7       	in	r29, 0x3e	; 62
    332c:	62 97       	sbiw	r28, 0x12	; 18
    332e:	0f b6       	in	r0, 0x3f	; 63
    3330:	f8 94       	cli
    3332:	de bf       	out	0x3e, r29	; 62
    3334:	0f be       	out	0x3f, r0	; 63
    3336:	cd bf       	out	0x3d, r28	; 61
    3338:	9f 83       	std	Y+7, r25	; 0x07
    333a:	8e 83       	std	Y+6, r24	; 0x06
    333c:	48 87       	std	Y+8, r20	; 0x08
    333e:	59 87       	std	Y+9, r21	; 0x09
    3340:	6a 87       	std	Y+10, r22	; 0x0a
    3342:	7b 87       	std	Y+11, r23	; 0x0b
    3344:	2c 87       	std	Y+12, r18	; 0x0c
    3346:	1e 87       	std	Y+14, r17	; 0x0e
    3348:	0d 87       	std	Y+13, r16	; 0x0d
    334a:	f8 8a       	std	Y+16, r15	; 0x10
    334c:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    334e:	81 e0       	ldi	r24, 0x01	; 1
    3350:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3352:	8e 81       	ldd	r24, Y+6	; 0x06
    3354:	9f 81       	ldd	r25, Y+7	; 0x07
    3356:	9d 83       	std	Y+5, r25	; 0x05
    3358:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    335a:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    335c:	8d 85       	ldd	r24, Y+13	; 0x0d
    335e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3360:	00 97       	sbiw	r24, 0x00	; 0
    3362:	61 f0       	breq	.+24     	; 0x337c <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3364:	ec 81       	ldd	r30, Y+4	; 0x04
    3366:	fd 81       	ldd	r31, Y+5	; 0x05
    3368:	81 a1       	ldd	r24, Z+33	; 0x21
    336a:	92 a1       	ldd	r25, Z+34	; 0x22
    336c:	a3 a1       	ldd	r26, Z+35	; 0x23
    336e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3370:	ed 85       	ldd	r30, Y+13	; 0x0d
    3372:	fe 85       	ldd	r31, Y+14	; 0x0e
    3374:	80 83       	st	Z, r24
    3376:	91 83       	std	Z+1, r25	; 0x01
    3378:	a2 83       	std	Z+2, r26	; 0x02
    337a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    337c:	ec 81       	ldd	r30, Y+4	; 0x04
    337e:	fd 81       	ldd	r31, Y+5	; 0x05
    3380:	85 a1       	ldd	r24, Z+37	; 0x25
    3382:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3384:	ec 81       	ldd	r30, Y+4	; 0x04
    3386:	fd 81       	ldd	r31, Y+5	; 0x05
    3388:	82 e0       	ldi	r24, 0x02	; 2
    338a:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    338c:	8c 85       	ldd	r24, Y+12	; 0x0c
    338e:	28 2f       	mov	r18, r24
    3390:	30 e0       	ldi	r19, 0x00	; 0
    3392:	3a 8b       	std	Y+18, r19	; 0x12
    3394:	29 8b       	std	Y+17, r18	; 0x11
    3396:	89 89       	ldd	r24, Y+17	; 0x11
    3398:	9a 89       	ldd	r25, Y+18	; 0x12
    339a:	82 30       	cpi	r24, 0x02	; 2
    339c:	91 05       	cpc	r25, r1
    339e:	59 f1       	breq	.+86     	; 0x33f6 <xTaskGenericNotifyFromISR+0xda>
    33a0:	29 89       	ldd	r18, Y+17	; 0x11
    33a2:	3a 89       	ldd	r19, Y+18	; 0x12
    33a4:	23 30       	cpi	r18, 0x03	; 3
    33a6:	31 05       	cpc	r19, r1
    33a8:	34 f4       	brge	.+12     	; 0x33b6 <xTaskGenericNotifyFromISR+0x9a>
    33aa:	89 89       	ldd	r24, Y+17	; 0x11
    33ac:	9a 89       	ldd	r25, Y+18	; 0x12
    33ae:	81 30       	cpi	r24, 0x01	; 1
    33b0:	91 05       	cpc	r25, r1
    33b2:	61 f0       	breq	.+24     	; 0x33cc <xTaskGenericNotifyFromISR+0xb0>
    33b4:	4a c0       	rjmp	.+148    	; 0x344a <xTaskGenericNotifyFromISR+0x12e>
    33b6:	29 89       	ldd	r18, Y+17	; 0x11
    33b8:	3a 89       	ldd	r19, Y+18	; 0x12
    33ba:	23 30       	cpi	r18, 0x03	; 3
    33bc:	31 05       	cpc	r19, r1
    33be:	59 f1       	breq	.+86     	; 0x3416 <xTaskGenericNotifyFromISR+0xfa>
    33c0:	89 89       	ldd	r24, Y+17	; 0x11
    33c2:	9a 89       	ldd	r25, Y+18	; 0x12
    33c4:	84 30       	cpi	r24, 0x04	; 4
    33c6:	91 05       	cpc	r25, r1
    33c8:	89 f1       	breq	.+98     	; 0x342c <xTaskGenericNotifyFromISR+0x110>
    33ca:	3f c0       	rjmp	.+126    	; 0x344a <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    33cc:	ec 81       	ldd	r30, Y+4	; 0x04
    33ce:	fd 81       	ldd	r31, Y+5	; 0x05
    33d0:	21 a1       	ldd	r18, Z+33	; 0x21
    33d2:	32 a1       	ldd	r19, Z+34	; 0x22
    33d4:	43 a1       	ldd	r20, Z+35	; 0x23
    33d6:	54 a1       	ldd	r21, Z+36	; 0x24
    33d8:	88 85       	ldd	r24, Y+8	; 0x08
    33da:	99 85       	ldd	r25, Y+9	; 0x09
    33dc:	aa 85       	ldd	r26, Y+10	; 0x0a
    33de:	bb 85       	ldd	r27, Y+11	; 0x0b
    33e0:	82 2b       	or	r24, r18
    33e2:	93 2b       	or	r25, r19
    33e4:	a4 2b       	or	r26, r20
    33e6:	b5 2b       	or	r27, r21
    33e8:	ec 81       	ldd	r30, Y+4	; 0x04
    33ea:	fd 81       	ldd	r31, Y+5	; 0x05
    33ec:	81 a3       	std	Z+33, r24	; 0x21
    33ee:	92 a3       	std	Z+34, r25	; 0x22
    33f0:	a3 a3       	std	Z+35, r26	; 0x23
    33f2:	b4 a3       	std	Z+36, r27	; 0x24
    33f4:	2a c0       	rjmp	.+84     	; 0x344a <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    33f6:	ec 81       	ldd	r30, Y+4	; 0x04
    33f8:	fd 81       	ldd	r31, Y+5	; 0x05
    33fa:	81 a1       	ldd	r24, Z+33	; 0x21
    33fc:	92 a1       	ldd	r25, Z+34	; 0x22
    33fe:	a3 a1       	ldd	r26, Z+35	; 0x23
    3400:	b4 a1       	ldd	r27, Z+36	; 0x24
    3402:	01 96       	adiw	r24, 0x01	; 1
    3404:	a1 1d       	adc	r26, r1
    3406:	b1 1d       	adc	r27, r1
    3408:	ec 81       	ldd	r30, Y+4	; 0x04
    340a:	fd 81       	ldd	r31, Y+5	; 0x05
    340c:	81 a3       	std	Z+33, r24	; 0x21
    340e:	92 a3       	std	Z+34, r25	; 0x22
    3410:	a3 a3       	std	Z+35, r26	; 0x23
    3412:	b4 a3       	std	Z+36, r27	; 0x24
    3414:	1a c0       	rjmp	.+52     	; 0x344a <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3416:	ec 81       	ldd	r30, Y+4	; 0x04
    3418:	fd 81       	ldd	r31, Y+5	; 0x05
    341a:	88 85       	ldd	r24, Y+8	; 0x08
    341c:	99 85       	ldd	r25, Y+9	; 0x09
    341e:	aa 85       	ldd	r26, Y+10	; 0x0a
    3420:	bb 85       	ldd	r27, Y+11	; 0x0b
    3422:	81 a3       	std	Z+33, r24	; 0x21
    3424:	92 a3       	std	Z+34, r25	; 0x22
    3426:	a3 a3       	std	Z+35, r26	; 0x23
    3428:	b4 a3       	std	Z+36, r27	; 0x24
    342a:	0f c0       	rjmp	.+30     	; 0x344a <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    342c:	8b 81       	ldd	r24, Y+3	; 0x03
    342e:	82 30       	cpi	r24, 0x02	; 2
    3430:	59 f0       	breq	.+22     	; 0x3448 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3432:	ec 81       	ldd	r30, Y+4	; 0x04
    3434:	fd 81       	ldd	r31, Y+5	; 0x05
    3436:	88 85       	ldd	r24, Y+8	; 0x08
    3438:	99 85       	ldd	r25, Y+9	; 0x09
    343a:	aa 85       	ldd	r26, Y+10	; 0x0a
    343c:	bb 85       	ldd	r27, Y+11	; 0x0b
    343e:	81 a3       	std	Z+33, r24	; 0x21
    3440:	92 a3       	std	Z+34, r25	; 0x22
    3442:	a3 a3       	std	Z+35, r26	; 0x23
    3444:	b4 a3       	std	Z+36, r27	; 0x24
    3446:	01 c0       	rjmp	.+2      	; 0x344a <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3448:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    344a:	8b 81       	ldd	r24, Y+3	; 0x03
    344c:	81 30       	cpi	r24, 0x01	; 1
    344e:	09 f0       	breq	.+2      	; 0x3452 <xTaskGenericNotifyFromISR+0x136>
    3450:	4f c0       	rjmp	.+158    	; 0x34f0 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3452:	80 91 f4 02 	lds	r24, 0x02F4
    3456:	88 23       	and	r24, r24
    3458:	61 f5       	brne	.+88     	; 0x34b2 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    345a:	8c 81       	ldd	r24, Y+4	; 0x04
    345c:	9d 81       	ldd	r25, Y+5	; 0x05
    345e:	02 96       	adiw	r24, 0x02	; 2
    3460:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3464:	ec 81       	ldd	r30, Y+4	; 0x04
    3466:	fd 81       	ldd	r31, Y+5	; 0x05
    3468:	96 89       	ldd	r25, Z+22	; 0x16
    346a:	80 91 ea 02 	lds	r24, 0x02EA
    346e:	89 17       	cp	r24, r25
    3470:	28 f4       	brcc	.+10     	; 0x347c <xTaskGenericNotifyFromISR+0x160>
    3472:	ec 81       	ldd	r30, Y+4	; 0x04
    3474:	fd 81       	ldd	r31, Y+5	; 0x05
    3476:	86 89       	ldd	r24, Z+22	; 0x16
    3478:	80 93 ea 02 	sts	0x02EA, r24
    347c:	ec 81       	ldd	r30, Y+4	; 0x04
    347e:	fd 81       	ldd	r31, Y+5	; 0x05
    3480:	86 89       	ldd	r24, Z+22	; 0x16
    3482:	28 2f       	mov	r18, r24
    3484:	30 e0       	ldi	r19, 0x00	; 0
    3486:	c9 01       	movw	r24, r18
    3488:	88 0f       	add	r24, r24
    348a:	99 1f       	adc	r25, r25
    348c:	88 0f       	add	r24, r24
    348e:	99 1f       	adc	r25, r25
    3490:	88 0f       	add	r24, r24
    3492:	99 1f       	adc	r25, r25
    3494:	82 0f       	add	r24, r18
    3496:	93 1f       	adc	r25, r19
    3498:	ac 01       	movw	r20, r24
    349a:	4b 50       	subi	r20, 0x0B	; 11
    349c:	5d 4f       	sbci	r21, 0xFD	; 253
    349e:	8c 81       	ldd	r24, Y+4	; 0x04
    34a0:	9d 81       	ldd	r25, Y+5	; 0x05
    34a2:	9c 01       	movw	r18, r24
    34a4:	2e 5f       	subi	r18, 0xFE	; 254
    34a6:	3f 4f       	sbci	r19, 0xFF	; 255
    34a8:	ca 01       	movw	r24, r20
    34aa:	b9 01       	movw	r22, r18
    34ac:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>
    34b0:	0a c0       	rjmp	.+20     	; 0x34c6 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    34b2:	8c 81       	ldd	r24, Y+4	; 0x04
    34b4:	9d 81       	ldd	r25, Y+5	; 0x05
    34b6:	9c 01       	movw	r18, r24
    34b8:	24 5f       	subi	r18, 0xF4	; 244
    34ba:	3f 4f       	sbci	r19, 0xFF	; 255
    34bc:	8f e2       	ldi	r24, 0x2F	; 47
    34be:	93 e0       	ldi	r25, 0x03	; 3
    34c0:	b9 01       	movw	r22, r18
    34c2:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    34c6:	ec 81       	ldd	r30, Y+4	; 0x04
    34c8:	fd 81       	ldd	r31, Y+5	; 0x05
    34ca:	96 89       	ldd	r25, Z+22	; 0x16
    34cc:	e0 91 e4 02 	lds	r30, 0x02E4
    34d0:	f0 91 e5 02 	lds	r31, 0x02E5
    34d4:	86 89       	ldd	r24, Z+22	; 0x16
    34d6:	89 17       	cp	r24, r25
    34d8:	58 f4       	brcc	.+22     	; 0x34f0 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    34da:	8f 85       	ldd	r24, Y+15	; 0x0f
    34dc:	98 89       	ldd	r25, Y+16	; 0x10
    34de:	00 97       	sbiw	r24, 0x00	; 0
    34e0:	21 f0       	breq	.+8      	; 0x34ea <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    34e2:	ef 85       	ldd	r30, Y+15	; 0x0f
    34e4:	f8 89       	ldd	r31, Y+16	; 0x10
    34e6:	81 e0       	ldi	r24, 0x01	; 1
    34e8:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    34ea:	81 e0       	ldi	r24, 0x01	; 1
    34ec:	80 93 ed 02 	sts	0x02ED, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    34f0:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    34f2:	62 96       	adiw	r28, 0x12	; 18
    34f4:	0f b6       	in	r0, 0x3f	; 63
    34f6:	f8 94       	cli
    34f8:	de bf       	out	0x3e, r29	; 62
    34fa:	0f be       	out	0x3f, r0	; 63
    34fc:	cd bf       	out	0x3d, r28	; 61
    34fe:	cf 91       	pop	r28
    3500:	df 91       	pop	r29
    3502:	1f 91       	pop	r17
    3504:	0f 91       	pop	r16
    3506:	ff 90       	pop	r15
    3508:	ef 90       	pop	r14
    350a:	08 95       	ret

0000350c <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    350c:	df 93       	push	r29
    350e:	cf 93       	push	r28
    3510:	cd b7       	in	r28, 0x3d	; 61
    3512:	de b7       	in	r29, 0x3e	; 62
    3514:	28 97       	sbiw	r28, 0x08	; 8
    3516:	0f b6       	in	r0, 0x3f	; 63
    3518:	f8 94       	cli
    351a:	de bf       	out	0x3e, r29	; 62
    351c:	0f be       	out	0x3f, r0	; 63
    351e:	cd bf       	out	0x3d, r28	; 61
    3520:	9e 83       	std	Y+6, r25	; 0x06
    3522:	8d 83       	std	Y+5, r24	; 0x05
    3524:	78 87       	std	Y+8, r23	; 0x08
    3526:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3528:	8d 81       	ldd	r24, Y+5	; 0x05
    352a:	9e 81       	ldd	r25, Y+6	; 0x06
    352c:	9c 83       	std	Y+4, r25	; 0x04
    352e:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3530:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3532:	eb 81       	ldd	r30, Y+3	; 0x03
    3534:	fc 81       	ldd	r31, Y+4	; 0x04
    3536:	85 a1       	ldd	r24, Z+37	; 0x25
    3538:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    353a:	eb 81       	ldd	r30, Y+3	; 0x03
    353c:	fc 81       	ldd	r31, Y+4	; 0x04
    353e:	82 e0       	ldi	r24, 0x02	; 2
    3540:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    3542:	eb 81       	ldd	r30, Y+3	; 0x03
    3544:	fc 81       	ldd	r31, Y+4	; 0x04
    3546:	81 a1       	ldd	r24, Z+33	; 0x21
    3548:	92 a1       	ldd	r25, Z+34	; 0x22
    354a:	a3 a1       	ldd	r26, Z+35	; 0x23
    354c:	b4 a1       	ldd	r27, Z+36	; 0x24
    354e:	01 96       	adiw	r24, 0x01	; 1
    3550:	a1 1d       	adc	r26, r1
    3552:	b1 1d       	adc	r27, r1
    3554:	eb 81       	ldd	r30, Y+3	; 0x03
    3556:	fc 81       	ldd	r31, Y+4	; 0x04
    3558:	81 a3       	std	Z+33, r24	; 0x21
    355a:	92 a3       	std	Z+34, r25	; 0x22
    355c:	a3 a3       	std	Z+35, r26	; 0x23
    355e:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3560:	8a 81       	ldd	r24, Y+2	; 0x02
    3562:	81 30       	cpi	r24, 0x01	; 1
    3564:	09 f0       	breq	.+2      	; 0x3568 <vTaskNotifyGiveFromISR+0x5c>
    3566:	4f c0       	rjmp	.+158    	; 0x3606 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3568:	80 91 f4 02 	lds	r24, 0x02F4
    356c:	88 23       	and	r24, r24
    356e:	61 f5       	brne	.+88     	; 0x35c8 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3570:	8b 81       	ldd	r24, Y+3	; 0x03
    3572:	9c 81       	ldd	r25, Y+4	; 0x04
    3574:	02 96       	adiw	r24, 0x02	; 2
    3576:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    357a:	eb 81       	ldd	r30, Y+3	; 0x03
    357c:	fc 81       	ldd	r31, Y+4	; 0x04
    357e:	96 89       	ldd	r25, Z+22	; 0x16
    3580:	80 91 ea 02 	lds	r24, 0x02EA
    3584:	89 17       	cp	r24, r25
    3586:	28 f4       	brcc	.+10     	; 0x3592 <vTaskNotifyGiveFromISR+0x86>
    3588:	eb 81       	ldd	r30, Y+3	; 0x03
    358a:	fc 81       	ldd	r31, Y+4	; 0x04
    358c:	86 89       	ldd	r24, Z+22	; 0x16
    358e:	80 93 ea 02 	sts	0x02EA, r24
    3592:	eb 81       	ldd	r30, Y+3	; 0x03
    3594:	fc 81       	ldd	r31, Y+4	; 0x04
    3596:	86 89       	ldd	r24, Z+22	; 0x16
    3598:	28 2f       	mov	r18, r24
    359a:	30 e0       	ldi	r19, 0x00	; 0
    359c:	c9 01       	movw	r24, r18
    359e:	88 0f       	add	r24, r24
    35a0:	99 1f       	adc	r25, r25
    35a2:	88 0f       	add	r24, r24
    35a4:	99 1f       	adc	r25, r25
    35a6:	88 0f       	add	r24, r24
    35a8:	99 1f       	adc	r25, r25
    35aa:	82 0f       	add	r24, r18
    35ac:	93 1f       	adc	r25, r19
    35ae:	ac 01       	movw	r20, r24
    35b0:	4b 50       	subi	r20, 0x0B	; 11
    35b2:	5d 4f       	sbci	r21, 0xFD	; 253
    35b4:	8b 81       	ldd	r24, Y+3	; 0x03
    35b6:	9c 81       	ldd	r25, Y+4	; 0x04
    35b8:	9c 01       	movw	r18, r24
    35ba:	2e 5f       	subi	r18, 0xFE	; 254
    35bc:	3f 4f       	sbci	r19, 0xFF	; 255
    35be:	ca 01       	movw	r24, r20
    35c0:	b9 01       	movw	r22, r18
    35c2:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>
    35c6:	0a c0       	rjmp	.+20     	; 0x35dc <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    35c8:	8b 81       	ldd	r24, Y+3	; 0x03
    35ca:	9c 81       	ldd	r25, Y+4	; 0x04
    35cc:	9c 01       	movw	r18, r24
    35ce:	24 5f       	subi	r18, 0xF4	; 244
    35d0:	3f 4f       	sbci	r19, 0xFF	; 255
    35d2:	8f e2       	ldi	r24, 0x2F	; 47
    35d4:	93 e0       	ldi	r25, 0x03	; 3
    35d6:	b9 01       	movw	r22, r18
    35d8:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    35dc:	eb 81       	ldd	r30, Y+3	; 0x03
    35de:	fc 81       	ldd	r31, Y+4	; 0x04
    35e0:	96 89       	ldd	r25, Z+22	; 0x16
    35e2:	e0 91 e4 02 	lds	r30, 0x02E4
    35e6:	f0 91 e5 02 	lds	r31, 0x02E5
    35ea:	86 89       	ldd	r24, Z+22	; 0x16
    35ec:	89 17       	cp	r24, r25
    35ee:	58 f4       	brcc	.+22     	; 0x3606 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    35f0:	8f 81       	ldd	r24, Y+7	; 0x07
    35f2:	98 85       	ldd	r25, Y+8	; 0x08
    35f4:	00 97       	sbiw	r24, 0x00	; 0
    35f6:	21 f0       	breq	.+8      	; 0x3600 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    35f8:	ef 81       	ldd	r30, Y+7	; 0x07
    35fa:	f8 85       	ldd	r31, Y+8	; 0x08
    35fc:	81 e0       	ldi	r24, 0x01	; 1
    35fe:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    3600:	81 e0       	ldi	r24, 0x01	; 1
    3602:	80 93 ed 02 	sts	0x02ED, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    3606:	28 96       	adiw	r28, 0x08	; 8
    3608:	0f b6       	in	r0, 0x3f	; 63
    360a:	f8 94       	cli
    360c:	de bf       	out	0x3e, r29	; 62
    360e:	0f be       	out	0x3f, r0	; 63
    3610:	cd bf       	out	0x3d, r28	; 61
    3612:	cf 91       	pop	r28
    3614:	df 91       	pop	r29
    3616:	08 95       	ret

00003618 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    3618:	df 93       	push	r29
    361a:	cf 93       	push	r28
    361c:	cd b7       	in	r28, 0x3d	; 61
    361e:	de b7       	in	r29, 0x3e	; 62
    3620:	27 97       	sbiw	r28, 0x07	; 7
    3622:	0f b6       	in	r0, 0x3f	; 63
    3624:	f8 94       	cli
    3626:	de bf       	out	0x3e, r29	; 62
    3628:	0f be       	out	0x3f, r0	; 63
    362a:	cd bf       	out	0x3d, r28	; 61
    362c:	9d 83       	std	Y+5, r25	; 0x05
    362e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    3630:	8c 81       	ldd	r24, Y+4	; 0x04
    3632:	9d 81       	ldd	r25, Y+5	; 0x05
    3634:	00 97       	sbiw	r24, 0x00	; 0
    3636:	39 f4       	brne	.+14     	; 0x3646 <xTaskNotifyStateClear+0x2e>
    3638:	80 91 e4 02 	lds	r24, 0x02E4
    363c:	90 91 e5 02 	lds	r25, 0x02E5
    3640:	9f 83       	std	Y+7, r25	; 0x07
    3642:	8e 83       	std	Y+6, r24	; 0x06
    3644:	04 c0       	rjmp	.+8      	; 0x364e <xTaskNotifyStateClear+0x36>
    3646:	8c 81       	ldd	r24, Y+4	; 0x04
    3648:	9d 81       	ldd	r25, Y+5	; 0x05
    364a:	9f 83       	std	Y+7, r25	; 0x07
    364c:	8e 83       	std	Y+6, r24	; 0x06
    364e:	8e 81       	ldd	r24, Y+6	; 0x06
    3650:	9f 81       	ldd	r25, Y+7	; 0x07
    3652:	9b 83       	std	Y+3, r25	; 0x03
    3654:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    3656:	0f b6       	in	r0, 0x3f	; 63
    3658:	f8 94       	cli
    365a:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    365c:	ea 81       	ldd	r30, Y+2	; 0x02
    365e:	fb 81       	ldd	r31, Y+3	; 0x03
    3660:	85 a1       	ldd	r24, Z+37	; 0x25
    3662:	82 30       	cpi	r24, 0x02	; 2
    3664:	31 f4       	brne	.+12     	; 0x3672 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3666:	ea 81       	ldd	r30, Y+2	; 0x02
    3668:	fb 81       	ldd	r31, Y+3	; 0x03
    366a:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    366c:	81 e0       	ldi	r24, 0x01	; 1
    366e:	89 83       	std	Y+1, r24	; 0x01
    3670:	01 c0       	rjmp	.+2      	; 0x3674 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    3672:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    3674:	0f 90       	pop	r0
    3676:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3678:	89 81       	ldd	r24, Y+1	; 0x01
	}
    367a:	27 96       	adiw	r28, 0x07	; 7
    367c:	0f b6       	in	r0, 0x3f	; 63
    367e:	f8 94       	cli
    3680:	de bf       	out	0x3e, r29	; 62
    3682:	0f be       	out	0x3f, r0	; 63
    3684:	cd bf       	out	0x3d, r28	; 61
    3686:	cf 91       	pop	r28
    3688:	df 91       	pop	r29
    368a:	08 95       	ret

0000368c <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    368c:	df 93       	push	r29
    368e:	cf 93       	push	r28
    3690:	cd b7       	in	r28, 0x3d	; 61
    3692:	de b7       	in	r29, 0x3e	; 62
    3694:	27 97       	sbiw	r28, 0x07	; 7
    3696:	0f b6       	in	r0, 0x3f	; 63
    3698:	f8 94       	cli
    369a:	de bf       	out	0x3e, r29	; 62
    369c:	0f be       	out	0x3f, r0	; 63
    369e:	cd bf       	out	0x3d, r28	; 61
    36a0:	9e 83       	std	Y+6, r25	; 0x06
    36a2:	8d 83       	std	Y+5, r24	; 0x05
    36a4:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    36a6:	80 91 e8 02 	lds	r24, 0x02E8
    36aa:	90 91 e9 02 	lds	r25, 0x02E9
    36ae:	9a 83       	std	Y+2, r25	; 0x02
    36b0:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    36b2:	80 91 e4 02 	lds	r24, 0x02E4
    36b6:	90 91 e5 02 	lds	r25, 0x02E5
    36ba:	02 96       	adiw	r24, 0x02	; 2
    36bc:	0e 94 82 05 	call	0xb04	; 0xb04 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    36c0:	29 81       	ldd	r18, Y+1	; 0x01
    36c2:	3a 81       	ldd	r19, Y+2	; 0x02
    36c4:	8d 81       	ldd	r24, Y+5	; 0x05
    36c6:	9e 81       	ldd	r25, Y+6	; 0x06
    36c8:	82 0f       	add	r24, r18
    36ca:	93 1f       	adc	r25, r19
    36cc:	9c 83       	std	Y+4, r25	; 0x04
    36ce:	8b 83       	std	Y+3, r24	; 0x03

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    36d0:	e0 91 e4 02 	lds	r30, 0x02E4
    36d4:	f0 91 e5 02 	lds	r31, 0x02E5
    36d8:	8b 81       	ldd	r24, Y+3	; 0x03
    36da:	9c 81       	ldd	r25, Y+4	; 0x04
    36dc:	93 83       	std	Z+3, r25	; 0x03
    36de:	82 83       	std	Z+2, r24	; 0x02

		if( xTimeToWake < xConstTickCount )
    36e0:	2b 81       	ldd	r18, Y+3	; 0x03
    36e2:	3c 81       	ldd	r19, Y+4	; 0x04
    36e4:	89 81       	ldd	r24, Y+1	; 0x01
    36e6:	9a 81       	ldd	r25, Y+2	; 0x02
    36e8:	28 17       	cp	r18, r24
    36ea:	39 07       	cpc	r19, r25
    36ec:	70 f4       	brcc	.+28     	; 0x370a <prvAddCurrentTaskToDelayedList+0x7e>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    36ee:	80 91 2d 03 	lds	r24, 0x032D
    36f2:	90 91 2e 03 	lds	r25, 0x032E
    36f6:	20 91 e4 02 	lds	r18, 0x02E4
    36fa:	30 91 e5 02 	lds	r19, 0x02E5
    36fe:	2e 5f       	subi	r18, 0xFE	; 254
    3700:	3f 4f       	sbci	r19, 0xFF	; 255
    3702:	b9 01       	movw	r22, r18
    3704:	0e 94 16 05 	call	0xa2c	; 0xa2c <vListInsert>
    3708:	1e c0       	rjmp	.+60     	; 0x3746 <prvAddCurrentTaskToDelayedList+0xba>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    370a:	40 91 2b 03 	lds	r20, 0x032B
    370e:	50 91 2c 03 	lds	r21, 0x032C
    3712:	80 91 e4 02 	lds	r24, 0x02E4
    3716:	90 91 e5 02 	lds	r25, 0x02E5
    371a:	9c 01       	movw	r18, r24
    371c:	2e 5f       	subi	r18, 0xFE	; 254
    371e:	3f 4f       	sbci	r19, 0xFF	; 255
    3720:	ca 01       	movw	r24, r20
    3722:	b9 01       	movw	r22, r18
    3724:	0e 94 16 05 	call	0xa2c	; 0xa2c <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    3728:	20 91 f0 02 	lds	r18, 0x02F0
    372c:	30 91 f1 02 	lds	r19, 0x02F1
    3730:	8b 81       	ldd	r24, Y+3	; 0x03
    3732:	9c 81       	ldd	r25, Y+4	; 0x04
    3734:	82 17       	cp	r24, r18
    3736:	93 07       	cpc	r25, r19
    3738:	30 f4       	brcc	.+12     	; 0x3746 <prvAddCurrentTaskToDelayedList+0xba>
			{
				xNextTaskUnblockTime = xTimeToWake;
    373a:	8b 81       	ldd	r24, Y+3	; 0x03
    373c:	9c 81       	ldd	r25, Y+4	; 0x04
    373e:	90 93 f1 02 	sts	0x02F1, r25
    3742:	80 93 f0 02 	sts	0x02F0, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3746:	27 96       	adiw	r28, 0x07	; 7
    3748:	0f b6       	in	r0, 0x3f	; 63
    374a:	f8 94       	cli
    374c:	de bf       	out	0x3e, r29	; 62
    374e:	0f be       	out	0x3f, r0	; 63
    3750:	cd bf       	out	0x3d, r28	; 61
    3752:	cf 91       	pop	r28
    3754:	df 91       	pop	r29
    3756:	08 95       	ret

00003758 <DIO_void_set_port_dir>:


/* Implementing of the driver functions */
/* Set direction of PORTx functions */
void DIO_void_set_port_dir(u8 copy_u8_port_id, u8 port_dir_copy)
{
    3758:	df 93       	push	r29
    375a:	cf 93       	push	r28
    375c:	00 d0       	rcall	.+0      	; 0x375e <DIO_void_set_port_dir+0x6>
    375e:	cd b7       	in	r28, 0x3d	; 61
    3760:	de b7       	in	r29, 0x3e	; 62
    3762:	89 83       	std	Y+1, r24	; 0x01
    3764:	6a 83       	std	Y+2, r22	; 0x02
	 *						1: for output pin
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT Direction Register DDRx
	 */
	*(DIO_DDRx_REF[copy_u8_port_id]) = port_dir_copy;
    3766:	89 81       	ldd	r24, Y+1	; 0x01
    3768:	88 2f       	mov	r24, r24
    376a:	90 e0       	ldi	r25, 0x00	; 0
    376c:	88 0f       	add	r24, r24
    376e:	99 1f       	adc	r25, r25
    3770:	fc 01       	movw	r30, r24
    3772:	e8 58       	subi	r30, 0x88	; 136
    3774:	ff 4f       	sbci	r31, 0xFF	; 255
    3776:	01 90       	ld	r0, Z+
    3778:	f0 81       	ld	r31, Z
    377a:	e0 2d       	mov	r30, r0
    377c:	8a 81       	ldd	r24, Y+2	; 0x02
    377e:	80 83       	st	Z, r24
}
    3780:	0f 90       	pop	r0
    3782:	0f 90       	pop	r0
    3784:	cf 91       	pop	r28
    3786:	df 91       	pop	r29
    3788:	08 95       	ret

0000378a <DIO_void_set_port_in_pullUp>:


void DIO_void_set_port_in_pullUp(u8 copy_u8_port_id)
{
    378a:	df 93       	push	r29
    378c:	cf 93       	push	r28
    378e:	0f 92       	push	r0
    3790:	cd b7       	in	r28, 0x3d	; 61
    3792:	de b7       	in	r29, 0x3e	; 62
    3794:	89 83       	std	Y+1, r24	; 0x01
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT Direction Register DDRx
	 */
	*(DIO_DDRx_REF[copy_u8_port_id]) = INPUT;
    3796:	89 81       	ldd	r24, Y+1	; 0x01
    3798:	88 2f       	mov	r24, r24
    379a:	90 e0       	ldi	r25, 0x00	; 0
    379c:	88 0f       	add	r24, r24
    379e:	99 1f       	adc	r25, r25
    37a0:	fc 01       	movw	r30, r24
    37a2:	e8 58       	subi	r30, 0x88	; 136
    37a4:	ff 4f       	sbci	r31, 0xFF	; 255
    37a6:	01 90       	ld	r0, Z+
    37a8:	f0 81       	ld	r31, Z
    37aa:	e0 2d       	mov	r30, r0
    37ac:	10 82       	st	Z, r1
	*(DIO_PORTx_REF[copy_u8_port_id]) = PORT_MAX;
    37ae:	89 81       	ldd	r24, Y+1	; 0x01
    37b0:	88 2f       	mov	r24, r24
    37b2:	90 e0       	ldi	r25, 0x00	; 0
    37b4:	88 0f       	add	r24, r24
    37b6:	99 1f       	adc	r25, r25
    37b8:	fc 01       	movw	r30, r24
    37ba:	e0 58       	subi	r30, 0x80	; 128
    37bc:	ff 4f       	sbci	r31, 0xFF	; 255
    37be:	01 90       	ld	r0, Z+
    37c0:	f0 81       	ld	r31, Z
    37c2:	e0 2d       	mov	r30, r0
    37c4:	8f ef       	ldi	r24, 0xFF	; 255
    37c6:	80 83       	st	Z, r24
}
    37c8:	0f 90       	pop	r0
    37ca:	cf 91       	pop	r28
    37cc:	df 91       	pop	r29
    37ce:	08 95       	ret

000037d0 <DIO_void_set_pin_dir>:


/* Set direction of PINx functions */
void DIO_void_set_pin_dir(u8 copy_u8_port_id, u8 copy_u8_pin_num, u8 pin_dir_copy)
{
    37d0:	df 93       	push	r29
    37d2:	cf 93       	push	r28
    37d4:	00 d0       	rcall	.+0      	; 0x37d6 <DIO_void_set_pin_dir+0x6>
    37d6:	0f 92       	push	r0
    37d8:	cd b7       	in	r28, 0x3d	; 61
    37da:	de b7       	in	r29, 0x3e	; 62
    37dc:	89 83       	std	Y+1, r24	; 0x01
    37de:	6a 83       	std	Y+2, r22	; 0x02
    37e0:	4b 83       	std	Y+3, r20	; 0x03
	 *				   1: for output pin
	 *
	 * Function does not return any output, yet it affects the 
	 * pin in the PORT Direction Register DDRx
	 */	
	agn_bit(*(DIO_DDRx_REF[copy_u8_port_id]), copy_u8_pin_num, pin_dir_copy);
    37e2:	8b 81       	ldd	r24, Y+3	; 0x03
    37e4:	88 23       	and	r24, r24
    37e6:	29 f1       	breq	.+74     	; 0x3832 <DIO_void_set_pin_dir+0x62>
    37e8:	89 81       	ldd	r24, Y+1	; 0x01
    37ea:	88 2f       	mov	r24, r24
    37ec:	90 e0       	ldi	r25, 0x00	; 0
    37ee:	88 0f       	add	r24, r24
    37f0:	99 1f       	adc	r25, r25
    37f2:	fc 01       	movw	r30, r24
    37f4:	e8 58       	subi	r30, 0x88	; 136
    37f6:	ff 4f       	sbci	r31, 0xFF	; 255
    37f8:	a0 81       	ld	r26, Z
    37fa:	b1 81       	ldd	r27, Z+1	; 0x01
    37fc:	89 81       	ldd	r24, Y+1	; 0x01
    37fe:	88 2f       	mov	r24, r24
    3800:	90 e0       	ldi	r25, 0x00	; 0
    3802:	88 0f       	add	r24, r24
    3804:	99 1f       	adc	r25, r25
    3806:	fc 01       	movw	r30, r24
    3808:	e8 58       	subi	r30, 0x88	; 136
    380a:	ff 4f       	sbci	r31, 0xFF	; 255
    380c:	01 90       	ld	r0, Z+
    380e:	f0 81       	ld	r31, Z
    3810:	e0 2d       	mov	r30, r0
    3812:	80 81       	ld	r24, Z
    3814:	48 2f       	mov	r20, r24
    3816:	8a 81       	ldd	r24, Y+2	; 0x02
    3818:	28 2f       	mov	r18, r24
    381a:	30 e0       	ldi	r19, 0x00	; 0
    381c:	81 e0       	ldi	r24, 0x01	; 1
    381e:	90 e0       	ldi	r25, 0x00	; 0
    3820:	02 2e       	mov	r0, r18
    3822:	02 c0       	rjmp	.+4      	; 0x3828 <DIO_void_set_pin_dir+0x58>
    3824:	88 0f       	add	r24, r24
    3826:	99 1f       	adc	r25, r25
    3828:	0a 94       	dec	r0
    382a:	e2 f7       	brpl	.-8      	; 0x3824 <DIO_void_set_pin_dir+0x54>
    382c:	84 2b       	or	r24, r20
    382e:	8c 93       	st	X, r24
    3830:	25 c0       	rjmp	.+74     	; 0x387c <DIO_void_set_pin_dir+0xac>
    3832:	89 81       	ldd	r24, Y+1	; 0x01
    3834:	88 2f       	mov	r24, r24
    3836:	90 e0       	ldi	r25, 0x00	; 0
    3838:	88 0f       	add	r24, r24
    383a:	99 1f       	adc	r25, r25
    383c:	fc 01       	movw	r30, r24
    383e:	e8 58       	subi	r30, 0x88	; 136
    3840:	ff 4f       	sbci	r31, 0xFF	; 255
    3842:	a0 81       	ld	r26, Z
    3844:	b1 81       	ldd	r27, Z+1	; 0x01
    3846:	89 81       	ldd	r24, Y+1	; 0x01
    3848:	88 2f       	mov	r24, r24
    384a:	90 e0       	ldi	r25, 0x00	; 0
    384c:	88 0f       	add	r24, r24
    384e:	99 1f       	adc	r25, r25
    3850:	fc 01       	movw	r30, r24
    3852:	e8 58       	subi	r30, 0x88	; 136
    3854:	ff 4f       	sbci	r31, 0xFF	; 255
    3856:	01 90       	ld	r0, Z+
    3858:	f0 81       	ld	r31, Z
    385a:	e0 2d       	mov	r30, r0
    385c:	80 81       	ld	r24, Z
    385e:	48 2f       	mov	r20, r24
    3860:	8a 81       	ldd	r24, Y+2	; 0x02
    3862:	28 2f       	mov	r18, r24
    3864:	30 e0       	ldi	r19, 0x00	; 0
    3866:	81 e0       	ldi	r24, 0x01	; 1
    3868:	90 e0       	ldi	r25, 0x00	; 0
    386a:	02 2e       	mov	r0, r18
    386c:	02 c0       	rjmp	.+4      	; 0x3872 <DIO_void_set_pin_dir+0xa2>
    386e:	88 0f       	add	r24, r24
    3870:	99 1f       	adc	r25, r25
    3872:	0a 94       	dec	r0
    3874:	e2 f7       	brpl	.-8      	; 0x386e <DIO_void_set_pin_dir+0x9e>
    3876:	80 95       	com	r24
    3878:	84 23       	and	r24, r20
    387a:	8c 93       	st	X, r24
}
    387c:	0f 90       	pop	r0
    387e:	0f 90       	pop	r0
    3880:	0f 90       	pop	r0
    3882:	cf 91       	pop	r28
    3884:	df 91       	pop	r29
    3886:	08 95       	ret

00003888 <DIO_void_set_pin_in_pullUP>:


void DIO_void_set_pin_in_pullUP(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    3888:	df 93       	push	r29
    388a:	cf 93       	push	r28
    388c:	00 d0       	rcall	.+0      	; 0x388e <DIO_void_set_pin_in_pullUP+0x6>
    388e:	cd b7       	in	r28, 0x3d	; 61
    3890:	de b7       	in	r29, 0x3e	; 62
    3892:	89 83       	std	Y+1, r24	; 0x01
    3894:	6a 83       	std	Y+2, r22	; 0x02
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	pin in the PORT Direction Register DDRx					  
	 */
	clr_bit(*(DIO_DDRx_REF[copy_u8_port_id]), copy_u8_pin_num);
    3896:	89 81       	ldd	r24, Y+1	; 0x01
    3898:	88 2f       	mov	r24, r24
    389a:	90 e0       	ldi	r25, 0x00	; 0
    389c:	88 0f       	add	r24, r24
    389e:	99 1f       	adc	r25, r25
    38a0:	fc 01       	movw	r30, r24
    38a2:	e8 58       	subi	r30, 0x88	; 136
    38a4:	ff 4f       	sbci	r31, 0xFF	; 255
    38a6:	a0 81       	ld	r26, Z
    38a8:	b1 81       	ldd	r27, Z+1	; 0x01
    38aa:	89 81       	ldd	r24, Y+1	; 0x01
    38ac:	88 2f       	mov	r24, r24
    38ae:	90 e0       	ldi	r25, 0x00	; 0
    38b0:	88 0f       	add	r24, r24
    38b2:	99 1f       	adc	r25, r25
    38b4:	fc 01       	movw	r30, r24
    38b6:	e8 58       	subi	r30, 0x88	; 136
    38b8:	ff 4f       	sbci	r31, 0xFF	; 255
    38ba:	01 90       	ld	r0, Z+
    38bc:	f0 81       	ld	r31, Z
    38be:	e0 2d       	mov	r30, r0
    38c0:	80 81       	ld	r24, Z
    38c2:	48 2f       	mov	r20, r24
    38c4:	8a 81       	ldd	r24, Y+2	; 0x02
    38c6:	28 2f       	mov	r18, r24
    38c8:	30 e0       	ldi	r19, 0x00	; 0
    38ca:	81 e0       	ldi	r24, 0x01	; 1
    38cc:	90 e0       	ldi	r25, 0x00	; 0
    38ce:	02 c0       	rjmp	.+4      	; 0x38d4 <DIO_void_set_pin_in_pullUP+0x4c>
    38d0:	88 0f       	add	r24, r24
    38d2:	99 1f       	adc	r25, r25
    38d4:	2a 95       	dec	r18
    38d6:	e2 f7       	brpl	.-8      	; 0x38d0 <DIO_void_set_pin_in_pullUP+0x48>
    38d8:	80 95       	com	r24
    38da:	84 23       	and	r24, r20
    38dc:	8c 93       	st	X, r24
	set_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    38de:	89 81       	ldd	r24, Y+1	; 0x01
    38e0:	88 2f       	mov	r24, r24
    38e2:	90 e0       	ldi	r25, 0x00	; 0
    38e4:	88 0f       	add	r24, r24
    38e6:	99 1f       	adc	r25, r25
    38e8:	fc 01       	movw	r30, r24
    38ea:	e0 58       	subi	r30, 0x80	; 128
    38ec:	ff 4f       	sbci	r31, 0xFF	; 255
    38ee:	a0 81       	ld	r26, Z
    38f0:	b1 81       	ldd	r27, Z+1	; 0x01
    38f2:	89 81       	ldd	r24, Y+1	; 0x01
    38f4:	88 2f       	mov	r24, r24
    38f6:	90 e0       	ldi	r25, 0x00	; 0
    38f8:	88 0f       	add	r24, r24
    38fa:	99 1f       	adc	r25, r25
    38fc:	fc 01       	movw	r30, r24
    38fe:	e0 58       	subi	r30, 0x80	; 128
    3900:	ff 4f       	sbci	r31, 0xFF	; 255
    3902:	01 90       	ld	r0, Z+
    3904:	f0 81       	ld	r31, Z
    3906:	e0 2d       	mov	r30, r0
    3908:	80 81       	ld	r24, Z
    390a:	48 2f       	mov	r20, r24
    390c:	8a 81       	ldd	r24, Y+2	; 0x02
    390e:	28 2f       	mov	r18, r24
    3910:	30 e0       	ldi	r19, 0x00	; 0
    3912:	81 e0       	ldi	r24, 0x01	; 1
    3914:	90 e0       	ldi	r25, 0x00	; 0
    3916:	02 2e       	mov	r0, r18
    3918:	02 c0       	rjmp	.+4      	; 0x391e <DIO_void_set_pin_in_pullUP+0x96>
    391a:	88 0f       	add	r24, r24
    391c:	99 1f       	adc	r25, r25
    391e:	0a 94       	dec	r0
    3920:	e2 f7       	brpl	.-8      	; 0x391a <DIO_void_set_pin_in_pullUP+0x92>
    3922:	84 2b       	or	r24, r20
    3924:	8c 93       	st	X, r24
}
    3926:	0f 90       	pop	r0
    3928:	0f 90       	pop	r0
    392a:	cf 91       	pop	r28
    392c:	df 91       	pop	r29
    392e:	08 95       	ret

00003930 <DIO_void_set_port>:


/* Assign Value to output PORTx functions */
void DIO_void_set_port(u8 copy_u8_port_id)
{
    3930:	df 93       	push	r29
    3932:	cf 93       	push	r28
    3934:	0f 92       	push	r0
    3936:	cd b7       	in	r28, 0x3d	; 61
    3938:	de b7       	in	r29, 0x3e	; 62
    393a:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = PORT_MAX;
    393c:	89 81       	ldd	r24, Y+1	; 0x01
    393e:	88 2f       	mov	r24, r24
    3940:	90 e0       	ldi	r25, 0x00	; 0
    3942:	88 0f       	add	r24, r24
    3944:	99 1f       	adc	r25, r25
    3946:	fc 01       	movw	r30, r24
    3948:	e0 58       	subi	r30, 0x80	; 128
    394a:	ff 4f       	sbci	r31, 0xFF	; 255
    394c:	01 90       	ld	r0, Z+
    394e:	f0 81       	ld	r31, Z
    3950:	e0 2d       	mov	r30, r0
    3952:	8f ef       	ldi	r24, 0xFF	; 255
    3954:	80 83       	st	Z, r24
}
    3956:	0f 90       	pop	r0
    3958:	cf 91       	pop	r28
    395a:	df 91       	pop	r29
    395c:	08 95       	ret

0000395e <DIO_void_clear_port>:


void DIO_void_clear_port(u8 copy_u8_port_id)
{
    395e:	df 93       	push	r29
    3960:	cf 93       	push	r28
    3962:	0f 92       	push	r0
    3964:	cd b7       	in	r28, 0x3d	; 61
    3966:	de b7       	in	r29, 0x3e	; 62
    3968:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = LOW;
    396a:	89 81       	ldd	r24, Y+1	; 0x01
    396c:	88 2f       	mov	r24, r24
    396e:	90 e0       	ldi	r25, 0x00	; 0
    3970:	88 0f       	add	r24, r24
    3972:	99 1f       	adc	r25, r25
    3974:	fc 01       	movw	r30, r24
    3976:	e0 58       	subi	r30, 0x80	; 128
    3978:	ff 4f       	sbci	r31, 0xFF	; 255
    397a:	01 90       	ld	r0, Z+
    397c:	f0 81       	ld	r31, Z
    397e:	e0 2d       	mov	r30, r0
    3980:	10 82       	st	Z, r1
}
    3982:	0f 90       	pop	r0
    3984:	cf 91       	pop	r28
    3986:	df 91       	pop	r29
    3988:	08 95       	ret

0000398a <DIO_void_toggle_port>:


void DIO_void_toggle_port(u8 copy_u8_port_id)
{
    398a:	df 93       	push	r29
    398c:	cf 93       	push	r28
    398e:	0f 92       	push	r0
    3990:	cd b7       	in	r28, 0x3d	; 61
    3992:	de b7       	in	r29, 0x3e	; 62
    3994:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) ^= PORT_MAX;
    3996:	89 81       	ldd	r24, Y+1	; 0x01
    3998:	88 2f       	mov	r24, r24
    399a:	90 e0       	ldi	r25, 0x00	; 0
    399c:	88 0f       	add	r24, r24
    399e:	99 1f       	adc	r25, r25
    39a0:	fc 01       	movw	r30, r24
    39a2:	e0 58       	subi	r30, 0x80	; 128
    39a4:	ff 4f       	sbci	r31, 0xFF	; 255
    39a6:	a0 81       	ld	r26, Z
    39a8:	b1 81       	ldd	r27, Z+1	; 0x01
    39aa:	89 81       	ldd	r24, Y+1	; 0x01
    39ac:	88 2f       	mov	r24, r24
    39ae:	90 e0       	ldi	r25, 0x00	; 0
    39b0:	88 0f       	add	r24, r24
    39b2:	99 1f       	adc	r25, r25
    39b4:	fc 01       	movw	r30, r24
    39b6:	e0 58       	subi	r30, 0x80	; 128
    39b8:	ff 4f       	sbci	r31, 0xFF	; 255
    39ba:	01 90       	ld	r0, Z+
    39bc:	f0 81       	ld	r31, Z
    39be:	e0 2d       	mov	r30, r0
    39c0:	80 81       	ld	r24, Z
    39c2:	80 95       	com	r24
    39c4:	8c 93       	st	X, r24
}
    39c6:	0f 90       	pop	r0
    39c8:	cf 91       	pop	r28
    39ca:	df 91       	pop	r29
    39cc:	08 95       	ret

000039ce <DIO_void_assign_port>:


void DIO_void_assign_port(u8 copy_u8_port_id, u8 port_val)
{
    39ce:	df 93       	push	r29
    39d0:	cf 93       	push	r28
    39d2:	00 d0       	rcall	.+0      	; 0x39d4 <DIO_void_assign_port+0x6>
    39d4:	cd b7       	in	r28, 0x3d	; 61
    39d6:	de b7       	in	r29, 0x3e	; 62
    39d8:	89 83       	std	Y+1, r24	; 0x01
    39da:	6a 83       	std	Y+2, r22	; 0x02
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = port_val;
    39dc:	89 81       	ldd	r24, Y+1	; 0x01
    39de:	88 2f       	mov	r24, r24
    39e0:	90 e0       	ldi	r25, 0x00	; 0
    39e2:	88 0f       	add	r24, r24
    39e4:	99 1f       	adc	r25, r25
    39e6:	fc 01       	movw	r30, r24
    39e8:	e0 58       	subi	r30, 0x80	; 128
    39ea:	ff 4f       	sbci	r31, 0xFF	; 255
    39ec:	01 90       	ld	r0, Z+
    39ee:	f0 81       	ld	r31, Z
    39f0:	e0 2d       	mov	r30, r0
    39f2:	8a 81       	ldd	r24, Y+2	; 0x02
    39f4:	80 83       	st	Z, r24
}
    39f6:	0f 90       	pop	r0
    39f8:	0f 90       	pop	r0
    39fa:	cf 91       	pop	r28
    39fc:	df 91       	pop	r29
    39fe:	08 95       	ret

00003a00 <DIO_void_set_pin>:


/* Assign Value to output PINx functions */
void DIO_void_set_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    3a00:	df 93       	push	r29
    3a02:	cf 93       	push	r28
    3a04:	00 d0       	rcall	.+0      	; 0x3a06 <DIO_void_set_pin+0x6>
    3a06:	cd b7       	in	r28, 0x3d	; 61
    3a08:	de b7       	in	r29, 0x3e	; 62
    3a0a:	89 83       	std	Y+1, r24	; 0x01
    3a0c:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	set_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    3a0e:	89 81       	ldd	r24, Y+1	; 0x01
    3a10:	88 2f       	mov	r24, r24
    3a12:	90 e0       	ldi	r25, 0x00	; 0
    3a14:	88 0f       	add	r24, r24
    3a16:	99 1f       	adc	r25, r25
    3a18:	fc 01       	movw	r30, r24
    3a1a:	e0 58       	subi	r30, 0x80	; 128
    3a1c:	ff 4f       	sbci	r31, 0xFF	; 255
    3a1e:	a0 81       	ld	r26, Z
    3a20:	b1 81       	ldd	r27, Z+1	; 0x01
    3a22:	89 81       	ldd	r24, Y+1	; 0x01
    3a24:	88 2f       	mov	r24, r24
    3a26:	90 e0       	ldi	r25, 0x00	; 0
    3a28:	88 0f       	add	r24, r24
    3a2a:	99 1f       	adc	r25, r25
    3a2c:	fc 01       	movw	r30, r24
    3a2e:	e0 58       	subi	r30, 0x80	; 128
    3a30:	ff 4f       	sbci	r31, 0xFF	; 255
    3a32:	01 90       	ld	r0, Z+
    3a34:	f0 81       	ld	r31, Z
    3a36:	e0 2d       	mov	r30, r0
    3a38:	80 81       	ld	r24, Z
    3a3a:	48 2f       	mov	r20, r24
    3a3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a3e:	28 2f       	mov	r18, r24
    3a40:	30 e0       	ldi	r19, 0x00	; 0
    3a42:	81 e0       	ldi	r24, 0x01	; 1
    3a44:	90 e0       	ldi	r25, 0x00	; 0
    3a46:	02 2e       	mov	r0, r18
    3a48:	02 c0       	rjmp	.+4      	; 0x3a4e <DIO_void_set_pin+0x4e>
    3a4a:	88 0f       	add	r24, r24
    3a4c:	99 1f       	adc	r25, r25
    3a4e:	0a 94       	dec	r0
    3a50:	e2 f7       	brpl	.-8      	; 0x3a4a <DIO_void_set_pin+0x4a>
    3a52:	84 2b       	or	r24, r20
    3a54:	8c 93       	st	X, r24
}
    3a56:	0f 90       	pop	r0
    3a58:	0f 90       	pop	r0
    3a5a:	cf 91       	pop	r28
    3a5c:	df 91       	pop	r29
    3a5e:	08 95       	ret

00003a60 <DIO_void_clear_pin>:


void DIO_void_clear_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    3a60:	df 93       	push	r29
    3a62:	cf 93       	push	r28
    3a64:	00 d0       	rcall	.+0      	; 0x3a66 <DIO_void_clear_pin+0x6>
    3a66:	cd b7       	in	r28, 0x3d	; 61
    3a68:	de b7       	in	r29, 0x3e	; 62
    3a6a:	89 83       	std	Y+1, r24	; 0x01
    3a6c:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	clr_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    3a6e:	89 81       	ldd	r24, Y+1	; 0x01
    3a70:	88 2f       	mov	r24, r24
    3a72:	90 e0       	ldi	r25, 0x00	; 0
    3a74:	88 0f       	add	r24, r24
    3a76:	99 1f       	adc	r25, r25
    3a78:	fc 01       	movw	r30, r24
    3a7a:	e0 58       	subi	r30, 0x80	; 128
    3a7c:	ff 4f       	sbci	r31, 0xFF	; 255
    3a7e:	a0 81       	ld	r26, Z
    3a80:	b1 81       	ldd	r27, Z+1	; 0x01
    3a82:	89 81       	ldd	r24, Y+1	; 0x01
    3a84:	88 2f       	mov	r24, r24
    3a86:	90 e0       	ldi	r25, 0x00	; 0
    3a88:	88 0f       	add	r24, r24
    3a8a:	99 1f       	adc	r25, r25
    3a8c:	fc 01       	movw	r30, r24
    3a8e:	e0 58       	subi	r30, 0x80	; 128
    3a90:	ff 4f       	sbci	r31, 0xFF	; 255
    3a92:	01 90       	ld	r0, Z+
    3a94:	f0 81       	ld	r31, Z
    3a96:	e0 2d       	mov	r30, r0
    3a98:	80 81       	ld	r24, Z
    3a9a:	48 2f       	mov	r20, r24
    3a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a9e:	28 2f       	mov	r18, r24
    3aa0:	30 e0       	ldi	r19, 0x00	; 0
    3aa2:	81 e0       	ldi	r24, 0x01	; 1
    3aa4:	90 e0       	ldi	r25, 0x00	; 0
    3aa6:	02 2e       	mov	r0, r18
    3aa8:	02 c0       	rjmp	.+4      	; 0x3aae <DIO_void_clear_pin+0x4e>
    3aaa:	88 0f       	add	r24, r24
    3aac:	99 1f       	adc	r25, r25
    3aae:	0a 94       	dec	r0
    3ab0:	e2 f7       	brpl	.-8      	; 0x3aaa <DIO_void_clear_pin+0x4a>
    3ab2:	80 95       	com	r24
    3ab4:	84 23       	and	r24, r20
    3ab6:	8c 93       	st	X, r24
}
    3ab8:	0f 90       	pop	r0
    3aba:	0f 90       	pop	r0
    3abc:	cf 91       	pop	r28
    3abe:	df 91       	pop	r29
    3ac0:	08 95       	ret

00003ac2 <DIO_void_toggle_pin>:


void DIO_void_toggle_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    3ac2:	df 93       	push	r29
    3ac4:	cf 93       	push	r28
    3ac6:	00 d0       	rcall	.+0      	; 0x3ac8 <DIO_void_toggle_pin+0x6>
    3ac8:	cd b7       	in	r28, 0x3d	; 61
    3aca:	de b7       	in	r29, 0x3e	; 62
    3acc:	89 83       	std	Y+1, r24	; 0x01
    3ace:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	tgl_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    3ad0:	89 81       	ldd	r24, Y+1	; 0x01
    3ad2:	88 2f       	mov	r24, r24
    3ad4:	90 e0       	ldi	r25, 0x00	; 0
    3ad6:	88 0f       	add	r24, r24
    3ad8:	99 1f       	adc	r25, r25
    3ada:	fc 01       	movw	r30, r24
    3adc:	e0 58       	subi	r30, 0x80	; 128
    3ade:	ff 4f       	sbci	r31, 0xFF	; 255
    3ae0:	a0 81       	ld	r26, Z
    3ae2:	b1 81       	ldd	r27, Z+1	; 0x01
    3ae4:	89 81       	ldd	r24, Y+1	; 0x01
    3ae6:	88 2f       	mov	r24, r24
    3ae8:	90 e0       	ldi	r25, 0x00	; 0
    3aea:	88 0f       	add	r24, r24
    3aec:	99 1f       	adc	r25, r25
    3aee:	fc 01       	movw	r30, r24
    3af0:	e0 58       	subi	r30, 0x80	; 128
    3af2:	ff 4f       	sbci	r31, 0xFF	; 255
    3af4:	01 90       	ld	r0, Z+
    3af6:	f0 81       	ld	r31, Z
    3af8:	e0 2d       	mov	r30, r0
    3afa:	80 81       	ld	r24, Z
    3afc:	48 2f       	mov	r20, r24
    3afe:	8a 81       	ldd	r24, Y+2	; 0x02
    3b00:	28 2f       	mov	r18, r24
    3b02:	30 e0       	ldi	r19, 0x00	; 0
    3b04:	81 e0       	ldi	r24, 0x01	; 1
    3b06:	90 e0       	ldi	r25, 0x00	; 0
    3b08:	02 2e       	mov	r0, r18
    3b0a:	02 c0       	rjmp	.+4      	; 0x3b10 <DIO_void_toggle_pin+0x4e>
    3b0c:	88 0f       	add	r24, r24
    3b0e:	99 1f       	adc	r25, r25
    3b10:	0a 94       	dec	r0
    3b12:	e2 f7       	brpl	.-8      	; 0x3b0c <DIO_void_toggle_pin+0x4a>
    3b14:	84 27       	eor	r24, r20
    3b16:	8c 93       	st	X, r24
}
    3b18:	0f 90       	pop	r0
    3b1a:	0f 90       	pop	r0
    3b1c:	cf 91       	pop	r28
    3b1e:	df 91       	pop	r29
    3b20:	08 95       	ret

00003b22 <DIO_void_assign_pin>:


void DIO_void_assign_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num, u8 pin_val)
{
    3b22:	df 93       	push	r29
    3b24:	cf 93       	push	r28
    3b26:	00 d0       	rcall	.+0      	; 0x3b28 <DIO_void_assign_pin+0x6>
    3b28:	0f 92       	push	r0
    3b2a:	cd b7       	in	r28, 0x3d	; 61
    3b2c:	de b7       	in	r29, 0x3e	; 62
    3b2e:	89 83       	std	Y+1, r24	; 0x01
    3b30:	6a 83       	std	Y+2, r22	; 0x02
    3b32:	4b 83       	std	Y+3, r20	; 0x03
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	agn_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num, pin_val);
    3b34:	8b 81       	ldd	r24, Y+3	; 0x03
    3b36:	88 23       	and	r24, r24
    3b38:	29 f1       	breq	.+74     	; 0x3b84 <DIO_void_assign_pin+0x62>
    3b3a:	89 81       	ldd	r24, Y+1	; 0x01
    3b3c:	88 2f       	mov	r24, r24
    3b3e:	90 e0       	ldi	r25, 0x00	; 0
    3b40:	88 0f       	add	r24, r24
    3b42:	99 1f       	adc	r25, r25
    3b44:	fc 01       	movw	r30, r24
    3b46:	e0 58       	subi	r30, 0x80	; 128
    3b48:	ff 4f       	sbci	r31, 0xFF	; 255
    3b4a:	a0 81       	ld	r26, Z
    3b4c:	b1 81       	ldd	r27, Z+1	; 0x01
    3b4e:	89 81       	ldd	r24, Y+1	; 0x01
    3b50:	88 2f       	mov	r24, r24
    3b52:	90 e0       	ldi	r25, 0x00	; 0
    3b54:	88 0f       	add	r24, r24
    3b56:	99 1f       	adc	r25, r25
    3b58:	fc 01       	movw	r30, r24
    3b5a:	e0 58       	subi	r30, 0x80	; 128
    3b5c:	ff 4f       	sbci	r31, 0xFF	; 255
    3b5e:	01 90       	ld	r0, Z+
    3b60:	f0 81       	ld	r31, Z
    3b62:	e0 2d       	mov	r30, r0
    3b64:	80 81       	ld	r24, Z
    3b66:	48 2f       	mov	r20, r24
    3b68:	8a 81       	ldd	r24, Y+2	; 0x02
    3b6a:	28 2f       	mov	r18, r24
    3b6c:	30 e0       	ldi	r19, 0x00	; 0
    3b6e:	81 e0       	ldi	r24, 0x01	; 1
    3b70:	90 e0       	ldi	r25, 0x00	; 0
    3b72:	02 2e       	mov	r0, r18
    3b74:	02 c0       	rjmp	.+4      	; 0x3b7a <DIO_void_assign_pin+0x58>
    3b76:	88 0f       	add	r24, r24
    3b78:	99 1f       	adc	r25, r25
    3b7a:	0a 94       	dec	r0
    3b7c:	e2 f7       	brpl	.-8      	; 0x3b76 <DIO_void_assign_pin+0x54>
    3b7e:	84 2b       	or	r24, r20
    3b80:	8c 93       	st	X, r24
    3b82:	25 c0       	rjmp	.+74     	; 0x3bce <DIO_void_assign_pin+0xac>
    3b84:	89 81       	ldd	r24, Y+1	; 0x01
    3b86:	88 2f       	mov	r24, r24
    3b88:	90 e0       	ldi	r25, 0x00	; 0
    3b8a:	88 0f       	add	r24, r24
    3b8c:	99 1f       	adc	r25, r25
    3b8e:	fc 01       	movw	r30, r24
    3b90:	e0 58       	subi	r30, 0x80	; 128
    3b92:	ff 4f       	sbci	r31, 0xFF	; 255
    3b94:	a0 81       	ld	r26, Z
    3b96:	b1 81       	ldd	r27, Z+1	; 0x01
    3b98:	89 81       	ldd	r24, Y+1	; 0x01
    3b9a:	88 2f       	mov	r24, r24
    3b9c:	90 e0       	ldi	r25, 0x00	; 0
    3b9e:	88 0f       	add	r24, r24
    3ba0:	99 1f       	adc	r25, r25
    3ba2:	fc 01       	movw	r30, r24
    3ba4:	e0 58       	subi	r30, 0x80	; 128
    3ba6:	ff 4f       	sbci	r31, 0xFF	; 255
    3ba8:	01 90       	ld	r0, Z+
    3baa:	f0 81       	ld	r31, Z
    3bac:	e0 2d       	mov	r30, r0
    3bae:	80 81       	ld	r24, Z
    3bb0:	48 2f       	mov	r20, r24
    3bb2:	8a 81       	ldd	r24, Y+2	; 0x02
    3bb4:	28 2f       	mov	r18, r24
    3bb6:	30 e0       	ldi	r19, 0x00	; 0
    3bb8:	81 e0       	ldi	r24, 0x01	; 1
    3bba:	90 e0       	ldi	r25, 0x00	; 0
    3bbc:	02 2e       	mov	r0, r18
    3bbe:	02 c0       	rjmp	.+4      	; 0x3bc4 <DIO_void_assign_pin+0xa2>
    3bc0:	88 0f       	add	r24, r24
    3bc2:	99 1f       	adc	r25, r25
    3bc4:	0a 94       	dec	r0
    3bc6:	e2 f7       	brpl	.-8      	; 0x3bc0 <DIO_void_assign_pin+0x9e>
    3bc8:	80 95       	com	r24
    3bca:	84 23       	and	r24, r20
    3bcc:	8c 93       	st	X, r24
}
    3bce:	0f 90       	pop	r0
    3bd0:	0f 90       	pop	r0
    3bd2:	0f 90       	pop	r0
    3bd4:	cf 91       	pop	r28
    3bd6:	df 91       	pop	r29
    3bd8:	08 95       	ret

00003bda <DIO_u8_get_port>:


/* Get value from input PORTx functions */
u8 DIO_u8_get_port(u8 copy_u8_port_id)
{
    3bda:	df 93       	push	r29
    3bdc:	cf 93       	push	r28
    3bde:	0f 92       	push	r0
    3be0:	cd b7       	in	r28, 0x3d	; 61
    3be2:	de b7       	in	r29, 0x3e	; 62
    3be4:	89 83       	std	Y+1, r24	; 0x01
	 *	
	 *	Function does not affect any regester it only gets
	 *	from the value in the input regester PINx of the 
	 *	given port                                                 
	 */
	return *(DIO_PINx_REF[copy_u8_port_id]);
    3be6:	89 81       	ldd	r24, Y+1	; 0x01
    3be8:	88 2f       	mov	r24, r24
    3bea:	90 e0       	ldi	r25, 0x00	; 0
    3bec:	88 0f       	add	r24, r24
    3bee:	99 1f       	adc	r25, r25
    3bf0:	fc 01       	movw	r30, r24
    3bf2:	e0 59       	subi	r30, 0x90	; 144
    3bf4:	ff 4f       	sbci	r31, 0xFF	; 255
    3bf6:	01 90       	ld	r0, Z+
    3bf8:	f0 81       	ld	r31, Z
    3bfa:	e0 2d       	mov	r30, r0
    3bfc:	80 81       	ld	r24, Z
}
    3bfe:	0f 90       	pop	r0
    3c00:	cf 91       	pop	r28
    3c02:	df 91       	pop	r29
    3c04:	08 95       	ret

00003c06 <DIO_u8_get_pin>:


/* Get value from input PINx functions */
u8 DIO_u8_get_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    3c06:	df 93       	push	r29
    3c08:	cf 93       	push	r28
    3c0a:	00 d0       	rcall	.+0      	; 0x3c0c <DIO_u8_get_pin+0x6>
    3c0c:	cd b7       	in	r28, 0x3d	; 61
    3c0e:	de b7       	in	r29, 0x3e	; 62
    3c10:	89 83       	std	Y+1, r24	; 0x01
    3c12:	6a 83       	std	Y+2, r22	; 0x02
	 *	
	 *	Function does not affect any regester it only gets the pin
	 *	value from the value in the input regester PINx of the 
	 *	given port                                                 
	 */
	return get_bit(*(DIO_PINx_REF[copy_u8_port_id]), copy_u8_pin_num);
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	88 2f       	mov	r24, r24
    3c18:	90 e0       	ldi	r25, 0x00	; 0
    3c1a:	88 0f       	add	r24, r24
    3c1c:	99 1f       	adc	r25, r25
    3c1e:	fc 01       	movw	r30, r24
    3c20:	e0 59       	subi	r30, 0x90	; 144
    3c22:	ff 4f       	sbci	r31, 0xFF	; 255
    3c24:	01 90       	ld	r0, Z+
    3c26:	f0 81       	ld	r31, Z
    3c28:	e0 2d       	mov	r30, r0
    3c2a:	80 81       	ld	r24, Z
    3c2c:	28 2f       	mov	r18, r24
    3c2e:	30 e0       	ldi	r19, 0x00	; 0
    3c30:	8a 81       	ldd	r24, Y+2	; 0x02
    3c32:	88 2f       	mov	r24, r24
    3c34:	90 e0       	ldi	r25, 0x00	; 0
    3c36:	a9 01       	movw	r20, r18
    3c38:	02 c0       	rjmp	.+4      	; 0x3c3e <DIO_u8_get_pin+0x38>
    3c3a:	55 95       	asr	r21
    3c3c:	47 95       	ror	r20
    3c3e:	8a 95       	dec	r24
    3c40:	e2 f7       	brpl	.-8      	; 0x3c3a <DIO_u8_get_pin+0x34>
    3c42:	ca 01       	movw	r24, r20
    3c44:	81 70       	andi	r24, 0x01	; 1
}
    3c46:	0f 90       	pop	r0
    3c48:	0f 90       	pop	r0
    3c4a:	cf 91       	pop	r28
    3c4c:	df 91       	pop	r29
    3c4e:	08 95       	ret

00003c50 <memcpy>:
    3c50:	fb 01       	movw	r30, r22
    3c52:	dc 01       	movw	r26, r24
    3c54:	02 c0       	rjmp	.+4      	; 0x3c5a <memcpy+0xa>
    3c56:	01 90       	ld	r0, Z+
    3c58:	0d 92       	st	X+, r0
    3c5a:	41 50       	subi	r20, 0x01	; 1
    3c5c:	50 40       	sbci	r21, 0x00	; 0
    3c5e:	d8 f7       	brcc	.-10     	; 0x3c56 <memcpy+0x6>
    3c60:	08 95       	ret

00003c62 <_exit>:
    3c62:	f8 94       	cli

00003c64 <__stop_program>:
    3c64:	ff cf       	rjmp	.-2      	; 0x3c64 <__stop_program>
