
APP_DEMO_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004a3e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000038  00800060  00004a3e  00004ad2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002b1  00800098  00800098  00004b0a  2**0
                  ALLOC
  3 .stab         00006d50  00000000  00000000  00004b0c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000055b0  00000000  00000000  0000b85c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00010e0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00010f4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  000110bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00012d05  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00013bf0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000149a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00014b00  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00014d8d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001555b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 92 0f 	jmp	0x1f24	; 0x1f24 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e3       	ldi	r30, 0x3E	; 62
      68:	fa e4       	ldi	r31, 0x4A	; 74
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 39       	cpi	r26, 0x98	; 152
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 e9       	ldi	r26, 0x98	; 152
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 34       	cpi	r26, 0x49	; 73
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 a3 05 	call	0xb46	; 0xb46 <main>
      8a:	0c 94 1d 25 	jmp	0x4a3a	; 0x4a3a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 dd 24 	jmp	0x49ba	; 0x49ba <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a7 e7       	ldi	r26, 0x77	; 119
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 f9 24 	jmp	0x49f2	; 0x49f2 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 e9 24 	jmp	0x49d2	; 0x49d2 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 05 25 	jmp	0x4a0a	; 0x4a0a <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 e9 24 	jmp	0x49d2	; 0x49d2 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 05 25 	jmp	0x4a0a	; 0x4a0a <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 dd 24 	jmp	0x49ba	; 0x49ba <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	87 e7       	ldi	r24, 0x77	; 119
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 f9 24 	jmp	0x49f2	; 0x49f2 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 e9 24 	jmp	0x49d2	; 0x49d2 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 05 25 	jmp	0x4a0a	; 0x4a0a <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 e9 24 	jmp	0x49d2	; 0x49d2 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 05 25 	jmp	0x4a0a	; 0x4a0a <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 e9 24 	jmp	0x49d2	; 0x49d2 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 05 25 	jmp	0x4a0a	; 0x4a0a <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 ed 24 	jmp	0x49da	; 0x49da <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 09 25 	jmp	0x4a12	; 0x4a12 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <main>:

// Global variables
SemaphoreHandle_t x_sem;

int main( void )
{
     b46:	ef 92       	push	r14
     b48:	ff 92       	push	r15
     b4a:	0f 93       	push	r16
     b4c:	df 93       	push	r29
     b4e:	cf 93       	push	r28
     b50:	cd b7       	in	r28, 0x3d	; 61
     b52:	de b7       	in	r29, 0x3e	; 62
	// Setup section

	vSemaphoreCreateBinary(x_sem);
     b54:	81 e0       	ldi	r24, 0x01	; 1
     b56:	60 e0       	ldi	r22, 0x00	; 0
     b58:	43 e0       	ldi	r20, 0x03	; 3
     b5a:	0e 94 1b 10 	call	0x2036	; 0x2036 <xQueueGenericCreate>
     b5e:	90 93 48 03 	sts	0x0348, r25
     b62:	80 93 47 03 	sts	0x0347, r24
     b66:	80 91 47 03 	lds	r24, 0x0347
     b6a:	90 91 48 03 	lds	r25, 0x0348
     b6e:	00 97       	sbiw	r24, 0x00	; 0
     b70:	59 f0       	breq	.+22     	; 0xb88 <main+0x42>
     b72:	80 91 47 03 	lds	r24, 0x0347
     b76:	90 91 48 03 	lds	r25, 0x0348
     b7a:	60 e0       	ldi	r22, 0x00	; 0
     b7c:	70 e0       	ldi	r23, 0x00	; 0
     b7e:	40 e0       	ldi	r20, 0x00	; 0
     b80:	50 e0       	ldi	r21, 0x00	; 0
     b82:	20 e0       	ldi	r18, 0x00	; 0
     b84:	0e 94 a7 10 	call	0x214e	; 0x214e <xQueueGenericSend>
	xSemaphoreGive(x_sem);
     b88:	80 91 47 03 	lds	r24, 0x0347
     b8c:	90 91 48 03 	lds	r25, 0x0348
     b90:	60 e0       	ldi	r22, 0x00	; 0
     b92:	70 e0       	ldi	r23, 0x00	; 0
     b94:	40 e0       	ldi	r20, 0x00	; 0
     b96:	50 e0       	ldi	r21, 0x00	; 0
     b98:	20 e0       	ldi	r18, 0x00	; 0
     b9a:	0e 94 a7 10 	call	0x214e	; 0x214e <xQueueGenericSend>

	xTaskCreate(Task3, "LED_3", 85, NULL, 3, NULL);
     b9e:	8a e0       	ldi	r24, 0x0A	; 10
     ba0:	97 e0       	ldi	r25, 0x07	; 7
     ba2:	20 e6       	ldi	r18, 0x60	; 96
     ba4:	30 e0       	ldi	r19, 0x00	; 0
     ba6:	b9 01       	movw	r22, r18
     ba8:	45 e5       	ldi	r20, 0x55	; 85
     baa:	50 e0       	ldi	r21, 0x00	; 0
     bac:	20 e0       	ldi	r18, 0x00	; 0
     bae:	30 e0       	ldi	r19, 0x00	; 0
     bb0:	03 e0       	ldi	r16, 0x03	; 3
     bb2:	ee 24       	eor	r14, r14
     bb4:	ff 24       	eor	r15, r15
     bb6:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <xTaskCreate>

	vTaskStartScheduler();
     bba:	0e 94 f7 18 	call	0x31ee	; 0x31ee <vTaskStartScheduler>
     bbe:	ff cf       	rjmp	.-2      	; 0xbbe <main+0x78>

00000bc0 <Task1>:
	return 0;
}


void Task1 ( void * TaskParameter)
{
     bc0:	df 93       	push	r29
     bc2:	cf 93       	push	r28
     bc4:	cd b7       	in	r28, 0x3d	; 61
     bc6:	de b7       	in	r29, 0x3e	; 62
     bc8:	60 97       	sbiw	r28, 0x10	; 16
     bca:	0f b6       	in	r0, 0x3f	; 63
     bcc:	f8 94       	cli
     bce:	de bf       	out	0x3e, r29	; 62
     bd0:	0f be       	out	0x3f, r0	; 63
     bd2:	cd bf       	out	0x3d, r28	; 61
     bd4:	98 8b       	std	Y+16, r25	; 0x10
     bd6:	8f 87       	std	Y+15, r24	; 0x0f
	// Setup section
	DIO_void_set_pin_dir(DIO_REF_PORTA, B1, OUTPUT);
     bd8:	80 e0       	ldi	r24, 0x00	; 0
     bda:	61 e0       	ldi	r22, 0x01	; 1
     bdc:	41 e0       	ldi	r20, 0x01	; 1
     bde:	0e 94 3d 22 	call	0x447a	; 0x447a <DIO_void_set_pin_dir>
	DIO_void_set_pin(DIO_REF_PORTA, B1);
     be2:	80 e0       	ldi	r24, 0x00	; 0
     be4:	61 e0       	ldi	r22, 0x01	; 1
     be6:	0e 94 90 23 	call	0x4720	; 0x4720 <DIO_void_set_pin>
     bea:	80 e0       	ldi	r24, 0x00	; 0
     bec:	90 e0       	ldi	r25, 0x00	; 0
     bee:	aa e7       	ldi	r26, 0x7A	; 122
     bf0:	b4 e4       	ldi	r27, 0x44	; 68
     bf2:	8b 87       	std	Y+11, r24	; 0x0b
     bf4:	9c 87       	std	Y+12, r25	; 0x0c
     bf6:	ad 87       	std	Y+13, r26	; 0x0d
     bf8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     bfa:	6b 85       	ldd	r22, Y+11	; 0x0b
     bfc:	7c 85       	ldd	r23, Y+12	; 0x0c
     bfe:	8d 85       	ldd	r24, Y+13	; 0x0d
     c00:	9e 85       	ldd	r25, Y+14	; 0x0e
     c02:	20 e0       	ldi	r18, 0x00	; 0
     c04:	30 e0       	ldi	r19, 0x00	; 0
     c06:	4a e7       	ldi	r20, 0x7A	; 122
     c08:	55 e4       	ldi	r21, 0x45	; 69
     c0a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     c0e:	dc 01       	movw	r26, r24
     c10:	cb 01       	movw	r24, r22
     c12:	8f 83       	std	Y+7, r24	; 0x07
     c14:	98 87       	std	Y+8, r25	; 0x08
     c16:	a9 87       	std	Y+9, r26	; 0x09
     c18:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     c1a:	6f 81       	ldd	r22, Y+7	; 0x07
     c1c:	78 85       	ldd	r23, Y+8	; 0x08
     c1e:	89 85       	ldd	r24, Y+9	; 0x09
     c20:	9a 85       	ldd	r25, Y+10	; 0x0a
     c22:	20 e0       	ldi	r18, 0x00	; 0
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	40 e8       	ldi	r20, 0x80	; 128
     c28:	5f e3       	ldi	r21, 0x3F	; 63
     c2a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     c2e:	88 23       	and	r24, r24
     c30:	2c f4       	brge	.+10     	; 0xc3c <Task1+0x7c>
		__ticks = 1;
     c32:	81 e0       	ldi	r24, 0x01	; 1
     c34:	90 e0       	ldi	r25, 0x00	; 0
     c36:	9e 83       	std	Y+6, r25	; 0x06
     c38:	8d 83       	std	Y+5, r24	; 0x05
     c3a:	3f c0       	rjmp	.+126    	; 0xcba <Task1+0xfa>
	else if (__tmp > 65535)
     c3c:	6f 81       	ldd	r22, Y+7	; 0x07
     c3e:	78 85       	ldd	r23, Y+8	; 0x08
     c40:	89 85       	ldd	r24, Y+9	; 0x09
     c42:	9a 85       	ldd	r25, Y+10	; 0x0a
     c44:	20 e0       	ldi	r18, 0x00	; 0
     c46:	3f ef       	ldi	r19, 0xFF	; 255
     c48:	4f e7       	ldi	r20, 0x7F	; 127
     c4a:	57 e4       	ldi	r21, 0x47	; 71
     c4c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     c50:	18 16       	cp	r1, r24
     c52:	4c f5       	brge	.+82     	; 0xca6 <Task1+0xe6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     c54:	6b 85       	ldd	r22, Y+11	; 0x0b
     c56:	7c 85       	ldd	r23, Y+12	; 0x0c
     c58:	8d 85       	ldd	r24, Y+13	; 0x0d
     c5a:	9e 85       	ldd	r25, Y+14	; 0x0e
     c5c:	20 e0       	ldi	r18, 0x00	; 0
     c5e:	30 e0       	ldi	r19, 0x00	; 0
     c60:	40 e2       	ldi	r20, 0x20	; 32
     c62:	51 e4       	ldi	r21, 0x41	; 65
     c64:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     c68:	dc 01       	movw	r26, r24
     c6a:	cb 01       	movw	r24, r22
     c6c:	bc 01       	movw	r22, r24
     c6e:	cd 01       	movw	r24, r26
     c70:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     c74:	dc 01       	movw	r26, r24
     c76:	cb 01       	movw	r24, r22
     c78:	9e 83       	std	Y+6, r25	; 0x06
     c7a:	8d 83       	std	Y+5, r24	; 0x05
     c7c:	0f c0       	rjmp	.+30     	; 0xc9c <Task1+0xdc>
     c7e:	80 e9       	ldi	r24, 0x90	; 144
     c80:	91 e0       	ldi	r25, 0x01	; 1
     c82:	9c 83       	std	Y+4, r25	; 0x04
     c84:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c86:	8b 81       	ldd	r24, Y+3	; 0x03
     c88:	9c 81       	ldd	r25, Y+4	; 0x04
     c8a:	01 97       	sbiw	r24, 0x01	; 1
     c8c:	f1 f7       	brne	.-4      	; 0xc8a <Task1+0xca>
     c8e:	9c 83       	std	Y+4, r25	; 0x04
     c90:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     c92:	8d 81       	ldd	r24, Y+5	; 0x05
     c94:	9e 81       	ldd	r25, Y+6	; 0x06
     c96:	01 97       	sbiw	r24, 0x01	; 1
     c98:	9e 83       	std	Y+6, r25	; 0x06
     c9a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     c9c:	8d 81       	ldd	r24, Y+5	; 0x05
     c9e:	9e 81       	ldd	r25, Y+6	; 0x06
     ca0:	00 97       	sbiw	r24, 0x00	; 0
     ca2:	69 f7       	brne	.-38     	; 0xc7e <Task1+0xbe>
     ca4:	14 c0       	rjmp	.+40     	; 0xcce <Task1+0x10e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     ca6:	6f 81       	ldd	r22, Y+7	; 0x07
     ca8:	78 85       	ldd	r23, Y+8	; 0x08
     caa:	89 85       	ldd	r24, Y+9	; 0x09
     cac:	9a 85       	ldd	r25, Y+10	; 0x0a
     cae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     cb2:	dc 01       	movw	r26, r24
     cb4:	cb 01       	movw	r24, r22
     cb6:	9e 83       	std	Y+6, r25	; 0x06
     cb8:	8d 83       	std	Y+5, r24	; 0x05
     cba:	8d 81       	ldd	r24, Y+5	; 0x05
     cbc:	9e 81       	ldd	r25, Y+6	; 0x06
     cbe:	9a 83       	std	Y+2, r25	; 0x02
     cc0:	89 83       	std	Y+1, r24	; 0x01
     cc2:	89 81       	ldd	r24, Y+1	; 0x01
     cc4:	9a 81       	ldd	r25, Y+2	; 0x02
     cc6:	01 97       	sbiw	r24, 0x01	; 1
     cc8:	f1 f7       	brne	.-4      	; 0xcc6 <Task1+0x106>
     cca:	9a 83       	std	Y+2, r25	; 0x02
     ccc:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(1000);

	DIO_void_clear_pin(DIO_REF_PORTA, B1);
     cce:	80 e0       	ldi	r24, 0x00	; 0
     cd0:	61 e0       	ldi	r22, 0x01	; 1
     cd2:	0e 94 c0 23 	call	0x4780	; 0x4780 <DIO_void_clear_pin>

	while ( 1 )
	{
		// Super loop
		if(xSemaphoreTake(x_sem, portMAX_DELAY))
     cd6:	80 91 47 03 	lds	r24, 0x0347
     cda:	90 91 48 03 	lds	r25, 0x0348
     cde:	6f ef       	ldi	r22, 0xFF	; 255
     ce0:	7f ef       	ldi	r23, 0xFF	; 255
     ce2:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueSemaphoreTake>
     ce6:	88 23       	and	r24, r24
     ce8:	b1 f3       	breq	.-20     	; 0xcd6 <Task1+0x116>
		{
			DIO_void_set_pin(DIO_REF_PORTA, B1);
     cea:	80 e0       	ldi	r24, 0x00	; 0
     cec:	61 e0       	ldi	r22, 0x01	; 1
     cee:	0e 94 90 23 	call	0x4720	; 0x4720 <DIO_void_set_pin>
     cf2:	f1 cf       	rjmp	.-30     	; 0xcd6 <Task1+0x116>

00000cf4 <Task2>:

}


void Task2 ( void * TaskParameter)
{
     cf4:	df 93       	push	r29
     cf6:	cf 93       	push	r28
     cf8:	cd b7       	in	r28, 0x3d	; 61
     cfa:	de b7       	in	r29, 0x3e	; 62
     cfc:	60 97       	sbiw	r28, 0x10	; 16
     cfe:	0f b6       	in	r0, 0x3f	; 63
     d00:	f8 94       	cli
     d02:	de bf       	out	0x3e, r29	; 62
     d04:	0f be       	out	0x3f, r0	; 63
     d06:	cd bf       	out	0x3d, r28	; 61
     d08:	98 8b       	std	Y+16, r25	; 0x10
     d0a:	8f 87       	std	Y+15, r24	; 0x0f
	// Setup section
	DIO_void_set_pin_dir(DIO_REF_PORTA, B2, OUTPUT);
     d0c:	80 e0       	ldi	r24, 0x00	; 0
     d0e:	62 e0       	ldi	r22, 0x02	; 2
     d10:	41 e0       	ldi	r20, 0x01	; 1
     d12:	0e 94 3d 22 	call	0x447a	; 0x447a <DIO_void_set_pin_dir>
	DIO_void_set_pin(DIO_REF_PORTA, B2);
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	62 e0       	ldi	r22, 0x02	; 2
     d1a:	0e 94 90 23 	call	0x4720	; 0x4720 <DIO_void_set_pin>
     d1e:	80 e0       	ldi	r24, 0x00	; 0
     d20:	90 e0       	ldi	r25, 0x00	; 0
     d22:	aa e7       	ldi	r26, 0x7A	; 122
     d24:	b4 e4       	ldi	r27, 0x44	; 68
     d26:	8b 87       	std	Y+11, r24	; 0x0b
     d28:	9c 87       	std	Y+12, r25	; 0x0c
     d2a:	ad 87       	std	Y+13, r26	; 0x0d
     d2c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     d2e:	6b 85       	ldd	r22, Y+11	; 0x0b
     d30:	7c 85       	ldd	r23, Y+12	; 0x0c
     d32:	8d 85       	ldd	r24, Y+13	; 0x0d
     d34:	9e 85       	ldd	r25, Y+14	; 0x0e
     d36:	20 e0       	ldi	r18, 0x00	; 0
     d38:	30 e0       	ldi	r19, 0x00	; 0
     d3a:	4a e7       	ldi	r20, 0x7A	; 122
     d3c:	55 e4       	ldi	r21, 0x45	; 69
     d3e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     d42:	dc 01       	movw	r26, r24
     d44:	cb 01       	movw	r24, r22
     d46:	8f 83       	std	Y+7, r24	; 0x07
     d48:	98 87       	std	Y+8, r25	; 0x08
     d4a:	a9 87       	std	Y+9, r26	; 0x09
     d4c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     d4e:	6f 81       	ldd	r22, Y+7	; 0x07
     d50:	78 85       	ldd	r23, Y+8	; 0x08
     d52:	89 85       	ldd	r24, Y+9	; 0x09
     d54:	9a 85       	ldd	r25, Y+10	; 0x0a
     d56:	20 e0       	ldi	r18, 0x00	; 0
     d58:	30 e0       	ldi	r19, 0x00	; 0
     d5a:	40 e8       	ldi	r20, 0x80	; 128
     d5c:	5f e3       	ldi	r21, 0x3F	; 63
     d5e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     d62:	88 23       	and	r24, r24
     d64:	2c f4       	brge	.+10     	; 0xd70 <Task2+0x7c>
		__ticks = 1;
     d66:	81 e0       	ldi	r24, 0x01	; 1
     d68:	90 e0       	ldi	r25, 0x00	; 0
     d6a:	9e 83       	std	Y+6, r25	; 0x06
     d6c:	8d 83       	std	Y+5, r24	; 0x05
     d6e:	3f c0       	rjmp	.+126    	; 0xdee <Task2+0xfa>
	else if (__tmp > 65535)
     d70:	6f 81       	ldd	r22, Y+7	; 0x07
     d72:	78 85       	ldd	r23, Y+8	; 0x08
     d74:	89 85       	ldd	r24, Y+9	; 0x09
     d76:	9a 85       	ldd	r25, Y+10	; 0x0a
     d78:	20 e0       	ldi	r18, 0x00	; 0
     d7a:	3f ef       	ldi	r19, 0xFF	; 255
     d7c:	4f e7       	ldi	r20, 0x7F	; 127
     d7e:	57 e4       	ldi	r21, 0x47	; 71
     d80:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     d84:	18 16       	cp	r1, r24
     d86:	4c f5       	brge	.+82     	; 0xdda <Task2+0xe6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d88:	6b 85       	ldd	r22, Y+11	; 0x0b
     d8a:	7c 85       	ldd	r23, Y+12	; 0x0c
     d8c:	8d 85       	ldd	r24, Y+13	; 0x0d
     d8e:	9e 85       	ldd	r25, Y+14	; 0x0e
     d90:	20 e0       	ldi	r18, 0x00	; 0
     d92:	30 e0       	ldi	r19, 0x00	; 0
     d94:	40 e2       	ldi	r20, 0x20	; 32
     d96:	51 e4       	ldi	r21, 0x41	; 65
     d98:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     d9c:	dc 01       	movw	r26, r24
     d9e:	cb 01       	movw	r24, r22
     da0:	bc 01       	movw	r22, r24
     da2:	cd 01       	movw	r24, r26
     da4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     da8:	dc 01       	movw	r26, r24
     daa:	cb 01       	movw	r24, r22
     dac:	9e 83       	std	Y+6, r25	; 0x06
     dae:	8d 83       	std	Y+5, r24	; 0x05
     db0:	0f c0       	rjmp	.+30     	; 0xdd0 <Task2+0xdc>
     db2:	80 e9       	ldi	r24, 0x90	; 144
     db4:	91 e0       	ldi	r25, 0x01	; 1
     db6:	9c 83       	std	Y+4, r25	; 0x04
     db8:	8b 83       	std	Y+3, r24	; 0x03
     dba:	8b 81       	ldd	r24, Y+3	; 0x03
     dbc:	9c 81       	ldd	r25, Y+4	; 0x04
     dbe:	01 97       	sbiw	r24, 0x01	; 1
     dc0:	f1 f7       	brne	.-4      	; 0xdbe <Task2+0xca>
     dc2:	9c 83       	std	Y+4, r25	; 0x04
     dc4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     dc6:	8d 81       	ldd	r24, Y+5	; 0x05
     dc8:	9e 81       	ldd	r25, Y+6	; 0x06
     dca:	01 97       	sbiw	r24, 0x01	; 1
     dcc:	9e 83       	std	Y+6, r25	; 0x06
     dce:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     dd0:	8d 81       	ldd	r24, Y+5	; 0x05
     dd2:	9e 81       	ldd	r25, Y+6	; 0x06
     dd4:	00 97       	sbiw	r24, 0x00	; 0
     dd6:	69 f7       	brne	.-38     	; 0xdb2 <Task2+0xbe>
     dd8:	14 c0       	rjmp	.+40     	; 0xe02 <Task2+0x10e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     dda:	6f 81       	ldd	r22, Y+7	; 0x07
     ddc:	78 85       	ldd	r23, Y+8	; 0x08
     dde:	89 85       	ldd	r24, Y+9	; 0x09
     de0:	9a 85       	ldd	r25, Y+10	; 0x0a
     de2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     de6:	dc 01       	movw	r26, r24
     de8:	cb 01       	movw	r24, r22
     dea:	9e 83       	std	Y+6, r25	; 0x06
     dec:	8d 83       	std	Y+5, r24	; 0x05
     dee:	8d 81       	ldd	r24, Y+5	; 0x05
     df0:	9e 81       	ldd	r25, Y+6	; 0x06
     df2:	9a 83       	std	Y+2, r25	; 0x02
     df4:	89 83       	std	Y+1, r24	; 0x01
     df6:	89 81       	ldd	r24, Y+1	; 0x01
     df8:	9a 81       	ldd	r25, Y+2	; 0x02
     dfa:	01 97       	sbiw	r24, 0x01	; 1
     dfc:	f1 f7       	brne	.-4      	; 0xdfa <Task2+0x106>
     dfe:	9a 83       	std	Y+2, r25	; 0x02
     e00:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(1000);

	DIO_void_clear_pin(DIO_REF_PORTA, B2);
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	62 e0       	ldi	r22, 0x02	; 2
     e06:	0e 94 c0 23 	call	0x4780	; 0x4780 <DIO_void_clear_pin>

	while ( 1 )
	{
		// Super loop
		vTaskDelay(5000);
     e0a:	88 e8       	ldi	r24, 0x88	; 136
     e0c:	93 e1       	ldi	r25, 0x13	; 19
     e0e:	0e 94 d5 18 	call	0x31aa	; 0x31aa <vTaskDelay>
     e12:	fb cf       	rjmp	.-10     	; 0xe0a <Task2+0x116>

00000e14 <Task3>:

}


void Task3 ( void * TaskParameter)
{
     e14:	ef 92       	push	r14
     e16:	ff 92       	push	r15
     e18:	0f 93       	push	r16
     e1a:	df 93       	push	r29
     e1c:	cf 93       	push	r28
     e1e:	cd b7       	in	r28, 0x3d	; 61
     e20:	de b7       	in	r29, 0x3e	; 62
     e22:	60 97       	sbiw	r28, 0x10	; 16
     e24:	0f b6       	in	r0, 0x3f	; 63
     e26:	f8 94       	cli
     e28:	de bf       	out	0x3e, r29	; 62
     e2a:	0f be       	out	0x3f, r0	; 63
     e2c:	cd bf       	out	0x3d, r28	; 61
     e2e:	98 8b       	std	Y+16, r25	; 0x10
     e30:	8f 87       	std	Y+15, r24	; 0x0f
	// Setup section

	DIO_void_set_pin_dir(DIO_REF_PORTA, B3, OUTPUT);
     e32:	80 e0       	ldi	r24, 0x00	; 0
     e34:	63 e0       	ldi	r22, 0x03	; 3
     e36:	41 e0       	ldi	r20, 0x01	; 1
     e38:	0e 94 3d 22 	call	0x447a	; 0x447a <DIO_void_set_pin_dir>
	DIO_void_set_pin(DIO_REF_PORTA, B3);
     e3c:	80 e0       	ldi	r24, 0x00	; 0
     e3e:	63 e0       	ldi	r22, 0x03	; 3
     e40:	0e 94 90 23 	call	0x4720	; 0x4720 <DIO_void_set_pin>
     e44:	80 e0       	ldi	r24, 0x00	; 0
     e46:	90 e0       	ldi	r25, 0x00	; 0
     e48:	aa e7       	ldi	r26, 0x7A	; 122
     e4a:	b4 e4       	ldi	r27, 0x44	; 68
     e4c:	8b 87       	std	Y+11, r24	; 0x0b
     e4e:	9c 87       	std	Y+12, r25	; 0x0c
     e50:	ad 87       	std	Y+13, r26	; 0x0d
     e52:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     e54:	6b 85       	ldd	r22, Y+11	; 0x0b
     e56:	7c 85       	ldd	r23, Y+12	; 0x0c
     e58:	8d 85       	ldd	r24, Y+13	; 0x0d
     e5a:	9e 85       	ldd	r25, Y+14	; 0x0e
     e5c:	20 e0       	ldi	r18, 0x00	; 0
     e5e:	30 e0       	ldi	r19, 0x00	; 0
     e60:	4a e7       	ldi	r20, 0x7A	; 122
     e62:	55 e4       	ldi	r21, 0x45	; 69
     e64:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     e68:	dc 01       	movw	r26, r24
     e6a:	cb 01       	movw	r24, r22
     e6c:	8f 83       	std	Y+7, r24	; 0x07
     e6e:	98 87       	std	Y+8, r25	; 0x08
     e70:	a9 87       	std	Y+9, r26	; 0x09
     e72:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     e74:	6f 81       	ldd	r22, Y+7	; 0x07
     e76:	78 85       	ldd	r23, Y+8	; 0x08
     e78:	89 85       	ldd	r24, Y+9	; 0x09
     e7a:	9a 85       	ldd	r25, Y+10	; 0x0a
     e7c:	20 e0       	ldi	r18, 0x00	; 0
     e7e:	30 e0       	ldi	r19, 0x00	; 0
     e80:	40 e8       	ldi	r20, 0x80	; 128
     e82:	5f e3       	ldi	r21, 0x3F	; 63
     e84:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     e88:	88 23       	and	r24, r24
     e8a:	2c f4       	brge	.+10     	; 0xe96 <Task3+0x82>
		__ticks = 1;
     e8c:	81 e0       	ldi	r24, 0x01	; 1
     e8e:	90 e0       	ldi	r25, 0x00	; 0
     e90:	9e 83       	std	Y+6, r25	; 0x06
     e92:	8d 83       	std	Y+5, r24	; 0x05
     e94:	3f c0       	rjmp	.+126    	; 0xf14 <Task3+0x100>
	else if (__tmp > 65535)
     e96:	6f 81       	ldd	r22, Y+7	; 0x07
     e98:	78 85       	ldd	r23, Y+8	; 0x08
     e9a:	89 85       	ldd	r24, Y+9	; 0x09
     e9c:	9a 85       	ldd	r25, Y+10	; 0x0a
     e9e:	20 e0       	ldi	r18, 0x00	; 0
     ea0:	3f ef       	ldi	r19, 0xFF	; 255
     ea2:	4f e7       	ldi	r20, 0x7F	; 127
     ea4:	57 e4       	ldi	r21, 0x47	; 71
     ea6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     eaa:	18 16       	cp	r1, r24
     eac:	4c f5       	brge	.+82     	; 0xf00 <Task3+0xec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     eae:	6b 85       	ldd	r22, Y+11	; 0x0b
     eb0:	7c 85       	ldd	r23, Y+12	; 0x0c
     eb2:	8d 85       	ldd	r24, Y+13	; 0x0d
     eb4:	9e 85       	ldd	r25, Y+14	; 0x0e
     eb6:	20 e0       	ldi	r18, 0x00	; 0
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	40 e2       	ldi	r20, 0x20	; 32
     ebc:	51 e4       	ldi	r21, 0x41	; 65
     ebe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ec2:	dc 01       	movw	r26, r24
     ec4:	cb 01       	movw	r24, r22
     ec6:	bc 01       	movw	r22, r24
     ec8:	cd 01       	movw	r24, r26
     eca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     ece:	dc 01       	movw	r26, r24
     ed0:	cb 01       	movw	r24, r22
     ed2:	9e 83       	std	Y+6, r25	; 0x06
     ed4:	8d 83       	std	Y+5, r24	; 0x05
     ed6:	0f c0       	rjmp	.+30     	; 0xef6 <Task3+0xe2>
     ed8:	80 e9       	ldi	r24, 0x90	; 144
     eda:	91 e0       	ldi	r25, 0x01	; 1
     edc:	9c 83       	std	Y+4, r25	; 0x04
     ede:	8b 83       	std	Y+3, r24	; 0x03
     ee0:	8b 81       	ldd	r24, Y+3	; 0x03
     ee2:	9c 81       	ldd	r25, Y+4	; 0x04
     ee4:	01 97       	sbiw	r24, 0x01	; 1
     ee6:	f1 f7       	brne	.-4      	; 0xee4 <Task3+0xd0>
     ee8:	9c 83       	std	Y+4, r25	; 0x04
     eea:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     eec:	8d 81       	ldd	r24, Y+5	; 0x05
     eee:	9e 81       	ldd	r25, Y+6	; 0x06
     ef0:	01 97       	sbiw	r24, 0x01	; 1
     ef2:	9e 83       	std	Y+6, r25	; 0x06
     ef4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     ef6:	8d 81       	ldd	r24, Y+5	; 0x05
     ef8:	9e 81       	ldd	r25, Y+6	; 0x06
     efa:	00 97       	sbiw	r24, 0x00	; 0
     efc:	69 f7       	brne	.-38     	; 0xed8 <Task3+0xc4>
     efe:	14 c0       	rjmp	.+40     	; 0xf28 <Task3+0x114>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f00:	6f 81       	ldd	r22, Y+7	; 0x07
     f02:	78 85       	ldd	r23, Y+8	; 0x08
     f04:	89 85       	ldd	r24, Y+9	; 0x09
     f06:	9a 85       	ldd	r25, Y+10	; 0x0a
     f08:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f0c:	dc 01       	movw	r26, r24
     f0e:	cb 01       	movw	r24, r22
     f10:	9e 83       	std	Y+6, r25	; 0x06
     f12:	8d 83       	std	Y+5, r24	; 0x05
     f14:	8d 81       	ldd	r24, Y+5	; 0x05
     f16:	9e 81       	ldd	r25, Y+6	; 0x06
     f18:	9a 83       	std	Y+2, r25	; 0x02
     f1a:	89 83       	std	Y+1, r24	; 0x01
     f1c:	89 81       	ldd	r24, Y+1	; 0x01
     f1e:	9a 81       	ldd	r25, Y+2	; 0x02
     f20:	01 97       	sbiw	r24, 0x01	; 1
     f22:	f1 f7       	brne	.-4      	; 0xf20 <Task3+0x10c>
     f24:	9a 83       	std	Y+2, r25	; 0x02
     f26:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(1000);

	DIO_void_clear_pin(DIO_REF_PORTA, B3);
     f28:	80 e0       	ldi	r24, 0x00	; 0
     f2a:	63 e0       	ldi	r22, 0x03	; 3
     f2c:	0e 94 c0 23 	call	0x4780	; 0x4780 <DIO_void_clear_pin>

	while ( 1 )
	{
		// Super loop
		if(xSemaphoreTake(x_sem, portMAX_DELAY))
     f30:	80 91 47 03 	lds	r24, 0x0347
     f34:	90 91 48 03 	lds	r25, 0x0348
     f38:	6f ef       	ldi	r22, 0xFF	; 255
     f3a:	7f ef       	ldi	r23, 0xFF	; 255
     f3c:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueSemaphoreTake>
     f40:	88 23       	and	r24, r24
     f42:	b1 f3       	breq	.-20     	; 0xf30 <Task3+0x11c>
		{
			xTaskCreate(Task1, "LED_1", 85, NULL, 1, NULL);
     f44:	80 ee       	ldi	r24, 0xE0	; 224
     f46:	95 e0       	ldi	r25, 0x05	; 5
     f48:	26 e6       	ldi	r18, 0x66	; 102
     f4a:	30 e0       	ldi	r19, 0x00	; 0
     f4c:	b9 01       	movw	r22, r18
     f4e:	45 e5       	ldi	r20, 0x55	; 85
     f50:	50 e0       	ldi	r21, 0x00	; 0
     f52:	20 e0       	ldi	r18, 0x00	; 0
     f54:	30 e0       	ldi	r19, 0x00	; 0
     f56:	01 e0       	ldi	r16, 0x01	; 1
     f58:	ee 24       	eor	r14, r14
     f5a:	ff 24       	eor	r15, r15
     f5c:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <xTaskCreate>
			xTaskCreate(Task2, "LED_2", 85, NULL, 2, NULL);
     f60:	8a e7       	ldi	r24, 0x7A	; 122
     f62:	96 e0       	ldi	r25, 0x06	; 6
     f64:	2c e6       	ldi	r18, 0x6C	; 108
     f66:	30 e0       	ldi	r19, 0x00	; 0
     f68:	b9 01       	movw	r22, r18
     f6a:	45 e5       	ldi	r20, 0x55	; 85
     f6c:	50 e0       	ldi	r21, 0x00	; 0
     f6e:	20 e0       	ldi	r18, 0x00	; 0
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	02 e0       	ldi	r16, 0x02	; 2
     f74:	ee 24       	eor	r14, r14
     f76:	ff 24       	eor	r15, r15
     f78:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <xTaskCreate>
			xSemaphoreGive(x_sem);
     f7c:	80 91 47 03 	lds	r24, 0x0347
     f80:	90 91 48 03 	lds	r25, 0x0348
     f84:	60 e0       	ldi	r22, 0x00	; 0
     f86:	70 e0       	ldi	r23, 0x00	; 0
     f88:	40 e0       	ldi	r20, 0x00	; 0
     f8a:	50 e0       	ldi	r21, 0x00	; 0
     f8c:	20 e0       	ldi	r18, 0x00	; 0
     f8e:	0e 94 a7 10 	call	0x214e	; 0x214e <xQueueGenericSend>
     f92:	ce cf       	rjmp	.-100    	; 0xf30 <Task3+0x11c>

00000f94 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     f94:	df 93       	push	r29
     f96:	cf 93       	push	r28
     f98:	00 d0       	rcall	.+0      	; 0xf9a <xEventGroupCreate+0x6>
     f9a:	cd b7       	in	r28, 0x3d	; 61
     f9c:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     f9e:	8b e0       	ldi	r24, 0x0B	; 11
     fa0:	90 e0       	ldi	r25, 0x00	; 0
     fa2:	0e 94 0f 0b 	call	0x161e	; 0x161e <pvPortMalloc>
     fa6:	9a 83       	std	Y+2, r25	; 0x02
     fa8:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     faa:	89 81       	ldd	r24, Y+1	; 0x01
     fac:	9a 81       	ldd	r25, Y+2	; 0x02
     fae:	00 97       	sbiw	r24, 0x00	; 0
     fb0:	49 f0       	breq	.+18     	; 0xfc4 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     fb2:	e9 81       	ldd	r30, Y+1	; 0x01
     fb4:	fa 81       	ldd	r31, Y+2	; 0x02
     fb6:	11 82       	std	Z+1, r1	; 0x01
     fb8:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     fba:	89 81       	ldd	r24, Y+1	; 0x01
     fbc:	9a 81       	ldd	r25, Y+2	; 0x02
     fbe:	02 96       	adiw	r24, 0x02	; 2
     fc0:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     fc4:	89 81       	ldd	r24, Y+1	; 0x01
     fc6:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     fc8:	0f 90       	pop	r0
     fca:	0f 90       	pop	r0
     fcc:	cf 91       	pop	r28
     fce:	df 91       	pop	r29
     fd0:	08 95       	ret

00000fd2 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     fd2:	df 93       	push	r29
     fd4:	cf 93       	push	r28
     fd6:	cd b7       	in	r28, 0x3d	; 61
     fd8:	de b7       	in	r29, 0x3e	; 62
     fda:	60 97       	sbiw	r28, 0x10	; 16
     fdc:	0f b6       	in	r0, 0x3f	; 63
     fde:	f8 94       	cli
     fe0:	de bf       	out	0x3e, r29	; 62
     fe2:	0f be       	out	0x3f, r0	; 63
     fe4:	cd bf       	out	0x3d, r28	; 61
     fe6:	9a 87       	std	Y+10, r25	; 0x0a
     fe8:	89 87       	std	Y+9, r24	; 0x09
     fea:	7c 87       	std	Y+12, r23	; 0x0c
     fec:	6b 87       	std	Y+11, r22	; 0x0b
     fee:	5e 87       	std	Y+14, r21	; 0x0e
     ff0:	4d 87       	std	Y+13, r20	; 0x0d
     ff2:	38 8b       	std	Y+16, r19	; 0x10
     ff4:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     ff6:	89 85       	ldd	r24, Y+9	; 0x09
     ff8:	9a 85       	ldd	r25, Y+10	; 0x0a
     ffa:	9c 83       	std	Y+4, r25	; 0x04
     ffc:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     ffe:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1000:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1004:	eb 81       	ldd	r30, Y+3	; 0x03
    1006:	fc 81       	ldd	r31, Y+4	; 0x04
    1008:	80 81       	ld	r24, Z
    100a:	91 81       	ldd	r25, Z+1	; 0x01
    100c:	98 87       	std	Y+8, r25	; 0x08
    100e:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1010:	89 85       	ldd	r24, Y+9	; 0x09
    1012:	9a 85       	ldd	r25, Y+10	; 0x0a
    1014:	2b 85       	ldd	r18, Y+11	; 0x0b
    1016:	3c 85       	ldd	r19, Y+12	; 0x0c
    1018:	b9 01       	movw	r22, r18
    101a:	0e 94 c0 09 	call	0x1380	; 0x1380 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    101e:	2f 81       	ldd	r18, Y+7	; 0x07
    1020:	38 85       	ldd	r19, Y+8	; 0x08
    1022:	8b 85       	ldd	r24, Y+11	; 0x0b
    1024:	9c 85       	ldd	r25, Y+12	; 0x0c
    1026:	28 2b       	or	r18, r24
    1028:	39 2b       	or	r19, r25
    102a:	8d 85       	ldd	r24, Y+13	; 0x0d
    102c:	9e 85       	ldd	r25, Y+14	; 0x0e
    102e:	28 23       	and	r18, r24
    1030:	39 23       	and	r19, r25
    1032:	8d 85       	ldd	r24, Y+13	; 0x0d
    1034:	9e 85       	ldd	r25, Y+14	; 0x0e
    1036:	28 17       	cp	r18, r24
    1038:	39 07       	cpc	r19, r25
    103a:	c9 f4       	brne	.+50     	; 0x106e <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    103c:	2f 81       	ldd	r18, Y+7	; 0x07
    103e:	38 85       	ldd	r19, Y+8	; 0x08
    1040:	8b 85       	ldd	r24, Y+11	; 0x0b
    1042:	9c 85       	ldd	r25, Y+12	; 0x0c
    1044:	82 2b       	or	r24, r18
    1046:	93 2b       	or	r25, r19
    1048:	9e 83       	std	Y+6, r25	; 0x06
    104a:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    104c:	eb 81       	ldd	r30, Y+3	; 0x03
    104e:	fc 81       	ldd	r31, Y+4	; 0x04
    1050:	20 81       	ld	r18, Z
    1052:	31 81       	ldd	r19, Z+1	; 0x01
    1054:	8d 85       	ldd	r24, Y+13	; 0x0d
    1056:	9e 85       	ldd	r25, Y+14	; 0x0e
    1058:	80 95       	com	r24
    105a:	90 95       	com	r25
    105c:	82 23       	and	r24, r18
    105e:	93 23       	and	r25, r19
    1060:	eb 81       	ldd	r30, Y+3	; 0x03
    1062:	fc 81       	ldd	r31, Y+4	; 0x04
    1064:	91 83       	std	Z+1, r25	; 0x01
    1066:	80 83       	st	Z, r24

			xTicksToWait = 0;
    1068:	18 8a       	std	Y+16, r1	; 0x10
    106a:	1f 86       	std	Y+15, r1	; 0x0f
    106c:	1e c0       	rjmp	.+60     	; 0x10aa <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    106e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1070:	98 89       	ldd	r25, Y+16	; 0x10
    1072:	00 97       	sbiw	r24, 0x00	; 0
    1074:	91 f0       	breq	.+36     	; 0x109a <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1076:	8b 81       	ldd	r24, Y+3	; 0x03
    1078:	9c 81       	ldd	r25, Y+4	; 0x04
    107a:	bc 01       	movw	r22, r24
    107c:	6e 5f       	subi	r22, 0xFE	; 254
    107e:	7f 4f       	sbci	r23, 0xFF	; 255
    1080:	8d 85       	ldd	r24, Y+13	; 0x0d
    1082:	9e 85       	ldd	r25, Y+14	; 0x0e
    1084:	9c 01       	movw	r18, r24
    1086:	35 60       	ori	r19, 0x05	; 5
    1088:	4f 85       	ldd	r20, Y+15	; 0x0f
    108a:	58 89       	ldd	r21, Y+16	; 0x10
    108c:	cb 01       	movw	r24, r22
    108e:	b9 01       	movw	r22, r18
    1090:	0e 94 a5 1b 	call	0x374a	; 0x374a <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    1094:	1e 82       	std	Y+6, r1	; 0x06
    1096:	1d 82       	std	Y+5, r1	; 0x05
    1098:	08 c0       	rjmp	.+16     	; 0x10aa <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    109a:	eb 81       	ldd	r30, Y+3	; 0x03
    109c:	fc 81       	ldd	r31, Y+4	; 0x04
    109e:	80 81       	ld	r24, Z
    10a0:	91 81       	ldd	r25, Z+1	; 0x01
    10a2:	9e 83       	std	Y+6, r25	; 0x06
    10a4:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
    10a6:	81 e0       	ldi	r24, 0x01	; 1
    10a8:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    10aa:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    10ae:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    10b0:	8f 85       	ldd	r24, Y+15	; 0x0f
    10b2:	98 89       	ldd	r25, Y+16	; 0x10
    10b4:	00 97       	sbiw	r24, 0x00	; 0
    10b6:	09 f4       	brne	.+2      	; 0x10ba <xEventGroupSync+0xe8>
    10b8:	3a c0       	rjmp	.+116    	; 0x112e <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
    10ba:	8a 81       	ldd	r24, Y+2	; 0x02
    10bc:	88 23       	and	r24, r24
    10be:	11 f4       	brne	.+4      	; 0x10c4 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
    10c0:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    10c4:	0e 94 b6 1d 	call	0x3b6c	; 0x3b6c <uxTaskResetEventItemValue>
    10c8:	9e 83       	std	Y+6, r25	; 0x06
    10ca:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    10cc:	8d 81       	ldd	r24, Y+5	; 0x05
    10ce:	9e 81       	ldd	r25, Y+6	; 0x06
    10d0:	80 70       	andi	r24, 0x00	; 0
    10d2:	92 70       	andi	r25, 0x02	; 2
    10d4:	00 97       	sbiw	r24, 0x00	; 0
    10d6:	31 f5       	brne	.+76     	; 0x1124 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    10d8:	0f b6       	in	r0, 0x3f	; 63
    10da:	f8 94       	cli
    10dc:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    10de:	eb 81       	ldd	r30, Y+3	; 0x03
    10e0:	fc 81       	ldd	r31, Y+4	; 0x04
    10e2:	80 81       	ld	r24, Z
    10e4:	91 81       	ldd	r25, Z+1	; 0x01
    10e6:	9e 83       	std	Y+6, r25	; 0x06
    10e8:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    10ea:	2d 81       	ldd	r18, Y+5	; 0x05
    10ec:	3e 81       	ldd	r19, Y+6	; 0x06
    10ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    10f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    10f2:	28 23       	and	r18, r24
    10f4:	39 23       	and	r19, r25
    10f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    10f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    10fa:	28 17       	cp	r18, r24
    10fc:	39 07       	cpc	r19, r25
    10fe:	71 f4       	brne	.+28     	; 0x111c <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1100:	eb 81       	ldd	r30, Y+3	; 0x03
    1102:	fc 81       	ldd	r31, Y+4	; 0x04
    1104:	20 81       	ld	r18, Z
    1106:	31 81       	ldd	r19, Z+1	; 0x01
    1108:	8d 85       	ldd	r24, Y+13	; 0x0d
    110a:	9e 85       	ldd	r25, Y+14	; 0x0e
    110c:	80 95       	com	r24
    110e:	90 95       	com	r25
    1110:	82 23       	and	r24, r18
    1112:	93 23       	and	r25, r19
    1114:	eb 81       	ldd	r30, Y+3	; 0x03
    1116:	fc 81       	ldd	r31, Y+4	; 0x04
    1118:	91 83       	std	Z+1, r25	; 0x01
    111a:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    111c:	0f 90       	pop	r0
    111e:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1124:	8d 81       	ldd	r24, Y+5	; 0x05
    1126:	9e 81       	ldd	r25, Y+6	; 0x06
    1128:	90 70       	andi	r25, 0x00	; 0
    112a:	9e 83       	std	Y+6, r25	; 0x06
    112c:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    112e:	8d 81       	ldd	r24, Y+5	; 0x05
    1130:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1132:	60 96       	adiw	r28, 0x10	; 16
    1134:	0f b6       	in	r0, 0x3f	; 63
    1136:	f8 94       	cli
    1138:	de bf       	out	0x3e, r29	; 62
    113a:	0f be       	out	0x3f, r0	; 63
    113c:	cd bf       	out	0x3d, r28	; 61
    113e:	cf 91       	pop	r28
    1140:	df 91       	pop	r29
    1142:	08 95       	ret

00001144 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1144:	0f 93       	push	r16
    1146:	1f 93       	push	r17
    1148:	df 93       	push	r29
    114a:	cf 93       	push	r28
    114c:	cd b7       	in	r28, 0x3d	; 61
    114e:	de b7       	in	r29, 0x3e	; 62
    1150:	63 97       	sbiw	r28, 0x13	; 19
    1152:	0f b6       	in	r0, 0x3f	; 63
    1154:	f8 94       	cli
    1156:	de bf       	out	0x3e, r29	; 62
    1158:	0f be       	out	0x3f, r0	; 63
    115a:	cd bf       	out	0x3d, r28	; 61
    115c:	9d 87       	std	Y+13, r25	; 0x0d
    115e:	8c 87       	std	Y+12, r24	; 0x0c
    1160:	7f 87       	std	Y+15, r23	; 0x0f
    1162:	6e 87       	std	Y+14, r22	; 0x0e
    1164:	48 8b       	std	Y+16, r20	; 0x10
    1166:	29 8b       	std	Y+17, r18	; 0x11
    1168:	1b 8b       	std	Y+19, r17	; 0x13
    116a:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    116c:	8c 85       	ldd	r24, Y+12	; 0x0c
    116e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1170:	9b 87       	std	Y+11, r25	; 0x0b
    1172:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    1174:	1f 82       	std	Y+7, r1	; 0x07
    1176:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1178:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    117a:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    117e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1180:	fb 85       	ldd	r31, Y+11	; 0x0b
    1182:	80 81       	ld	r24, Z
    1184:	91 81       	ldd	r25, Z+1	; 0x01
    1186:	9a 83       	std	Y+2, r25	; 0x02
    1188:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    118a:	89 81       	ldd	r24, Y+1	; 0x01
    118c:	9a 81       	ldd	r25, Y+2	; 0x02
    118e:	2e 85       	ldd	r18, Y+14	; 0x0e
    1190:	3f 85       	ldd	r19, Y+15	; 0x0f
    1192:	b9 01       	movw	r22, r18
    1194:	49 89       	ldd	r20, Y+17	; 0x11
    1196:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <prvTestWaitCondition>
    119a:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    119c:	8d 81       	ldd	r24, Y+5	; 0x05
    119e:	88 23       	and	r24, r24
    11a0:	c1 f0       	breq	.+48     	; 0x11d2 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    11a2:	89 81       	ldd	r24, Y+1	; 0x01
    11a4:	9a 81       	ldd	r25, Y+2	; 0x02
    11a6:	99 87       	std	Y+9, r25	; 0x09
    11a8:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    11aa:	1b 8a       	std	Y+19, r1	; 0x13
    11ac:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    11ae:	88 89       	ldd	r24, Y+16	; 0x10
    11b0:	88 23       	and	r24, r24
    11b2:	e9 f1       	breq	.+122    	; 0x122e <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    11b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    11b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    11b8:	20 81       	ld	r18, Z
    11ba:	31 81       	ldd	r19, Z+1	; 0x01
    11bc:	8e 85       	ldd	r24, Y+14	; 0x0e
    11be:	9f 85       	ldd	r25, Y+15	; 0x0f
    11c0:	80 95       	com	r24
    11c2:	90 95       	com	r25
    11c4:	82 23       	and	r24, r18
    11c6:	93 23       	and	r25, r19
    11c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    11ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    11cc:	91 83       	std	Z+1, r25	; 0x01
    11ce:	80 83       	st	Z, r24
    11d0:	2e c0       	rjmp	.+92     	; 0x122e <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    11d2:	8a 89       	ldd	r24, Y+18	; 0x12
    11d4:	9b 89       	ldd	r25, Y+19	; 0x13
    11d6:	00 97       	sbiw	r24, 0x00	; 0
    11d8:	39 f4       	brne	.+14     	; 0x11e8 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    11da:	89 81       	ldd	r24, Y+1	; 0x01
    11dc:	9a 81       	ldd	r25, Y+2	; 0x02
    11de:	99 87       	std	Y+9, r25	; 0x09
    11e0:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
    11e2:	81 e0       	ldi	r24, 0x01	; 1
    11e4:	8b 83       	std	Y+3, r24	; 0x03
    11e6:	23 c0       	rjmp	.+70     	; 0x122e <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    11e8:	88 89       	ldd	r24, Y+16	; 0x10
    11ea:	88 23       	and	r24, r24
    11ec:	29 f0       	breq	.+10     	; 0x11f8 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    11ee:	8e 81       	ldd	r24, Y+6	; 0x06
    11f0:	9f 81       	ldd	r25, Y+7	; 0x07
    11f2:	91 60       	ori	r25, 0x01	; 1
    11f4:	9f 83       	std	Y+7, r25	; 0x07
    11f6:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    11f8:	89 89       	ldd	r24, Y+17	; 0x11
    11fa:	88 23       	and	r24, r24
    11fc:	29 f0       	breq	.+10     	; 0x1208 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    11fe:	8e 81       	ldd	r24, Y+6	; 0x06
    1200:	9f 81       	ldd	r25, Y+7	; 0x07
    1202:	94 60       	ori	r25, 0x04	; 4
    1204:	9f 83       	std	Y+7, r25	; 0x07
    1206:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1208:	8a 85       	ldd	r24, Y+10	; 0x0a
    120a:	9b 85       	ldd	r25, Y+11	; 0x0b
    120c:	bc 01       	movw	r22, r24
    120e:	6e 5f       	subi	r22, 0xFE	; 254
    1210:	7f 4f       	sbci	r23, 0xFF	; 255
    1212:	2e 85       	ldd	r18, Y+14	; 0x0e
    1214:	3f 85       	ldd	r19, Y+15	; 0x0f
    1216:	8e 81       	ldd	r24, Y+6	; 0x06
    1218:	9f 81       	ldd	r25, Y+7	; 0x07
    121a:	28 2b       	or	r18, r24
    121c:	39 2b       	or	r19, r25
    121e:	4a 89       	ldd	r20, Y+18	; 0x12
    1220:	5b 89       	ldd	r21, Y+19	; 0x13
    1222:	cb 01       	movw	r24, r22
    1224:	b9 01       	movw	r22, r18
    1226:	0e 94 a5 1b 	call	0x374a	; 0x374a <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    122a:	19 86       	std	Y+9, r1	; 0x09
    122c:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    122e:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    1232:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    1234:	8a 89       	ldd	r24, Y+18	; 0x12
    1236:	9b 89       	ldd	r25, Y+19	; 0x13
    1238:	00 97       	sbiw	r24, 0x00	; 0
    123a:	09 f4       	brne	.+2      	; 0x123e <xEventGroupWaitBits+0xfa>
    123c:	3c c0       	rjmp	.+120    	; 0x12b6 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    123e:	8c 81       	ldd	r24, Y+4	; 0x04
    1240:	88 23       	and	r24, r24
    1242:	11 f4       	brne	.+4      	; 0x1248 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    1244:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1248:	0e 94 b6 1d 	call	0x3b6c	; 0x3b6c <uxTaskResetEventItemValue>
    124c:	99 87       	std	Y+9, r25	; 0x09
    124e:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1250:	88 85       	ldd	r24, Y+8	; 0x08
    1252:	99 85       	ldd	r25, Y+9	; 0x09
    1254:	80 70       	andi	r24, 0x00	; 0
    1256:	92 70       	andi	r25, 0x02	; 2
    1258:	00 97       	sbiw	r24, 0x00	; 0
    125a:	41 f5       	brne	.+80     	; 0x12ac <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    125c:	0f b6       	in	r0, 0x3f	; 63
    125e:	f8 94       	cli
    1260:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1262:	ea 85       	ldd	r30, Y+10	; 0x0a
    1264:	fb 85       	ldd	r31, Y+11	; 0x0b
    1266:	80 81       	ld	r24, Z
    1268:	91 81       	ldd	r25, Z+1	; 0x01
    126a:	99 87       	std	Y+9, r25	; 0x09
    126c:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    126e:	88 85       	ldd	r24, Y+8	; 0x08
    1270:	99 85       	ldd	r25, Y+9	; 0x09
    1272:	2e 85       	ldd	r18, Y+14	; 0x0e
    1274:	3f 85       	ldd	r19, Y+15	; 0x0f
    1276:	b9 01       	movw	r22, r18
    1278:	49 89       	ldd	r20, Y+17	; 0x11
    127a:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <prvTestWaitCondition>
    127e:	88 23       	and	r24, r24
    1280:	89 f0       	breq	.+34     	; 0x12a4 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    1282:	88 89       	ldd	r24, Y+16	; 0x10
    1284:	88 23       	and	r24, r24
    1286:	71 f0       	breq	.+28     	; 0x12a4 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1288:	ea 85       	ldd	r30, Y+10	; 0x0a
    128a:	fb 85       	ldd	r31, Y+11	; 0x0b
    128c:	20 81       	ld	r18, Z
    128e:	31 81       	ldd	r19, Z+1	; 0x01
    1290:	8e 85       	ldd	r24, Y+14	; 0x0e
    1292:	9f 85       	ldd	r25, Y+15	; 0x0f
    1294:	80 95       	com	r24
    1296:	90 95       	com	r25
    1298:	82 23       	and	r24, r18
    129a:	93 23       	and	r25, r19
    129c:	ea 85       	ldd	r30, Y+10	; 0x0a
    129e:	fb 85       	ldd	r31, Y+11	; 0x0b
    12a0:	91 83       	std	Z+1, r25	; 0x01
    12a2:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    12a4:	81 e0       	ldi	r24, 0x01	; 1
    12a6:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    12a8:	0f 90       	pop	r0
    12aa:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    12ac:	88 85       	ldd	r24, Y+8	; 0x08
    12ae:	99 85       	ldd	r25, Y+9	; 0x09
    12b0:	90 70       	andi	r25, 0x00	; 0
    12b2:	99 87       	std	Y+9, r25	; 0x09
    12b4:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    12b6:	88 85       	ldd	r24, Y+8	; 0x08
    12b8:	99 85       	ldd	r25, Y+9	; 0x09
}
    12ba:	63 96       	adiw	r28, 0x13	; 19
    12bc:	0f b6       	in	r0, 0x3f	; 63
    12be:	f8 94       	cli
    12c0:	de bf       	out	0x3e, r29	; 62
    12c2:	0f be       	out	0x3f, r0	; 63
    12c4:	cd bf       	out	0x3d, r28	; 61
    12c6:	cf 91       	pop	r28
    12c8:	df 91       	pop	r29
    12ca:	1f 91       	pop	r17
    12cc:	0f 91       	pop	r16
    12ce:	08 95       	ret

000012d0 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    12d0:	df 93       	push	r29
    12d2:	cf 93       	push	r28
    12d4:	cd b7       	in	r28, 0x3d	; 61
    12d6:	de b7       	in	r29, 0x3e	; 62
    12d8:	28 97       	sbiw	r28, 0x08	; 8
    12da:	0f b6       	in	r0, 0x3f	; 63
    12dc:	f8 94       	cli
    12de:	de bf       	out	0x3e, r29	; 62
    12e0:	0f be       	out	0x3f, r0	; 63
    12e2:	cd bf       	out	0x3d, r28	; 61
    12e4:	9e 83       	std	Y+6, r25	; 0x06
    12e6:	8d 83       	std	Y+5, r24	; 0x05
    12e8:	78 87       	std	Y+8, r23	; 0x08
    12ea:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    12ec:	8d 81       	ldd	r24, Y+5	; 0x05
    12ee:	9e 81       	ldd	r25, Y+6	; 0x06
    12f0:	9c 83       	std	Y+4, r25	; 0x04
    12f2:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    12f4:	0f b6       	in	r0, 0x3f	; 63
    12f6:	f8 94       	cli
    12f8:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    12fa:	eb 81       	ldd	r30, Y+3	; 0x03
    12fc:	fc 81       	ldd	r31, Y+4	; 0x04
    12fe:	80 81       	ld	r24, Z
    1300:	91 81       	ldd	r25, Z+1	; 0x01
    1302:	9a 83       	std	Y+2, r25	; 0x02
    1304:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1306:	eb 81       	ldd	r30, Y+3	; 0x03
    1308:	fc 81       	ldd	r31, Y+4	; 0x04
    130a:	20 81       	ld	r18, Z
    130c:	31 81       	ldd	r19, Z+1	; 0x01
    130e:	8f 81       	ldd	r24, Y+7	; 0x07
    1310:	98 85       	ldd	r25, Y+8	; 0x08
    1312:	80 95       	com	r24
    1314:	90 95       	com	r25
    1316:	82 23       	and	r24, r18
    1318:	93 23       	and	r25, r19
    131a:	eb 81       	ldd	r30, Y+3	; 0x03
    131c:	fc 81       	ldd	r31, Y+4	; 0x04
    131e:	91 83       	std	Z+1, r25	; 0x01
    1320:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    1322:	0f 90       	pop	r0
    1324:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1326:	89 81       	ldd	r24, Y+1	; 0x01
    1328:	9a 81       	ldd	r25, Y+2	; 0x02
}
    132a:	28 96       	adiw	r28, 0x08	; 8
    132c:	0f b6       	in	r0, 0x3f	; 63
    132e:	f8 94       	cli
    1330:	de bf       	out	0x3e, r29	; 62
    1332:	0f be       	out	0x3f, r0	; 63
    1334:	cd bf       	out	0x3d, r28	; 61
    1336:	cf 91       	pop	r28
    1338:	df 91       	pop	r29
    133a:	08 95       	ret

0000133c <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    133c:	df 93       	push	r29
    133e:	cf 93       	push	r28
    1340:	cd b7       	in	r28, 0x3d	; 61
    1342:	de b7       	in	r29, 0x3e	; 62
    1344:	27 97       	sbiw	r28, 0x07	; 7
    1346:	0f b6       	in	r0, 0x3f	; 63
    1348:	f8 94       	cli
    134a:	de bf       	out	0x3e, r29	; 62
    134c:	0f be       	out	0x3f, r0	; 63
    134e:	cd bf       	out	0x3d, r28	; 61
    1350:	9f 83       	std	Y+7, r25	; 0x07
    1352:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    1354:	8e 81       	ldd	r24, Y+6	; 0x06
    1356:	9f 81       	ldd	r25, Y+7	; 0x07
    1358:	9c 83       	std	Y+4, r25	; 0x04
    135a:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    135c:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    135e:	eb 81       	ldd	r30, Y+3	; 0x03
    1360:	fc 81       	ldd	r31, Y+4	; 0x04
    1362:	80 81       	ld	r24, Z
    1364:	91 81       	ldd	r25, Z+1	; 0x01
    1366:	9a 83       	std	Y+2, r25	; 0x02
    1368:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    136a:	89 81       	ldd	r24, Y+1	; 0x01
    136c:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    136e:	27 96       	adiw	r28, 0x07	; 7
    1370:	0f b6       	in	r0, 0x3f	; 63
    1372:	f8 94       	cli
    1374:	de bf       	out	0x3e, r29	; 62
    1376:	0f be       	out	0x3f, r0	; 63
    1378:	cd bf       	out	0x3d, r28	; 61
    137a:	cf 91       	pop	r28
    137c:	df 91       	pop	r29
    137e:	08 95       	ret

00001380 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    1380:	df 93       	push	r29
    1382:	cf 93       	push	r28
    1384:	cd b7       	in	r28, 0x3d	; 61
    1386:	de b7       	in	r29, 0x3e	; 62
    1388:	65 97       	sbiw	r28, 0x15	; 21
    138a:	0f b6       	in	r0, 0x3f	; 63
    138c:	f8 94       	cli
    138e:	de bf       	out	0x3e, r29	; 62
    1390:	0f be       	out	0x3f, r0	; 63
    1392:	cd bf       	out	0x3d, r28	; 61
    1394:	9b 8b       	std	Y+19, r25	; 0x13
    1396:	8a 8b       	std	Y+18, r24	; 0x12
    1398:	7d 8b       	std	Y+21, r23	; 0x15
    139a:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    139c:	19 86       	std	Y+9, r1	; 0x09
    139e:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    13a0:	8a 89       	ldd	r24, Y+18	; 0x12
    13a2:	9b 89       	ldd	r25, Y+19	; 0x13
    13a4:	9b 83       	std	Y+3, r25	; 0x03
    13a6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    13a8:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    13aa:	8a 81       	ldd	r24, Y+2	; 0x02
    13ac:	9b 81       	ldd	r25, Y+3	; 0x03
    13ae:	02 96       	adiw	r24, 0x02	; 2
    13b0:	9b 87       	std	Y+11, r25	; 0x0b
    13b2:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    13b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    13b8:	03 96       	adiw	r24, 0x03	; 3
    13ba:	9d 87       	std	Y+13, r25	; 0x0d
    13bc:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    13be:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    13c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    13c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    13c6:	85 81       	ldd	r24, Z+5	; 0x05
    13c8:	96 81       	ldd	r25, Z+6	; 0x06
    13ca:	99 8b       	std	Y+17, r25	; 0x11
    13cc:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    13ce:	ea 81       	ldd	r30, Y+2	; 0x02
    13d0:	fb 81       	ldd	r31, Y+3	; 0x03
    13d2:	20 81       	ld	r18, Z
    13d4:	31 81       	ldd	r19, Z+1	; 0x01
    13d6:	8c 89       	ldd	r24, Y+20	; 0x14
    13d8:	9d 89       	ldd	r25, Y+21	; 0x15
    13da:	82 2b       	or	r24, r18
    13dc:	93 2b       	or	r25, r19
    13de:	ea 81       	ldd	r30, Y+2	; 0x02
    13e0:	fb 81       	ldd	r31, Y+3	; 0x03
    13e2:	91 83       	std	Z+1, r25	; 0x01
    13e4:	80 83       	st	Z, r24
    13e6:	59 c0       	rjmp	.+178    	; 0x149a <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    13e8:	e8 89       	ldd	r30, Y+16	; 0x10
    13ea:	f9 89       	ldd	r31, Y+17	; 0x11
    13ec:	82 81       	ldd	r24, Z+2	; 0x02
    13ee:	93 81       	ldd	r25, Z+3	; 0x03
    13f0:	9f 87       	std	Y+15, r25	; 0x0f
    13f2:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    13f4:	e8 89       	ldd	r30, Y+16	; 0x10
    13f6:	f9 89       	ldd	r31, Y+17	; 0x11
    13f8:	80 81       	ld	r24, Z
    13fa:	91 81       	ldd	r25, Z+1	; 0x01
    13fc:	9f 83       	std	Y+7, r25	; 0x07
    13fe:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    1400:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1402:	8e 81       	ldd	r24, Y+6	; 0x06
    1404:	9f 81       	ldd	r25, Y+7	; 0x07
    1406:	80 70       	andi	r24, 0x00	; 0
    1408:	9d 83       	std	Y+5, r25	; 0x05
    140a:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    140c:	8e 81       	ldd	r24, Y+6	; 0x06
    140e:	9f 81       	ldd	r25, Y+7	; 0x07
    1410:	90 70       	andi	r25, 0x00	; 0
    1412:	9f 83       	std	Y+7, r25	; 0x07
    1414:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1416:	8c 81       	ldd	r24, Y+4	; 0x04
    1418:	9d 81       	ldd	r25, Y+5	; 0x05
    141a:	80 70       	andi	r24, 0x00	; 0
    141c:	94 70       	andi	r25, 0x04	; 4
    141e:	00 97       	sbiw	r24, 0x00	; 0
    1420:	69 f4       	brne	.+26     	; 0x143c <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1422:	ea 81       	ldd	r30, Y+2	; 0x02
    1424:	fb 81       	ldd	r31, Y+3	; 0x03
    1426:	20 81       	ld	r18, Z
    1428:	31 81       	ldd	r19, Z+1	; 0x01
    142a:	8e 81       	ldd	r24, Y+6	; 0x06
    142c:	9f 81       	ldd	r25, Y+7	; 0x07
    142e:	82 23       	and	r24, r18
    1430:	93 23       	and	r25, r19
    1432:	00 97       	sbiw	r24, 0x00	; 0
    1434:	91 f0       	breq	.+36     	; 0x145a <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    1436:	81 e0       	ldi	r24, 0x01	; 1
    1438:	89 83       	std	Y+1, r24	; 0x01
    143a:	0f c0       	rjmp	.+30     	; 0x145a <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    143c:	ea 81       	ldd	r30, Y+2	; 0x02
    143e:	fb 81       	ldd	r31, Y+3	; 0x03
    1440:	20 81       	ld	r18, Z
    1442:	31 81       	ldd	r19, Z+1	; 0x01
    1444:	8e 81       	ldd	r24, Y+6	; 0x06
    1446:	9f 81       	ldd	r25, Y+7	; 0x07
    1448:	28 23       	and	r18, r24
    144a:	39 23       	and	r19, r25
    144c:	8e 81       	ldd	r24, Y+6	; 0x06
    144e:	9f 81       	ldd	r25, Y+7	; 0x07
    1450:	28 17       	cp	r18, r24
    1452:	39 07       	cpc	r19, r25
    1454:	11 f4       	brne	.+4      	; 0x145a <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    1456:	81 e0       	ldi	r24, 0x01	; 1
    1458:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    145a:	89 81       	ldd	r24, Y+1	; 0x01
    145c:	88 23       	and	r24, r24
    145e:	c9 f0       	breq	.+50     	; 0x1492 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1460:	8c 81       	ldd	r24, Y+4	; 0x04
    1462:	9d 81       	ldd	r25, Y+5	; 0x05
    1464:	80 70       	andi	r24, 0x00	; 0
    1466:	91 70       	andi	r25, 0x01	; 1
    1468:	00 97       	sbiw	r24, 0x00	; 0
    146a:	41 f0       	breq	.+16     	; 0x147c <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    146c:	88 85       	ldd	r24, Y+8	; 0x08
    146e:	99 85       	ldd	r25, Y+9	; 0x09
    1470:	2e 81       	ldd	r18, Y+6	; 0x06
    1472:	3f 81       	ldd	r19, Y+7	; 0x07
    1474:	82 2b       	or	r24, r18
    1476:	93 2b       	or	r25, r19
    1478:	99 87       	std	Y+9, r25	; 0x09
    147a:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    147c:	ea 81       	ldd	r30, Y+2	; 0x02
    147e:	fb 81       	ldd	r31, Y+3	; 0x03
    1480:	80 81       	ld	r24, Z
    1482:	91 81       	ldd	r25, Z+1	; 0x01
    1484:	9c 01       	movw	r18, r24
    1486:	32 60       	ori	r19, 0x02	; 2
    1488:	88 89       	ldd	r24, Y+16	; 0x10
    148a:	99 89       	ldd	r25, Y+17	; 0x11
    148c:	b9 01       	movw	r22, r18
    148e:	0e 94 40 1c 	call	0x3880	; 0x3880 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    1492:	8e 85       	ldd	r24, Y+14	; 0x0e
    1494:	9f 85       	ldd	r25, Y+15	; 0x0f
    1496:	99 8b       	std	Y+17, r25	; 0x11
    1498:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    149a:	28 89       	ldd	r18, Y+16	; 0x10
    149c:	39 89       	ldd	r19, Y+17	; 0x11
    149e:	8c 85       	ldd	r24, Y+12	; 0x0c
    14a0:	9d 85       	ldd	r25, Y+13	; 0x0d
    14a2:	28 17       	cp	r18, r24
    14a4:	39 07       	cpc	r19, r25
    14a6:	09 f0       	breq	.+2      	; 0x14aa <xEventGroupSetBits+0x12a>
    14a8:	9f cf       	rjmp	.-194    	; 0x13e8 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    14aa:	ea 81       	ldd	r30, Y+2	; 0x02
    14ac:	fb 81       	ldd	r31, Y+3	; 0x03
    14ae:	20 81       	ld	r18, Z
    14b0:	31 81       	ldd	r19, Z+1	; 0x01
    14b2:	88 85       	ldd	r24, Y+8	; 0x08
    14b4:	99 85       	ldd	r25, Y+9	; 0x09
    14b6:	80 95       	com	r24
    14b8:	90 95       	com	r25
    14ba:	82 23       	and	r24, r18
    14bc:	93 23       	and	r25, r19
    14be:	ea 81       	ldd	r30, Y+2	; 0x02
    14c0:	fb 81       	ldd	r31, Y+3	; 0x03
    14c2:	91 83       	std	Z+1, r25	; 0x01
    14c4:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    14c6:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    14ca:	ea 81       	ldd	r30, Y+2	; 0x02
    14cc:	fb 81       	ldd	r31, Y+3	; 0x03
    14ce:	80 81       	ld	r24, Z
    14d0:	91 81       	ldd	r25, Z+1	; 0x01
}
    14d2:	65 96       	adiw	r28, 0x15	; 21
    14d4:	0f b6       	in	r0, 0x3f	; 63
    14d6:	f8 94       	cli
    14d8:	de bf       	out	0x3e, r29	; 62
    14da:	0f be       	out	0x3f, r0	; 63
    14dc:	cd bf       	out	0x3d, r28	; 61
    14de:	cf 91       	pop	r28
    14e0:	df 91       	pop	r29
    14e2:	08 95       	ret

000014e4 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    14e4:	df 93       	push	r29
    14e6:	cf 93       	push	r28
    14e8:	00 d0       	rcall	.+0      	; 0x14ea <vEventGroupDelete+0x6>
    14ea:	00 d0       	rcall	.+0      	; 0x14ec <vEventGroupDelete+0x8>
    14ec:	00 d0       	rcall	.+0      	; 0x14ee <vEventGroupDelete+0xa>
    14ee:	cd b7       	in	r28, 0x3d	; 61
    14f0:	de b7       	in	r29, 0x3e	; 62
    14f2:	9e 83       	std	Y+6, r25	; 0x06
    14f4:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    14f6:	8d 81       	ldd	r24, Y+5	; 0x05
    14f8:	9e 81       	ldd	r25, Y+6	; 0x06
    14fa:	9c 83       	std	Y+4, r25	; 0x04
    14fc:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    14fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1500:	9c 81       	ldd	r25, Y+4	; 0x04
    1502:	02 96       	adiw	r24, 0x02	; 2
    1504:	9a 83       	std	Y+2, r25	; 0x02
    1506:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    1508:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
    150c:	08 c0       	rjmp	.+16     	; 0x151e <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    150e:	e9 81       	ldd	r30, Y+1	; 0x01
    1510:	fa 81       	ldd	r31, Y+2	; 0x02
    1512:	85 81       	ldd	r24, Z+5	; 0x05
    1514:	96 81       	ldd	r25, Z+6	; 0x06
    1516:	60 e0       	ldi	r22, 0x00	; 0
    1518:	72 e0       	ldi	r23, 0x02	; 2
    151a:	0e 94 40 1c 	call	0x3880	; 0x3880 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    151e:	e9 81       	ldd	r30, Y+1	; 0x01
    1520:	fa 81       	ldd	r31, Y+2	; 0x02
    1522:	80 81       	ld	r24, Z
    1524:	88 23       	and	r24, r24
    1526:	99 f7       	brne	.-26     	; 0x150e <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    1528:	8b 81       	ldd	r24, Y+3	; 0x03
    152a:	9c 81       	ldd	r25, Y+4	; 0x04
    152c:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    1530:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
}
    1534:	26 96       	adiw	r28, 0x06	; 6
    1536:	0f b6       	in	r0, 0x3f	; 63
    1538:	f8 94       	cli
    153a:	de bf       	out	0x3e, r29	; 62
    153c:	0f be       	out	0x3f, r0	; 63
    153e:	cd bf       	out	0x3d, r28	; 61
    1540:	cf 91       	pop	r28
    1542:	df 91       	pop	r29
    1544:	08 95       	ret

00001546 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    1546:	df 93       	push	r29
    1548:	cf 93       	push	r28
    154a:	00 d0       	rcall	.+0      	; 0x154c <vEventGroupSetBitsCallback+0x6>
    154c:	00 d0       	rcall	.+0      	; 0x154e <vEventGroupSetBitsCallback+0x8>
    154e:	00 d0       	rcall	.+0      	; 0x1550 <vEventGroupSetBitsCallback+0xa>
    1550:	cd b7       	in	r28, 0x3d	; 61
    1552:	de b7       	in	r29, 0x3e	; 62
    1554:	9a 83       	std	Y+2, r25	; 0x02
    1556:	89 83       	std	Y+1, r24	; 0x01
    1558:	4b 83       	std	Y+3, r20	; 0x03
    155a:	5c 83       	std	Y+4, r21	; 0x04
    155c:	6d 83       	std	Y+5, r22	; 0x05
    155e:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1560:	89 81       	ldd	r24, Y+1	; 0x01
    1562:	9a 81       	ldd	r25, Y+2	; 0x02
    1564:	2b 81       	ldd	r18, Y+3	; 0x03
    1566:	3c 81       	ldd	r19, Y+4	; 0x04
    1568:	b9 01       	movw	r22, r18
    156a:	0e 94 c0 09 	call	0x1380	; 0x1380 <xEventGroupSetBits>
}
    156e:	26 96       	adiw	r28, 0x06	; 6
    1570:	0f b6       	in	r0, 0x3f	; 63
    1572:	f8 94       	cli
    1574:	de bf       	out	0x3e, r29	; 62
    1576:	0f be       	out	0x3f, r0	; 63
    1578:	cd bf       	out	0x3d, r28	; 61
    157a:	cf 91       	pop	r28
    157c:	df 91       	pop	r29
    157e:	08 95       	ret

00001580 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    1580:	df 93       	push	r29
    1582:	cf 93       	push	r28
    1584:	00 d0       	rcall	.+0      	; 0x1586 <vEventGroupClearBitsCallback+0x6>
    1586:	00 d0       	rcall	.+0      	; 0x1588 <vEventGroupClearBitsCallback+0x8>
    1588:	00 d0       	rcall	.+0      	; 0x158a <vEventGroupClearBitsCallback+0xa>
    158a:	cd b7       	in	r28, 0x3d	; 61
    158c:	de b7       	in	r29, 0x3e	; 62
    158e:	9a 83       	std	Y+2, r25	; 0x02
    1590:	89 83       	std	Y+1, r24	; 0x01
    1592:	4b 83       	std	Y+3, r20	; 0x03
    1594:	5c 83       	std	Y+4, r21	; 0x04
    1596:	6d 83       	std	Y+5, r22	; 0x05
    1598:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    159a:	89 81       	ldd	r24, Y+1	; 0x01
    159c:	9a 81       	ldd	r25, Y+2	; 0x02
    159e:	2b 81       	ldd	r18, Y+3	; 0x03
    15a0:	3c 81       	ldd	r19, Y+4	; 0x04
    15a2:	b9 01       	movw	r22, r18
    15a4:	0e 94 68 09 	call	0x12d0	; 0x12d0 <xEventGroupClearBits>
}
    15a8:	26 96       	adiw	r28, 0x06	; 6
    15aa:	0f b6       	in	r0, 0x3f	; 63
    15ac:	f8 94       	cli
    15ae:	de bf       	out	0x3e, r29	; 62
    15b0:	0f be       	out	0x3f, r0	; 63
    15b2:	cd bf       	out	0x3d, r28	; 61
    15b4:	cf 91       	pop	r28
    15b6:	df 91       	pop	r29
    15b8:	08 95       	ret

000015ba <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    15ba:	df 93       	push	r29
    15bc:	cf 93       	push	r28
    15be:	00 d0       	rcall	.+0      	; 0x15c0 <prvTestWaitCondition+0x6>
    15c0:	00 d0       	rcall	.+0      	; 0x15c2 <prvTestWaitCondition+0x8>
    15c2:	00 d0       	rcall	.+0      	; 0x15c4 <prvTestWaitCondition+0xa>
    15c4:	cd b7       	in	r28, 0x3d	; 61
    15c6:	de b7       	in	r29, 0x3e	; 62
    15c8:	9b 83       	std	Y+3, r25	; 0x03
    15ca:	8a 83       	std	Y+2, r24	; 0x02
    15cc:	7d 83       	std	Y+5, r23	; 0x05
    15ce:	6c 83       	std	Y+4, r22	; 0x04
    15d0:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    15d2:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    15d4:	8e 81       	ldd	r24, Y+6	; 0x06
    15d6:	88 23       	and	r24, r24
    15d8:	59 f4       	brne	.+22     	; 0x15f0 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    15da:	8a 81       	ldd	r24, Y+2	; 0x02
    15dc:	9b 81       	ldd	r25, Y+3	; 0x03
    15de:	2c 81       	ldd	r18, Y+4	; 0x04
    15e0:	3d 81       	ldd	r19, Y+5	; 0x05
    15e2:	82 23       	and	r24, r18
    15e4:	93 23       	and	r25, r19
    15e6:	00 97       	sbiw	r24, 0x00	; 0
    15e8:	81 f0       	breq	.+32     	; 0x160a <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	89 83       	std	Y+1, r24	; 0x01
    15ee:	0d c0       	rjmp	.+26     	; 0x160a <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    15f0:	2a 81       	ldd	r18, Y+2	; 0x02
    15f2:	3b 81       	ldd	r19, Y+3	; 0x03
    15f4:	8c 81       	ldd	r24, Y+4	; 0x04
    15f6:	9d 81       	ldd	r25, Y+5	; 0x05
    15f8:	28 23       	and	r18, r24
    15fa:	39 23       	and	r19, r25
    15fc:	8c 81       	ldd	r24, Y+4	; 0x04
    15fe:	9d 81       	ldd	r25, Y+5	; 0x05
    1600:	28 17       	cp	r18, r24
    1602:	39 07       	cpc	r19, r25
    1604:	11 f4       	brne	.+4      	; 0x160a <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1606:	81 e0       	ldi	r24, 0x01	; 1
    1608:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    160a:	89 81       	ldd	r24, Y+1	; 0x01
}
    160c:	26 96       	adiw	r28, 0x06	; 6
    160e:	0f b6       	in	r0, 0x3f	; 63
    1610:	f8 94       	cli
    1612:	de bf       	out	0x3e, r29	; 62
    1614:	0f be       	out	0x3f, r0	; 63
    1616:	cd bf       	out	0x3d, r28	; 61
    1618:	cf 91       	pop	r28
    161a:	df 91       	pop	r29
    161c:	08 95       	ret

0000161e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    161e:	df 93       	push	r29
    1620:	cf 93       	push	r28
    1622:	00 d0       	rcall	.+0      	; 0x1624 <pvPortMalloc+0x6>
    1624:	00 d0       	rcall	.+0      	; 0x1626 <pvPortMalloc+0x8>
    1626:	cd b7       	in	r28, 0x3d	; 61
    1628:	de b7       	in	r29, 0x3e	; 62
    162a:	9c 83       	std	Y+4, r25	; 0x04
    162c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    162e:	1a 82       	std	Y+2, r1	; 0x02
    1630:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1632:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1636:	80 91 9a 00 	lds	r24, 0x009A
    163a:	90 91 9b 00 	lds	r25, 0x009B
    163e:	00 97       	sbiw	r24, 0x00	; 0
    1640:	31 f4       	brne	.+12     	; 0x164e <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1642:	8d e9       	ldi	r24, 0x9D	; 157
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	90 93 9b 00 	sts	0x009B, r25
    164a:	80 93 9a 00 	sts	0x009A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    164e:	80 91 98 00 	lds	r24, 0x0098
    1652:	90 91 99 00 	lds	r25, 0x0099
    1656:	2b 81       	ldd	r18, Y+3	; 0x03
    1658:	3c 81       	ldd	r19, Y+4	; 0x04
    165a:	82 0f       	add	r24, r18
    165c:	93 1f       	adc	r25, r19
    165e:	22 e0       	ldi	r18, 0x02	; 2
    1660:	87 35       	cpi	r24, 0x57	; 87
    1662:	92 07       	cpc	r25, r18
    1664:	38 f5       	brcc	.+78     	; 0x16b4 <pvPortMalloc+0x96>
    1666:	20 91 98 00 	lds	r18, 0x0098
    166a:	30 91 99 00 	lds	r19, 0x0099
    166e:	8b 81       	ldd	r24, Y+3	; 0x03
    1670:	9c 81       	ldd	r25, Y+4	; 0x04
    1672:	28 0f       	add	r18, r24
    1674:	39 1f       	adc	r19, r25
    1676:	80 91 98 00 	lds	r24, 0x0098
    167a:	90 91 99 00 	lds	r25, 0x0099
    167e:	82 17       	cp	r24, r18
    1680:	93 07       	cpc	r25, r19
    1682:	c0 f4       	brcc	.+48     	; 0x16b4 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1684:	20 91 9a 00 	lds	r18, 0x009A
    1688:	30 91 9b 00 	lds	r19, 0x009B
    168c:	80 91 98 00 	lds	r24, 0x0098
    1690:	90 91 99 00 	lds	r25, 0x0099
    1694:	82 0f       	add	r24, r18
    1696:	93 1f       	adc	r25, r19
    1698:	9a 83       	std	Y+2, r25	; 0x02
    169a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    169c:	20 91 98 00 	lds	r18, 0x0098
    16a0:	30 91 99 00 	lds	r19, 0x0099
    16a4:	8b 81       	ldd	r24, Y+3	; 0x03
    16a6:	9c 81       	ldd	r25, Y+4	; 0x04
    16a8:	82 0f       	add	r24, r18
    16aa:	93 1f       	adc	r25, r19
    16ac:	90 93 99 00 	sts	0x0099, r25
    16b0:	80 93 98 00 	sts	0x0098, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    16b4:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    16b8:	89 81       	ldd	r24, Y+1	; 0x01
    16ba:	9a 81       	ldd	r25, Y+2	; 0x02
}
    16bc:	0f 90       	pop	r0
    16be:	0f 90       	pop	r0
    16c0:	0f 90       	pop	r0
    16c2:	0f 90       	pop	r0
    16c4:	cf 91       	pop	r28
    16c6:	df 91       	pop	r29
    16c8:	08 95       	ret

000016ca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    16ca:	df 93       	push	r29
    16cc:	cf 93       	push	r28
    16ce:	00 d0       	rcall	.+0      	; 0x16d0 <vPortFree+0x6>
    16d0:	cd b7       	in	r28, 0x3d	; 61
    16d2:	de b7       	in	r29, 0x3e	; 62
    16d4:	9a 83       	std	Y+2, r25	; 0x02
    16d6:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    16d8:	0f 90       	pop	r0
    16da:	0f 90       	pop	r0
    16dc:	cf 91       	pop	r28
    16de:	df 91       	pop	r29
    16e0:	08 95       	ret

000016e2 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    16e2:	df 93       	push	r29
    16e4:	cf 93       	push	r28
    16e6:	cd b7       	in	r28, 0x3d	; 61
    16e8:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    16ea:	10 92 99 00 	sts	0x0099, r1
    16ee:	10 92 98 00 	sts	0x0098, r1
}
    16f2:	cf 91       	pop	r28
    16f4:	df 91       	pop	r29
    16f6:	08 95       	ret

000016f8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    16f8:	df 93       	push	r29
    16fa:	cf 93       	push	r28
    16fc:	cd b7       	in	r28, 0x3d	; 61
    16fe:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1700:	20 91 98 00 	lds	r18, 0x0098
    1704:	30 91 99 00 	lds	r19, 0x0099
    1708:	87 e5       	ldi	r24, 0x57	; 87
    170a:	92 e0       	ldi	r25, 0x02	; 2
    170c:	82 1b       	sub	r24, r18
    170e:	93 0b       	sbc	r25, r19
}
    1710:	cf 91       	pop	r28
    1712:	df 91       	pop	r29
    1714:	08 95       	ret

00001716 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1716:	df 93       	push	r29
    1718:	cf 93       	push	r28
    171a:	00 d0       	rcall	.+0      	; 0x171c <vListInitialise+0x6>
    171c:	cd b7       	in	r28, 0x3d	; 61
    171e:	de b7       	in	r29, 0x3e	; 62
    1720:	9a 83       	std	Y+2, r25	; 0x02
    1722:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1724:	89 81       	ldd	r24, Y+1	; 0x01
    1726:	9a 81       	ldd	r25, Y+2	; 0x02
    1728:	03 96       	adiw	r24, 0x03	; 3
    172a:	e9 81       	ldd	r30, Y+1	; 0x01
    172c:	fa 81       	ldd	r31, Y+2	; 0x02
    172e:	92 83       	std	Z+2, r25	; 0x02
    1730:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1732:	e9 81       	ldd	r30, Y+1	; 0x01
    1734:	fa 81       	ldd	r31, Y+2	; 0x02
    1736:	8f ef       	ldi	r24, 0xFF	; 255
    1738:	9f ef       	ldi	r25, 0xFF	; 255
    173a:	94 83       	std	Z+4, r25	; 0x04
    173c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    173e:	89 81       	ldd	r24, Y+1	; 0x01
    1740:	9a 81       	ldd	r25, Y+2	; 0x02
    1742:	03 96       	adiw	r24, 0x03	; 3
    1744:	e9 81       	ldd	r30, Y+1	; 0x01
    1746:	fa 81       	ldd	r31, Y+2	; 0x02
    1748:	96 83       	std	Z+6, r25	; 0x06
    174a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    174c:	89 81       	ldd	r24, Y+1	; 0x01
    174e:	9a 81       	ldd	r25, Y+2	; 0x02
    1750:	03 96       	adiw	r24, 0x03	; 3
    1752:	e9 81       	ldd	r30, Y+1	; 0x01
    1754:	fa 81       	ldd	r31, Y+2	; 0x02
    1756:	90 87       	std	Z+8, r25	; 0x08
    1758:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    175a:	e9 81       	ldd	r30, Y+1	; 0x01
    175c:	fa 81       	ldd	r31, Y+2	; 0x02
    175e:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1760:	0f 90       	pop	r0
    1762:	0f 90       	pop	r0
    1764:	cf 91       	pop	r28
    1766:	df 91       	pop	r29
    1768:	08 95       	ret

0000176a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    176a:	df 93       	push	r29
    176c:	cf 93       	push	r28
    176e:	00 d0       	rcall	.+0      	; 0x1770 <vListInitialiseItem+0x6>
    1770:	cd b7       	in	r28, 0x3d	; 61
    1772:	de b7       	in	r29, 0x3e	; 62
    1774:	9a 83       	std	Y+2, r25	; 0x02
    1776:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1778:	e9 81       	ldd	r30, Y+1	; 0x01
    177a:	fa 81       	ldd	r31, Y+2	; 0x02
    177c:	11 86       	std	Z+9, r1	; 0x09
    177e:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1780:	0f 90       	pop	r0
    1782:	0f 90       	pop	r0
    1784:	cf 91       	pop	r28
    1786:	df 91       	pop	r29
    1788:	08 95       	ret

0000178a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    178a:	df 93       	push	r29
    178c:	cf 93       	push	r28
    178e:	00 d0       	rcall	.+0      	; 0x1790 <vListInsertEnd+0x6>
    1790:	00 d0       	rcall	.+0      	; 0x1792 <vListInsertEnd+0x8>
    1792:	00 d0       	rcall	.+0      	; 0x1794 <vListInsertEnd+0xa>
    1794:	cd b7       	in	r28, 0x3d	; 61
    1796:	de b7       	in	r29, 0x3e	; 62
    1798:	9c 83       	std	Y+4, r25	; 0x04
    179a:	8b 83       	std	Y+3, r24	; 0x03
    179c:	7e 83       	std	Y+6, r23	; 0x06
    179e:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    17a0:	eb 81       	ldd	r30, Y+3	; 0x03
    17a2:	fc 81       	ldd	r31, Y+4	; 0x04
    17a4:	81 81       	ldd	r24, Z+1	; 0x01
    17a6:	92 81       	ldd	r25, Z+2	; 0x02
    17a8:	9a 83       	std	Y+2, r25	; 0x02
    17aa:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    17ac:	ed 81       	ldd	r30, Y+5	; 0x05
    17ae:	fe 81       	ldd	r31, Y+6	; 0x06
    17b0:	89 81       	ldd	r24, Y+1	; 0x01
    17b2:	9a 81       	ldd	r25, Y+2	; 0x02
    17b4:	93 83       	std	Z+3, r25	; 0x03
    17b6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    17b8:	e9 81       	ldd	r30, Y+1	; 0x01
    17ba:	fa 81       	ldd	r31, Y+2	; 0x02
    17bc:	84 81       	ldd	r24, Z+4	; 0x04
    17be:	95 81       	ldd	r25, Z+5	; 0x05
    17c0:	ed 81       	ldd	r30, Y+5	; 0x05
    17c2:	fe 81       	ldd	r31, Y+6	; 0x06
    17c4:	95 83       	std	Z+5, r25	; 0x05
    17c6:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    17c8:	e9 81       	ldd	r30, Y+1	; 0x01
    17ca:	fa 81       	ldd	r31, Y+2	; 0x02
    17cc:	04 80       	ldd	r0, Z+4	; 0x04
    17ce:	f5 81       	ldd	r31, Z+5	; 0x05
    17d0:	e0 2d       	mov	r30, r0
    17d2:	8d 81       	ldd	r24, Y+5	; 0x05
    17d4:	9e 81       	ldd	r25, Y+6	; 0x06
    17d6:	93 83       	std	Z+3, r25	; 0x03
    17d8:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    17da:	e9 81       	ldd	r30, Y+1	; 0x01
    17dc:	fa 81       	ldd	r31, Y+2	; 0x02
    17de:	8d 81       	ldd	r24, Y+5	; 0x05
    17e0:	9e 81       	ldd	r25, Y+6	; 0x06
    17e2:	95 83       	std	Z+5, r25	; 0x05
    17e4:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    17e6:	ed 81       	ldd	r30, Y+5	; 0x05
    17e8:	fe 81       	ldd	r31, Y+6	; 0x06
    17ea:	8b 81       	ldd	r24, Y+3	; 0x03
    17ec:	9c 81       	ldd	r25, Y+4	; 0x04
    17ee:	91 87       	std	Z+9, r25	; 0x09
    17f0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    17f2:	eb 81       	ldd	r30, Y+3	; 0x03
    17f4:	fc 81       	ldd	r31, Y+4	; 0x04
    17f6:	80 81       	ld	r24, Z
    17f8:	8f 5f       	subi	r24, 0xFF	; 255
    17fa:	eb 81       	ldd	r30, Y+3	; 0x03
    17fc:	fc 81       	ldd	r31, Y+4	; 0x04
    17fe:	80 83       	st	Z, r24
}
    1800:	26 96       	adiw	r28, 0x06	; 6
    1802:	0f b6       	in	r0, 0x3f	; 63
    1804:	f8 94       	cli
    1806:	de bf       	out	0x3e, r29	; 62
    1808:	0f be       	out	0x3f, r0	; 63
    180a:	cd bf       	out	0x3d, r28	; 61
    180c:	cf 91       	pop	r28
    180e:	df 91       	pop	r29
    1810:	08 95       	ret

00001812 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1812:	df 93       	push	r29
    1814:	cf 93       	push	r28
    1816:	cd b7       	in	r28, 0x3d	; 61
    1818:	de b7       	in	r29, 0x3e	; 62
    181a:	28 97       	sbiw	r28, 0x08	; 8
    181c:	0f b6       	in	r0, 0x3f	; 63
    181e:	f8 94       	cli
    1820:	de bf       	out	0x3e, r29	; 62
    1822:	0f be       	out	0x3f, r0	; 63
    1824:	cd bf       	out	0x3d, r28	; 61
    1826:	9e 83       	std	Y+6, r25	; 0x06
    1828:	8d 83       	std	Y+5, r24	; 0x05
    182a:	78 87       	std	Y+8, r23	; 0x08
    182c:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    182e:	ef 81       	ldd	r30, Y+7	; 0x07
    1830:	f8 85       	ldd	r31, Y+8	; 0x08
    1832:	80 81       	ld	r24, Z
    1834:	91 81       	ldd	r25, Z+1	; 0x01
    1836:	9a 83       	std	Y+2, r25	; 0x02
    1838:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    183a:	89 81       	ldd	r24, Y+1	; 0x01
    183c:	9a 81       	ldd	r25, Y+2	; 0x02
    183e:	2f ef       	ldi	r18, 0xFF	; 255
    1840:	8f 3f       	cpi	r24, 0xFF	; 255
    1842:	92 07       	cpc	r25, r18
    1844:	39 f4       	brne	.+14     	; 0x1854 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1846:	ed 81       	ldd	r30, Y+5	; 0x05
    1848:	fe 81       	ldd	r31, Y+6	; 0x06
    184a:	87 81       	ldd	r24, Z+7	; 0x07
    184c:	90 85       	ldd	r25, Z+8	; 0x08
    184e:	9c 83       	std	Y+4, r25	; 0x04
    1850:	8b 83       	std	Y+3, r24	; 0x03
    1852:	18 c0       	rjmp	.+48     	; 0x1884 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1854:	8d 81       	ldd	r24, Y+5	; 0x05
    1856:	9e 81       	ldd	r25, Y+6	; 0x06
    1858:	03 96       	adiw	r24, 0x03	; 3
    185a:	9c 83       	std	Y+4, r25	; 0x04
    185c:	8b 83       	std	Y+3, r24	; 0x03
    185e:	06 c0       	rjmp	.+12     	; 0x186c <vListInsert+0x5a>
    1860:	eb 81       	ldd	r30, Y+3	; 0x03
    1862:	fc 81       	ldd	r31, Y+4	; 0x04
    1864:	82 81       	ldd	r24, Z+2	; 0x02
    1866:	93 81       	ldd	r25, Z+3	; 0x03
    1868:	9c 83       	std	Y+4, r25	; 0x04
    186a:	8b 83       	std	Y+3, r24	; 0x03
    186c:	eb 81       	ldd	r30, Y+3	; 0x03
    186e:	fc 81       	ldd	r31, Y+4	; 0x04
    1870:	02 80       	ldd	r0, Z+2	; 0x02
    1872:	f3 81       	ldd	r31, Z+3	; 0x03
    1874:	e0 2d       	mov	r30, r0
    1876:	20 81       	ld	r18, Z
    1878:	31 81       	ldd	r19, Z+1	; 0x01
    187a:	89 81       	ldd	r24, Y+1	; 0x01
    187c:	9a 81       	ldd	r25, Y+2	; 0x02
    187e:	82 17       	cp	r24, r18
    1880:	93 07       	cpc	r25, r19
    1882:	70 f7       	brcc	.-36     	; 0x1860 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1884:	eb 81       	ldd	r30, Y+3	; 0x03
    1886:	fc 81       	ldd	r31, Y+4	; 0x04
    1888:	82 81       	ldd	r24, Z+2	; 0x02
    188a:	93 81       	ldd	r25, Z+3	; 0x03
    188c:	ef 81       	ldd	r30, Y+7	; 0x07
    188e:	f8 85       	ldd	r31, Y+8	; 0x08
    1890:	93 83       	std	Z+3, r25	; 0x03
    1892:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1894:	ef 81       	ldd	r30, Y+7	; 0x07
    1896:	f8 85       	ldd	r31, Y+8	; 0x08
    1898:	02 80       	ldd	r0, Z+2	; 0x02
    189a:	f3 81       	ldd	r31, Z+3	; 0x03
    189c:	e0 2d       	mov	r30, r0
    189e:	8f 81       	ldd	r24, Y+7	; 0x07
    18a0:	98 85       	ldd	r25, Y+8	; 0x08
    18a2:	95 83       	std	Z+5, r25	; 0x05
    18a4:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    18a6:	ef 81       	ldd	r30, Y+7	; 0x07
    18a8:	f8 85       	ldd	r31, Y+8	; 0x08
    18aa:	8b 81       	ldd	r24, Y+3	; 0x03
    18ac:	9c 81       	ldd	r25, Y+4	; 0x04
    18ae:	95 83       	std	Z+5, r25	; 0x05
    18b0:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    18b2:	eb 81       	ldd	r30, Y+3	; 0x03
    18b4:	fc 81       	ldd	r31, Y+4	; 0x04
    18b6:	8f 81       	ldd	r24, Y+7	; 0x07
    18b8:	98 85       	ldd	r25, Y+8	; 0x08
    18ba:	93 83       	std	Z+3, r25	; 0x03
    18bc:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    18be:	ef 81       	ldd	r30, Y+7	; 0x07
    18c0:	f8 85       	ldd	r31, Y+8	; 0x08
    18c2:	8d 81       	ldd	r24, Y+5	; 0x05
    18c4:	9e 81       	ldd	r25, Y+6	; 0x06
    18c6:	91 87       	std	Z+9, r25	; 0x09
    18c8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    18ca:	ed 81       	ldd	r30, Y+5	; 0x05
    18cc:	fe 81       	ldd	r31, Y+6	; 0x06
    18ce:	80 81       	ld	r24, Z
    18d0:	8f 5f       	subi	r24, 0xFF	; 255
    18d2:	ed 81       	ldd	r30, Y+5	; 0x05
    18d4:	fe 81       	ldd	r31, Y+6	; 0x06
    18d6:	80 83       	st	Z, r24
}
    18d8:	28 96       	adiw	r28, 0x08	; 8
    18da:	0f b6       	in	r0, 0x3f	; 63
    18dc:	f8 94       	cli
    18de:	de bf       	out	0x3e, r29	; 62
    18e0:	0f be       	out	0x3f, r0	; 63
    18e2:	cd bf       	out	0x3d, r28	; 61
    18e4:	cf 91       	pop	r28
    18e6:	df 91       	pop	r29
    18e8:	08 95       	ret

000018ea <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    18ea:	df 93       	push	r29
    18ec:	cf 93       	push	r28
    18ee:	00 d0       	rcall	.+0      	; 0x18f0 <uxListRemove+0x6>
    18f0:	00 d0       	rcall	.+0      	; 0x18f2 <uxListRemove+0x8>
    18f2:	cd b7       	in	r28, 0x3d	; 61
    18f4:	de b7       	in	r29, 0x3e	; 62
    18f6:	9c 83       	std	Y+4, r25	; 0x04
    18f8:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    18fa:	eb 81       	ldd	r30, Y+3	; 0x03
    18fc:	fc 81       	ldd	r31, Y+4	; 0x04
    18fe:	80 85       	ldd	r24, Z+8	; 0x08
    1900:	91 85       	ldd	r25, Z+9	; 0x09
    1902:	9a 83       	std	Y+2, r25	; 0x02
    1904:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1906:	eb 81       	ldd	r30, Y+3	; 0x03
    1908:	fc 81       	ldd	r31, Y+4	; 0x04
    190a:	a2 81       	ldd	r26, Z+2	; 0x02
    190c:	b3 81       	ldd	r27, Z+3	; 0x03
    190e:	eb 81       	ldd	r30, Y+3	; 0x03
    1910:	fc 81       	ldd	r31, Y+4	; 0x04
    1912:	84 81       	ldd	r24, Z+4	; 0x04
    1914:	95 81       	ldd	r25, Z+5	; 0x05
    1916:	15 96       	adiw	r26, 0x05	; 5
    1918:	9c 93       	st	X, r25
    191a:	8e 93       	st	-X, r24
    191c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    191e:	eb 81       	ldd	r30, Y+3	; 0x03
    1920:	fc 81       	ldd	r31, Y+4	; 0x04
    1922:	a4 81       	ldd	r26, Z+4	; 0x04
    1924:	b5 81       	ldd	r27, Z+5	; 0x05
    1926:	eb 81       	ldd	r30, Y+3	; 0x03
    1928:	fc 81       	ldd	r31, Y+4	; 0x04
    192a:	82 81       	ldd	r24, Z+2	; 0x02
    192c:	93 81       	ldd	r25, Z+3	; 0x03
    192e:	13 96       	adiw	r26, 0x03	; 3
    1930:	9c 93       	st	X, r25
    1932:	8e 93       	st	-X, r24
    1934:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1936:	e9 81       	ldd	r30, Y+1	; 0x01
    1938:	fa 81       	ldd	r31, Y+2	; 0x02
    193a:	21 81       	ldd	r18, Z+1	; 0x01
    193c:	32 81       	ldd	r19, Z+2	; 0x02
    193e:	8b 81       	ldd	r24, Y+3	; 0x03
    1940:	9c 81       	ldd	r25, Y+4	; 0x04
    1942:	28 17       	cp	r18, r24
    1944:	39 07       	cpc	r19, r25
    1946:	41 f4       	brne	.+16     	; 0x1958 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1948:	eb 81       	ldd	r30, Y+3	; 0x03
    194a:	fc 81       	ldd	r31, Y+4	; 0x04
    194c:	84 81       	ldd	r24, Z+4	; 0x04
    194e:	95 81       	ldd	r25, Z+5	; 0x05
    1950:	e9 81       	ldd	r30, Y+1	; 0x01
    1952:	fa 81       	ldd	r31, Y+2	; 0x02
    1954:	92 83       	std	Z+2, r25	; 0x02
    1956:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1958:	eb 81       	ldd	r30, Y+3	; 0x03
    195a:	fc 81       	ldd	r31, Y+4	; 0x04
    195c:	11 86       	std	Z+9, r1	; 0x09
    195e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1960:	e9 81       	ldd	r30, Y+1	; 0x01
    1962:	fa 81       	ldd	r31, Y+2	; 0x02
    1964:	80 81       	ld	r24, Z
    1966:	81 50       	subi	r24, 0x01	; 1
    1968:	e9 81       	ldd	r30, Y+1	; 0x01
    196a:	fa 81       	ldd	r31, Y+2	; 0x02
    196c:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    196e:	e9 81       	ldd	r30, Y+1	; 0x01
    1970:	fa 81       	ldd	r31, Y+2	; 0x02
    1972:	80 81       	ld	r24, Z
}
    1974:	0f 90       	pop	r0
    1976:	0f 90       	pop	r0
    1978:	0f 90       	pop	r0
    197a:	0f 90       	pop	r0
    197c:	cf 91       	pop	r28
    197e:	df 91       	pop	r29
    1980:	08 95       	ret

00001982 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1982:	df 93       	push	r29
    1984:	cf 93       	push	r28
    1986:	cd b7       	in	r28, 0x3d	; 61
    1988:	de b7       	in	r29, 0x3e	; 62
    198a:	28 97       	sbiw	r28, 0x08	; 8
    198c:	0f b6       	in	r0, 0x3f	; 63
    198e:	f8 94       	cli
    1990:	de bf       	out	0x3e, r29	; 62
    1992:	0f be       	out	0x3f, r0	; 63
    1994:	cd bf       	out	0x3d, r28	; 61
    1996:	9c 83       	std	Y+4, r25	; 0x04
    1998:	8b 83       	std	Y+3, r24	; 0x03
    199a:	7e 83       	std	Y+6, r23	; 0x06
    199c:	6d 83       	std	Y+5, r22	; 0x05
    199e:	58 87       	std	Y+8, r21	; 0x08
    19a0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    19a2:	eb 81       	ldd	r30, Y+3	; 0x03
    19a4:	fc 81       	ldd	r31, Y+4	; 0x04
    19a6:	81 e1       	ldi	r24, 0x11	; 17
    19a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    19aa:	8b 81       	ldd	r24, Y+3	; 0x03
    19ac:	9c 81       	ldd	r25, Y+4	; 0x04
    19ae:	01 97       	sbiw	r24, 0x01	; 1
    19b0:	9c 83       	std	Y+4, r25	; 0x04
    19b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    19b4:	eb 81       	ldd	r30, Y+3	; 0x03
    19b6:	fc 81       	ldd	r31, Y+4	; 0x04
    19b8:	82 e2       	ldi	r24, 0x22	; 34
    19ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    19bc:	8b 81       	ldd	r24, Y+3	; 0x03
    19be:	9c 81       	ldd	r25, Y+4	; 0x04
    19c0:	01 97       	sbiw	r24, 0x01	; 1
    19c2:	9c 83       	std	Y+4, r25	; 0x04
    19c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    19c6:	eb 81       	ldd	r30, Y+3	; 0x03
    19c8:	fc 81       	ldd	r31, Y+4	; 0x04
    19ca:	83 e3       	ldi	r24, 0x33	; 51
    19cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    19ce:	8b 81       	ldd	r24, Y+3	; 0x03
    19d0:	9c 81       	ldd	r25, Y+4	; 0x04
    19d2:	01 97       	sbiw	r24, 0x01	; 1
    19d4:	9c 83       	std	Y+4, r25	; 0x04
    19d6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    19d8:	8d 81       	ldd	r24, Y+5	; 0x05
    19da:	9e 81       	ldd	r25, Y+6	; 0x06
    19dc:	9a 83       	std	Y+2, r25	; 0x02
    19de:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    19e0:	89 81       	ldd	r24, Y+1	; 0x01
    19e2:	eb 81       	ldd	r30, Y+3	; 0x03
    19e4:	fc 81       	ldd	r31, Y+4	; 0x04
    19e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    19e8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ea:	9c 81       	ldd	r25, Y+4	; 0x04
    19ec:	01 97       	sbiw	r24, 0x01	; 1
    19ee:	9c 83       	std	Y+4, r25	; 0x04
    19f0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    19f2:	89 81       	ldd	r24, Y+1	; 0x01
    19f4:	9a 81       	ldd	r25, Y+2	; 0x02
    19f6:	89 2f       	mov	r24, r25
    19f8:	99 27       	eor	r25, r25
    19fa:	9a 83       	std	Y+2, r25	; 0x02
    19fc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    19fe:	89 81       	ldd	r24, Y+1	; 0x01
    1a00:	eb 81       	ldd	r30, Y+3	; 0x03
    1a02:	fc 81       	ldd	r31, Y+4	; 0x04
    1a04:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a06:	8b 81       	ldd	r24, Y+3	; 0x03
    1a08:	9c 81       	ldd	r25, Y+4	; 0x04
    1a0a:	01 97       	sbiw	r24, 0x01	; 1
    1a0c:	9c 83       	std	Y+4, r25	; 0x04
    1a0e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1a10:	eb 81       	ldd	r30, Y+3	; 0x03
    1a12:	fc 81       	ldd	r31, Y+4	; 0x04
    1a14:	10 82       	st	Z, r1
	pxTopOfStack--;
    1a16:	8b 81       	ldd	r24, Y+3	; 0x03
    1a18:	9c 81       	ldd	r25, Y+4	; 0x04
    1a1a:	01 97       	sbiw	r24, 0x01	; 1
    1a1c:	9c 83       	std	Y+4, r25	; 0x04
    1a1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1a20:	eb 81       	ldd	r30, Y+3	; 0x03
    1a22:	fc 81       	ldd	r31, Y+4	; 0x04
    1a24:	80 e8       	ldi	r24, 0x80	; 128
    1a26:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a28:	8b 81       	ldd	r24, Y+3	; 0x03
    1a2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a2c:	01 97       	sbiw	r24, 0x01	; 1
    1a2e:	9c 83       	std	Y+4, r25	; 0x04
    1a30:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1a32:	eb 81       	ldd	r30, Y+3	; 0x03
    1a34:	fc 81       	ldd	r31, Y+4	; 0x04
    1a36:	10 82       	st	Z, r1
	pxTopOfStack--;
    1a38:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a3c:	01 97       	sbiw	r24, 0x01	; 1
    1a3e:	9c 83       	std	Y+4, r25	; 0x04
    1a40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1a42:	eb 81       	ldd	r30, Y+3	; 0x03
    1a44:	fc 81       	ldd	r31, Y+4	; 0x04
    1a46:	82 e0       	ldi	r24, 0x02	; 2
    1a48:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a4e:	01 97       	sbiw	r24, 0x01	; 1
    1a50:	9c 83       	std	Y+4, r25	; 0x04
    1a52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1a54:	eb 81       	ldd	r30, Y+3	; 0x03
    1a56:	fc 81       	ldd	r31, Y+4	; 0x04
    1a58:	83 e0       	ldi	r24, 0x03	; 3
    1a5a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a60:	01 97       	sbiw	r24, 0x01	; 1
    1a62:	9c 83       	std	Y+4, r25	; 0x04
    1a64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1a66:	eb 81       	ldd	r30, Y+3	; 0x03
    1a68:	fc 81       	ldd	r31, Y+4	; 0x04
    1a6a:	84 e0       	ldi	r24, 0x04	; 4
    1a6c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a70:	9c 81       	ldd	r25, Y+4	; 0x04
    1a72:	01 97       	sbiw	r24, 0x01	; 1
    1a74:	9c 83       	std	Y+4, r25	; 0x04
    1a76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1a78:	eb 81       	ldd	r30, Y+3	; 0x03
    1a7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a7c:	85 e0       	ldi	r24, 0x05	; 5
    1a7e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a80:	8b 81       	ldd	r24, Y+3	; 0x03
    1a82:	9c 81       	ldd	r25, Y+4	; 0x04
    1a84:	01 97       	sbiw	r24, 0x01	; 1
    1a86:	9c 83       	std	Y+4, r25	; 0x04
    1a88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1a8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a8e:	86 e0       	ldi	r24, 0x06	; 6
    1a90:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a92:	8b 81       	ldd	r24, Y+3	; 0x03
    1a94:	9c 81       	ldd	r25, Y+4	; 0x04
    1a96:	01 97       	sbiw	r24, 0x01	; 1
    1a98:	9c 83       	std	Y+4, r25	; 0x04
    1a9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1a9c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a9e:	fc 81       	ldd	r31, Y+4	; 0x04
    1aa0:	87 e0       	ldi	r24, 0x07	; 7
    1aa2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1aa4:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa6:	9c 81       	ldd	r25, Y+4	; 0x04
    1aa8:	01 97       	sbiw	r24, 0x01	; 1
    1aaa:	9c 83       	std	Y+4, r25	; 0x04
    1aac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1aae:	eb 81       	ldd	r30, Y+3	; 0x03
    1ab0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ab2:	88 e0       	ldi	r24, 0x08	; 8
    1ab4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    1aba:	01 97       	sbiw	r24, 0x01	; 1
    1abc:	9c 83       	std	Y+4, r25	; 0x04
    1abe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1ac0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ac2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ac4:	89 e0       	ldi	r24, 0x09	; 9
    1ac6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aca:	9c 81       	ldd	r25, Y+4	; 0x04
    1acc:	01 97       	sbiw	r24, 0x01	; 1
    1ace:	9c 83       	std	Y+4, r25	; 0x04
    1ad0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1ad2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ad4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ad6:	80 e1       	ldi	r24, 0x10	; 16
    1ad8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ada:	8b 81       	ldd	r24, Y+3	; 0x03
    1adc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ade:	01 97       	sbiw	r24, 0x01	; 1
    1ae0:	9c 83       	std	Y+4, r25	; 0x04
    1ae2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1ae4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ae6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ae8:	81 e1       	ldi	r24, 0x11	; 17
    1aea:	80 83       	st	Z, r24
	pxTopOfStack--;
    1aec:	8b 81       	ldd	r24, Y+3	; 0x03
    1aee:	9c 81       	ldd	r25, Y+4	; 0x04
    1af0:	01 97       	sbiw	r24, 0x01	; 1
    1af2:	9c 83       	std	Y+4, r25	; 0x04
    1af4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1af6:	eb 81       	ldd	r30, Y+3	; 0x03
    1af8:	fc 81       	ldd	r31, Y+4	; 0x04
    1afa:	82 e1       	ldi	r24, 0x12	; 18
    1afc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1afe:	8b 81       	ldd	r24, Y+3	; 0x03
    1b00:	9c 81       	ldd	r25, Y+4	; 0x04
    1b02:	01 97       	sbiw	r24, 0x01	; 1
    1b04:	9c 83       	std	Y+4, r25	; 0x04
    1b06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1b08:	eb 81       	ldd	r30, Y+3	; 0x03
    1b0a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b0c:	83 e1       	ldi	r24, 0x13	; 19
    1b0e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b10:	8b 81       	ldd	r24, Y+3	; 0x03
    1b12:	9c 81       	ldd	r25, Y+4	; 0x04
    1b14:	01 97       	sbiw	r24, 0x01	; 1
    1b16:	9c 83       	std	Y+4, r25	; 0x04
    1b18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1b1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b1e:	84 e1       	ldi	r24, 0x14	; 20
    1b20:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b22:	8b 81       	ldd	r24, Y+3	; 0x03
    1b24:	9c 81       	ldd	r25, Y+4	; 0x04
    1b26:	01 97       	sbiw	r24, 0x01	; 1
    1b28:	9c 83       	std	Y+4, r25	; 0x04
    1b2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1b2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b30:	85 e1       	ldi	r24, 0x15	; 21
    1b32:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b34:	8b 81       	ldd	r24, Y+3	; 0x03
    1b36:	9c 81       	ldd	r25, Y+4	; 0x04
    1b38:	01 97       	sbiw	r24, 0x01	; 1
    1b3a:	9c 83       	std	Y+4, r25	; 0x04
    1b3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1b3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b40:	fc 81       	ldd	r31, Y+4	; 0x04
    1b42:	86 e1       	ldi	r24, 0x16	; 22
    1b44:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b46:	8b 81       	ldd	r24, Y+3	; 0x03
    1b48:	9c 81       	ldd	r25, Y+4	; 0x04
    1b4a:	01 97       	sbiw	r24, 0x01	; 1
    1b4c:	9c 83       	std	Y+4, r25	; 0x04
    1b4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1b50:	eb 81       	ldd	r30, Y+3	; 0x03
    1b52:	fc 81       	ldd	r31, Y+4	; 0x04
    1b54:	87 e1       	ldi	r24, 0x17	; 23
    1b56:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b58:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b5c:	01 97       	sbiw	r24, 0x01	; 1
    1b5e:	9c 83       	std	Y+4, r25	; 0x04
    1b60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1b62:	eb 81       	ldd	r30, Y+3	; 0x03
    1b64:	fc 81       	ldd	r31, Y+4	; 0x04
    1b66:	88 e1       	ldi	r24, 0x18	; 24
    1b68:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b6e:	01 97       	sbiw	r24, 0x01	; 1
    1b70:	9c 83       	std	Y+4, r25	; 0x04
    1b72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1b74:	eb 81       	ldd	r30, Y+3	; 0x03
    1b76:	fc 81       	ldd	r31, Y+4	; 0x04
    1b78:	89 e1       	ldi	r24, 0x19	; 25
    1b7a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b7e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b80:	01 97       	sbiw	r24, 0x01	; 1
    1b82:	9c 83       	std	Y+4, r25	; 0x04
    1b84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1b86:	eb 81       	ldd	r30, Y+3	; 0x03
    1b88:	fc 81       	ldd	r31, Y+4	; 0x04
    1b8a:	80 e2       	ldi	r24, 0x20	; 32
    1b8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b90:	9c 81       	ldd	r25, Y+4	; 0x04
    1b92:	01 97       	sbiw	r24, 0x01	; 1
    1b94:	9c 83       	std	Y+4, r25	; 0x04
    1b96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1b98:	eb 81       	ldd	r30, Y+3	; 0x03
    1b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b9c:	81 e2       	ldi	r24, 0x21	; 33
    1b9e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ba2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ba4:	01 97       	sbiw	r24, 0x01	; 1
    1ba6:	9c 83       	std	Y+4, r25	; 0x04
    1ba8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1baa:	eb 81       	ldd	r30, Y+3	; 0x03
    1bac:	fc 81       	ldd	r31, Y+4	; 0x04
    1bae:	82 e2       	ldi	r24, 0x22	; 34
    1bb0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb4:	9c 81       	ldd	r25, Y+4	; 0x04
    1bb6:	01 97       	sbiw	r24, 0x01	; 1
    1bb8:	9c 83       	std	Y+4, r25	; 0x04
    1bba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1bbc:	eb 81       	ldd	r30, Y+3	; 0x03
    1bbe:	fc 81       	ldd	r31, Y+4	; 0x04
    1bc0:	83 e2       	ldi	r24, 0x23	; 35
    1bc2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc8:	01 97       	sbiw	r24, 0x01	; 1
    1bca:	9c 83       	std	Y+4, r25	; 0x04
    1bcc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1bce:	8f 81       	ldd	r24, Y+7	; 0x07
    1bd0:	98 85       	ldd	r25, Y+8	; 0x08
    1bd2:	9a 83       	std	Y+2, r25	; 0x02
    1bd4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1bd6:	89 81       	ldd	r24, Y+1	; 0x01
    1bd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bda:	fc 81       	ldd	r31, Y+4	; 0x04
    1bdc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bde:	8b 81       	ldd	r24, Y+3	; 0x03
    1be0:	9c 81       	ldd	r25, Y+4	; 0x04
    1be2:	01 97       	sbiw	r24, 0x01	; 1
    1be4:	9c 83       	std	Y+4, r25	; 0x04
    1be6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1be8:	89 81       	ldd	r24, Y+1	; 0x01
    1bea:	9a 81       	ldd	r25, Y+2	; 0x02
    1bec:	89 2f       	mov	r24, r25
    1bee:	99 27       	eor	r25, r25
    1bf0:	9a 83       	std	Y+2, r25	; 0x02
    1bf2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1bf4:	89 81       	ldd	r24, Y+1	; 0x01
    1bf6:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bfa:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1bfe:	9c 81       	ldd	r25, Y+4	; 0x04
    1c00:	01 97       	sbiw	r24, 0x01	; 1
    1c02:	9c 83       	std	Y+4, r25	; 0x04
    1c04:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1c06:	eb 81       	ldd	r30, Y+3	; 0x03
    1c08:	fc 81       	ldd	r31, Y+4	; 0x04
    1c0a:	86 e2       	ldi	r24, 0x26	; 38
    1c0c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c10:	9c 81       	ldd	r25, Y+4	; 0x04
    1c12:	01 97       	sbiw	r24, 0x01	; 1
    1c14:	9c 83       	std	Y+4, r25	; 0x04
    1c16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1c18:	eb 81       	ldd	r30, Y+3	; 0x03
    1c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c1c:	87 e2       	ldi	r24, 0x27	; 39
    1c1e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c20:	8b 81       	ldd	r24, Y+3	; 0x03
    1c22:	9c 81       	ldd	r25, Y+4	; 0x04
    1c24:	01 97       	sbiw	r24, 0x01	; 1
    1c26:	9c 83       	std	Y+4, r25	; 0x04
    1c28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1c2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c2e:	88 e2       	ldi	r24, 0x28	; 40
    1c30:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c32:	8b 81       	ldd	r24, Y+3	; 0x03
    1c34:	9c 81       	ldd	r25, Y+4	; 0x04
    1c36:	01 97       	sbiw	r24, 0x01	; 1
    1c38:	9c 83       	std	Y+4, r25	; 0x04
    1c3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c40:	89 e2       	ldi	r24, 0x29	; 41
    1c42:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c44:	8b 81       	ldd	r24, Y+3	; 0x03
    1c46:	9c 81       	ldd	r25, Y+4	; 0x04
    1c48:	01 97       	sbiw	r24, 0x01	; 1
    1c4a:	9c 83       	std	Y+4, r25	; 0x04
    1c4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1c4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c50:	fc 81       	ldd	r31, Y+4	; 0x04
    1c52:	80 e3       	ldi	r24, 0x30	; 48
    1c54:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c56:	8b 81       	ldd	r24, Y+3	; 0x03
    1c58:	9c 81       	ldd	r25, Y+4	; 0x04
    1c5a:	01 97       	sbiw	r24, 0x01	; 1
    1c5c:	9c 83       	std	Y+4, r25	; 0x04
    1c5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1c60:	eb 81       	ldd	r30, Y+3	; 0x03
    1c62:	fc 81       	ldd	r31, Y+4	; 0x04
    1c64:	81 e3       	ldi	r24, 0x31	; 49
    1c66:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c68:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c6c:	01 97       	sbiw	r24, 0x01	; 1
    1c6e:	9c 83       	std	Y+4, r25	; 0x04
    1c70:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1c72:	8b 81       	ldd	r24, Y+3	; 0x03
    1c74:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1c76:	28 96       	adiw	r28, 0x08	; 8
    1c78:	0f b6       	in	r0, 0x3f	; 63
    1c7a:	f8 94       	cli
    1c7c:	de bf       	out	0x3e, r29	; 62
    1c7e:	0f be       	out	0x3f, r0	; 63
    1c80:	cd bf       	out	0x3d, r28	; 61
    1c82:	cf 91       	pop	r28
    1c84:	df 91       	pop	r29
    1c86:	08 95       	ret

00001c88 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1c88:	df 93       	push	r29
    1c8a:	cf 93       	push	r28
    1c8c:	cd b7       	in	r28, 0x3d	; 61
    1c8e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1c90:	0e 94 36 0f 	call	0x1e6c	; 0x1e6c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1c94:	a0 91 f4 02 	lds	r26, 0x02F4
    1c98:	b0 91 f5 02 	lds	r27, 0x02F5
    1c9c:	cd 91       	ld	r28, X+
    1c9e:	cd bf       	out	0x3d, r28	; 61
    1ca0:	dd 91       	ld	r29, X+
    1ca2:	de bf       	out	0x3e, r29	; 62
    1ca4:	ff 91       	pop	r31
    1ca6:	ef 91       	pop	r30
    1ca8:	df 91       	pop	r29
    1caa:	cf 91       	pop	r28
    1cac:	bf 91       	pop	r27
    1cae:	af 91       	pop	r26
    1cb0:	9f 91       	pop	r25
    1cb2:	8f 91       	pop	r24
    1cb4:	7f 91       	pop	r23
    1cb6:	6f 91       	pop	r22
    1cb8:	5f 91       	pop	r21
    1cba:	4f 91       	pop	r20
    1cbc:	3f 91       	pop	r19
    1cbe:	2f 91       	pop	r18
    1cc0:	1f 91       	pop	r17
    1cc2:	0f 91       	pop	r16
    1cc4:	ff 90       	pop	r15
    1cc6:	ef 90       	pop	r14
    1cc8:	df 90       	pop	r13
    1cca:	cf 90       	pop	r12
    1ccc:	bf 90       	pop	r11
    1cce:	af 90       	pop	r10
    1cd0:	9f 90       	pop	r9
    1cd2:	8f 90       	pop	r8
    1cd4:	7f 90       	pop	r7
    1cd6:	6f 90       	pop	r6
    1cd8:	5f 90       	pop	r5
    1cda:	4f 90       	pop	r4
    1cdc:	3f 90       	pop	r3
    1cde:	2f 90       	pop	r2
    1ce0:	1f 90       	pop	r1
    1ce2:	0f 90       	pop	r0
    1ce4:	0f be       	out	0x3f, r0	; 63
    1ce6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1ce8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1cea:	81 e0       	ldi	r24, 0x01	; 1
}
    1cec:	cf 91       	pop	r28
    1cee:	df 91       	pop	r29
    1cf0:	08 95       	ret

00001cf2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1cf2:	df 93       	push	r29
    1cf4:	cf 93       	push	r28
    1cf6:	cd b7       	in	r28, 0x3d	; 61
    1cf8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1cfa:	cf 91       	pop	r28
    1cfc:	df 91       	pop	r29
    1cfe:	08 95       	ret

00001d00 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1d00:	0f 92       	push	r0
    1d02:	0f b6       	in	r0, 0x3f	; 63
    1d04:	f8 94       	cli
    1d06:	0f 92       	push	r0
    1d08:	1f 92       	push	r1
    1d0a:	11 24       	eor	r1, r1
    1d0c:	2f 92       	push	r2
    1d0e:	3f 92       	push	r3
    1d10:	4f 92       	push	r4
    1d12:	5f 92       	push	r5
    1d14:	6f 92       	push	r6
    1d16:	7f 92       	push	r7
    1d18:	8f 92       	push	r8
    1d1a:	9f 92       	push	r9
    1d1c:	af 92       	push	r10
    1d1e:	bf 92       	push	r11
    1d20:	cf 92       	push	r12
    1d22:	df 92       	push	r13
    1d24:	ef 92       	push	r14
    1d26:	ff 92       	push	r15
    1d28:	0f 93       	push	r16
    1d2a:	1f 93       	push	r17
    1d2c:	2f 93       	push	r18
    1d2e:	3f 93       	push	r19
    1d30:	4f 93       	push	r20
    1d32:	5f 93       	push	r21
    1d34:	6f 93       	push	r22
    1d36:	7f 93       	push	r23
    1d38:	8f 93       	push	r24
    1d3a:	9f 93       	push	r25
    1d3c:	af 93       	push	r26
    1d3e:	bf 93       	push	r27
    1d40:	cf 93       	push	r28
    1d42:	df 93       	push	r29
    1d44:	ef 93       	push	r30
    1d46:	ff 93       	push	r31
    1d48:	a0 91 f4 02 	lds	r26, 0x02F4
    1d4c:	b0 91 f5 02 	lds	r27, 0x02F5
    1d50:	0d b6       	in	r0, 0x3d	; 61
    1d52:	0d 92       	st	X+, r0
    1d54:	0e b6       	in	r0, 0x3e	; 62
    1d56:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1d58:	0e 94 16 1b 	call	0x362c	; 0x362c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1d5c:	a0 91 f4 02 	lds	r26, 0x02F4
    1d60:	b0 91 f5 02 	lds	r27, 0x02F5
    1d64:	cd 91       	ld	r28, X+
    1d66:	cd bf       	out	0x3d, r28	; 61
    1d68:	dd 91       	ld	r29, X+
    1d6a:	de bf       	out	0x3e, r29	; 62
    1d6c:	ff 91       	pop	r31
    1d6e:	ef 91       	pop	r30
    1d70:	df 91       	pop	r29
    1d72:	cf 91       	pop	r28
    1d74:	bf 91       	pop	r27
    1d76:	af 91       	pop	r26
    1d78:	9f 91       	pop	r25
    1d7a:	8f 91       	pop	r24
    1d7c:	7f 91       	pop	r23
    1d7e:	6f 91       	pop	r22
    1d80:	5f 91       	pop	r21
    1d82:	4f 91       	pop	r20
    1d84:	3f 91       	pop	r19
    1d86:	2f 91       	pop	r18
    1d88:	1f 91       	pop	r17
    1d8a:	0f 91       	pop	r16
    1d8c:	ff 90       	pop	r15
    1d8e:	ef 90       	pop	r14
    1d90:	df 90       	pop	r13
    1d92:	cf 90       	pop	r12
    1d94:	bf 90       	pop	r11
    1d96:	af 90       	pop	r10
    1d98:	9f 90       	pop	r9
    1d9a:	8f 90       	pop	r8
    1d9c:	7f 90       	pop	r7
    1d9e:	6f 90       	pop	r6
    1da0:	5f 90       	pop	r5
    1da2:	4f 90       	pop	r4
    1da4:	3f 90       	pop	r3
    1da6:	2f 90       	pop	r2
    1da8:	1f 90       	pop	r1
    1daa:	0f 90       	pop	r0
    1dac:	0f be       	out	0x3f, r0	; 63
    1dae:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1db0:	08 95       	ret

00001db2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1db2:	0f 92       	push	r0
    1db4:	0f b6       	in	r0, 0x3f	; 63
    1db6:	f8 94       	cli
    1db8:	0f 92       	push	r0
    1dba:	1f 92       	push	r1
    1dbc:	11 24       	eor	r1, r1
    1dbe:	2f 92       	push	r2
    1dc0:	3f 92       	push	r3
    1dc2:	4f 92       	push	r4
    1dc4:	5f 92       	push	r5
    1dc6:	6f 92       	push	r6
    1dc8:	7f 92       	push	r7
    1dca:	8f 92       	push	r8
    1dcc:	9f 92       	push	r9
    1dce:	af 92       	push	r10
    1dd0:	bf 92       	push	r11
    1dd2:	cf 92       	push	r12
    1dd4:	df 92       	push	r13
    1dd6:	ef 92       	push	r14
    1dd8:	ff 92       	push	r15
    1dda:	0f 93       	push	r16
    1ddc:	1f 93       	push	r17
    1dde:	2f 93       	push	r18
    1de0:	3f 93       	push	r19
    1de2:	4f 93       	push	r20
    1de4:	5f 93       	push	r21
    1de6:	6f 93       	push	r22
    1de8:	7f 93       	push	r23
    1dea:	8f 93       	push	r24
    1dec:	9f 93       	push	r25
    1dee:	af 93       	push	r26
    1df0:	bf 93       	push	r27
    1df2:	cf 93       	push	r28
    1df4:	df 93       	push	r29
    1df6:	ef 93       	push	r30
    1df8:	ff 93       	push	r31
    1dfa:	a0 91 f4 02 	lds	r26, 0x02F4
    1dfe:	b0 91 f5 02 	lds	r27, 0x02F5
    1e02:	0d b6       	in	r0, 0x3d	; 61
    1e04:	0d 92       	st	X+, r0
    1e06:	0e b6       	in	r0, 0x3e	; 62
    1e08:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1e0a:	0e 94 31 1a 	call	0x3462	; 0x3462 <xTaskIncrementTick>
    1e0e:	88 23       	and	r24, r24
    1e10:	11 f0       	breq	.+4      	; 0x1e16 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1e12:	0e 94 16 1b 	call	0x362c	; 0x362c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1e16:	a0 91 f4 02 	lds	r26, 0x02F4
    1e1a:	b0 91 f5 02 	lds	r27, 0x02F5
    1e1e:	cd 91       	ld	r28, X+
    1e20:	cd bf       	out	0x3d, r28	; 61
    1e22:	dd 91       	ld	r29, X+
    1e24:	de bf       	out	0x3e, r29	; 62
    1e26:	ff 91       	pop	r31
    1e28:	ef 91       	pop	r30
    1e2a:	df 91       	pop	r29
    1e2c:	cf 91       	pop	r28
    1e2e:	bf 91       	pop	r27
    1e30:	af 91       	pop	r26
    1e32:	9f 91       	pop	r25
    1e34:	8f 91       	pop	r24
    1e36:	7f 91       	pop	r23
    1e38:	6f 91       	pop	r22
    1e3a:	5f 91       	pop	r21
    1e3c:	4f 91       	pop	r20
    1e3e:	3f 91       	pop	r19
    1e40:	2f 91       	pop	r18
    1e42:	1f 91       	pop	r17
    1e44:	0f 91       	pop	r16
    1e46:	ff 90       	pop	r15
    1e48:	ef 90       	pop	r14
    1e4a:	df 90       	pop	r13
    1e4c:	cf 90       	pop	r12
    1e4e:	bf 90       	pop	r11
    1e50:	af 90       	pop	r10
    1e52:	9f 90       	pop	r9
    1e54:	8f 90       	pop	r8
    1e56:	7f 90       	pop	r7
    1e58:	6f 90       	pop	r6
    1e5a:	5f 90       	pop	r5
    1e5c:	4f 90       	pop	r4
    1e5e:	3f 90       	pop	r3
    1e60:	2f 90       	pop	r2
    1e62:	1f 90       	pop	r1
    1e64:	0f 90       	pop	r0
    1e66:	0f be       	out	0x3f, r0	; 63
    1e68:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1e6a:	08 95       	ret

00001e6c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1e6c:	df 93       	push	r29
    1e6e:	cf 93       	push	r28
    1e70:	00 d0       	rcall	.+0      	; 0x1e72 <prvSetupTimerInterrupt+0x6>
    1e72:	00 d0       	rcall	.+0      	; 0x1e74 <prvSetupTimerInterrupt+0x8>
    1e74:	00 d0       	rcall	.+0      	; 0x1e76 <prvSetupTimerInterrupt+0xa>
    1e76:	cd b7       	in	r28, 0x3d	; 61
    1e78:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1e7a:	80 e8       	ldi	r24, 0x80	; 128
    1e7c:	9e e3       	ldi	r25, 0x3E	; 62
    1e7e:	a0 e0       	ldi	r26, 0x00	; 0
    1e80:	b0 e0       	ldi	r27, 0x00	; 0
    1e82:	8b 83       	std	Y+3, r24	; 0x03
    1e84:	9c 83       	std	Y+4, r25	; 0x04
    1e86:	ad 83       	std	Y+5, r26	; 0x05
    1e88:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1e8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e8e:	ad 81       	ldd	r26, Y+5	; 0x05
    1e90:	be 81       	ldd	r27, Y+6	; 0x06
    1e92:	68 94       	set
    1e94:	15 f8       	bld	r1, 5
    1e96:	b6 95       	lsr	r27
    1e98:	a7 95       	ror	r26
    1e9a:	97 95       	ror	r25
    1e9c:	87 95       	ror	r24
    1e9e:	16 94       	lsr	r1
    1ea0:	d1 f7       	brne	.-12     	; 0x1e96 <prvSetupTimerInterrupt+0x2a>
    1ea2:	8b 83       	std	Y+3, r24	; 0x03
    1ea4:	9c 83       	std	Y+4, r25	; 0x04
    1ea6:	ad 83       	std	Y+5, r26	; 0x05
    1ea8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    1eac:	9c 81       	ldd	r25, Y+4	; 0x04
    1eae:	ad 81       	ldd	r26, Y+5	; 0x05
    1eb0:	be 81       	ldd	r27, Y+6	; 0x06
    1eb2:	01 97       	sbiw	r24, 0x01	; 1
    1eb4:	a1 09       	sbc	r26, r1
    1eb6:	b1 09       	sbc	r27, r1
    1eb8:	8b 83       	std	Y+3, r24	; 0x03
    1eba:	9c 83       	std	Y+4, r25	; 0x04
    1ebc:	ad 83       	std	Y+5, r26	; 0x05
    1ebe:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1ec4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec8:	ad 81       	ldd	r26, Y+5	; 0x05
    1eca:	be 81       	ldd	r27, Y+6	; 0x06
    1ecc:	89 2f       	mov	r24, r25
    1ece:	9a 2f       	mov	r25, r26
    1ed0:	ab 2f       	mov	r26, r27
    1ed2:	bb 27       	eor	r27, r27
    1ed4:	8b 83       	std	Y+3, r24	; 0x03
    1ed6:	9c 83       	std	Y+4, r25	; 0x04
    1ed8:	ad 83       	std	Y+5, r26	; 0x05
    1eda:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1edc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ede:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1ee0:	eb e4       	ldi	r30, 0x4B	; 75
    1ee2:	f0 e0       	ldi	r31, 0x00	; 0
    1ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1ee8:	ea e4       	ldi	r30, 0x4A	; 74
    1eea:	f0 e0       	ldi	r31, 0x00	; 0
    1eec:	89 81       	ldd	r24, Y+1	; 0x01
    1eee:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1ef0:	8b e0       	ldi	r24, 0x0B	; 11
    1ef2:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1ef4:	ee e4       	ldi	r30, 0x4E	; 78
    1ef6:	f0 e0       	ldi	r31, 0x00	; 0
    1ef8:	89 81       	ldd	r24, Y+1	; 0x01
    1efa:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1efc:	e9 e5       	ldi	r30, 0x59	; 89
    1efe:	f0 e0       	ldi	r31, 0x00	; 0
    1f00:	80 81       	ld	r24, Z
    1f02:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1f04:	89 81       	ldd	r24, Y+1	; 0x01
    1f06:	80 61       	ori	r24, 0x10	; 16
    1f08:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1f0a:	e9 e5       	ldi	r30, 0x59	; 89
    1f0c:	f0 e0       	ldi	r31, 0x00	; 0
    1f0e:	89 81       	ldd	r24, Y+1	; 0x01
    1f10:	80 83       	st	Z, r24
}
    1f12:	26 96       	adiw	r28, 0x06	; 6
    1f14:	0f b6       	in	r0, 0x3f	; 63
    1f16:	f8 94       	cli
    1f18:	de bf       	out	0x3e, r29	; 62
    1f1a:	0f be       	out	0x3f, r0	; 63
    1f1c:	cd bf       	out	0x3d, r28	; 61
    1f1e:	cf 91       	pop	r28
    1f20:	df 91       	pop	r29
    1f22:	08 95       	ret

00001f24 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1f24:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1f28:	18 95       	reti

00001f2a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1f2a:	df 93       	push	r29
    1f2c:	cf 93       	push	r28
    1f2e:	00 d0       	rcall	.+0      	; 0x1f30 <xQueueGenericReset+0x6>
    1f30:	00 d0       	rcall	.+0      	; 0x1f32 <xQueueGenericReset+0x8>
    1f32:	0f 92       	push	r0
    1f34:	cd b7       	in	r28, 0x3d	; 61
    1f36:	de b7       	in	r29, 0x3e	; 62
    1f38:	9c 83       	std	Y+4, r25	; 0x04
    1f3a:	8b 83       	std	Y+3, r24	; 0x03
    1f3c:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1f3e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f40:	9c 81       	ldd	r25, Y+4	; 0x04
    1f42:	9a 83       	std	Y+2, r25	; 0x02
    1f44:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1f46:	0f b6       	in	r0, 0x3f	; 63
    1f48:	f8 94       	cli
    1f4a:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f50:	40 81       	ld	r20, Z
    1f52:	51 81       	ldd	r21, Z+1	; 0x01
    1f54:	e9 81       	ldd	r30, Y+1	; 0x01
    1f56:	fa 81       	ldd	r31, Y+2	; 0x02
    1f58:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f5a:	28 2f       	mov	r18, r24
    1f5c:	30 e0       	ldi	r19, 0x00	; 0
    1f5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f60:	fa 81       	ldd	r31, Y+2	; 0x02
    1f62:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f64:	88 2f       	mov	r24, r24
    1f66:	90 e0       	ldi	r25, 0x00	; 0
    1f68:	bc 01       	movw	r22, r24
    1f6a:	26 9f       	mul	r18, r22
    1f6c:	c0 01       	movw	r24, r0
    1f6e:	27 9f       	mul	r18, r23
    1f70:	90 0d       	add	r25, r0
    1f72:	36 9f       	mul	r19, r22
    1f74:	90 0d       	add	r25, r0
    1f76:	11 24       	eor	r1, r1
    1f78:	84 0f       	add	r24, r20
    1f7a:	95 1f       	adc	r25, r21
    1f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f80:	95 83       	std	Z+5, r25	; 0x05
    1f82:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1f84:	e9 81       	ldd	r30, Y+1	; 0x01
    1f86:	fa 81       	ldd	r31, Y+2	; 0x02
    1f88:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1f8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f8e:	80 81       	ld	r24, Z
    1f90:	91 81       	ldd	r25, Z+1	; 0x01
    1f92:	e9 81       	ldd	r30, Y+1	; 0x01
    1f94:	fa 81       	ldd	r31, Y+2	; 0x02
    1f96:	93 83       	std	Z+3, r25	; 0x03
    1f98:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f9e:	40 81       	ld	r20, Z
    1fa0:	51 81       	ldd	r21, Z+1	; 0x01
    1fa2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fa4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1fa8:	88 2f       	mov	r24, r24
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	9c 01       	movw	r18, r24
    1fae:	21 50       	subi	r18, 0x01	; 1
    1fb0:	30 40       	sbci	r19, 0x00	; 0
    1fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fb6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fb8:	88 2f       	mov	r24, r24
    1fba:	90 e0       	ldi	r25, 0x00	; 0
    1fbc:	bc 01       	movw	r22, r24
    1fbe:	26 9f       	mul	r18, r22
    1fc0:	c0 01       	movw	r24, r0
    1fc2:	27 9f       	mul	r18, r23
    1fc4:	90 0d       	add	r25, r0
    1fc6:	36 9f       	mul	r19, r22
    1fc8:	90 0d       	add	r25, r0
    1fca:	11 24       	eor	r1, r1
    1fcc:	84 0f       	add	r24, r20
    1fce:	95 1f       	adc	r25, r21
    1fd0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fd2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fd4:	97 83       	std	Z+7, r25	; 0x07
    1fd6:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1fd8:	e9 81       	ldd	r30, Y+1	; 0x01
    1fda:	fa 81       	ldd	r31, Y+2	; 0x02
    1fdc:	8f ef       	ldi	r24, 0xFF	; 255
    1fde:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1fe0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fe2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fe4:	8f ef       	ldi	r24, 0xFF	; 255
    1fe6:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1fe8:	8d 81       	ldd	r24, Y+5	; 0x05
    1fea:	88 23       	and	r24, r24
    1fec:	79 f4       	brne	.+30     	; 0x200c <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1fee:	e9 81       	ldd	r30, Y+1	; 0x01
    1ff0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ff2:	80 85       	ldd	r24, Z+8	; 0x08
    1ff4:	88 23       	and	r24, r24
    1ff6:	a1 f0       	breq	.+40     	; 0x2020 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ff8:	89 81       	ldd	r24, Y+1	; 0x01
    1ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffc:	08 96       	adiw	r24, 0x08	; 8
    1ffe:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <xTaskRemoveFromEventList>
    2002:	88 23       	and	r24, r24
    2004:	69 f0       	breq	.+26     	; 0x2020 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2006:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
    200a:	0a c0       	rjmp	.+20     	; 0x2020 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    200c:	89 81       	ldd	r24, Y+1	; 0x01
    200e:	9a 81       	ldd	r25, Y+2	; 0x02
    2010:	08 96       	adiw	r24, 0x08	; 8
    2012:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2016:	89 81       	ldd	r24, Y+1	; 0x01
    2018:	9a 81       	ldd	r25, Y+2	; 0x02
    201a:	41 96       	adiw	r24, 0x11	; 17
    201c:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2020:	0f 90       	pop	r0
    2022:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2024:	81 e0       	ldi	r24, 0x01	; 1
}
    2026:	0f 90       	pop	r0
    2028:	0f 90       	pop	r0
    202a:	0f 90       	pop	r0
    202c:	0f 90       	pop	r0
    202e:	0f 90       	pop	r0
    2030:	cf 91       	pop	r28
    2032:	df 91       	pop	r29
    2034:	08 95       	ret

00002036 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    2036:	0f 93       	push	r16
    2038:	1f 93       	push	r17
    203a:	df 93       	push	r29
    203c:	cf 93       	push	r28
    203e:	cd b7       	in	r28, 0x3d	; 61
    2040:	de b7       	in	r29, 0x3e	; 62
    2042:	29 97       	sbiw	r28, 0x09	; 9
    2044:	0f b6       	in	r0, 0x3f	; 63
    2046:	f8 94       	cli
    2048:	de bf       	out	0x3e, r29	; 62
    204a:	0f be       	out	0x3f, r0	; 63
    204c:	cd bf       	out	0x3d, r28	; 61
    204e:	8f 83       	std	Y+7, r24	; 0x07
    2050:	68 87       	std	Y+8, r22	; 0x08
    2052:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    2054:	88 85       	ldd	r24, Y+8	; 0x08
    2056:	88 23       	and	r24, r24
    2058:	19 f4       	brne	.+6      	; 0x2060 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    205a:	1c 82       	std	Y+4, r1	; 0x04
    205c:	1b 82       	std	Y+3, r1	; 0x03
    205e:	10 c0       	rjmp	.+32     	; 0x2080 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2060:	8f 81       	ldd	r24, Y+7	; 0x07
    2062:	28 2f       	mov	r18, r24
    2064:	30 e0       	ldi	r19, 0x00	; 0
    2066:	88 85       	ldd	r24, Y+8	; 0x08
    2068:	88 2f       	mov	r24, r24
    206a:	90 e0       	ldi	r25, 0x00	; 0
    206c:	ac 01       	movw	r20, r24
    206e:	24 9f       	mul	r18, r20
    2070:	c0 01       	movw	r24, r0
    2072:	25 9f       	mul	r18, r21
    2074:	90 0d       	add	r25, r0
    2076:	34 9f       	mul	r19, r20
    2078:	90 0d       	add	r25, r0
    207a:	11 24       	eor	r1, r1
    207c:	9c 83       	std	Y+4, r25	; 0x04
    207e:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2080:	8b 81       	ldd	r24, Y+3	; 0x03
    2082:	9c 81       	ldd	r25, Y+4	; 0x04
    2084:	4f 96       	adiw	r24, 0x1f	; 31
    2086:	0e 94 0f 0b 	call	0x161e	; 0x161e <pvPortMalloc>
    208a:	9e 83       	std	Y+6, r25	; 0x06
    208c:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    208e:	8d 81       	ldd	r24, Y+5	; 0x05
    2090:	9e 81       	ldd	r25, Y+6	; 0x06
    2092:	00 97       	sbiw	r24, 0x00	; 0
    2094:	a1 f0       	breq	.+40     	; 0x20be <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    2096:	8d 81       	ldd	r24, Y+5	; 0x05
    2098:	9e 81       	ldd	r25, Y+6	; 0x06
    209a:	9a 83       	std	Y+2, r25	; 0x02
    209c:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    209e:	89 81       	ldd	r24, Y+1	; 0x01
    20a0:	9a 81       	ldd	r25, Y+2	; 0x02
    20a2:	4f 96       	adiw	r24, 0x1f	; 31
    20a4:	9a 83       	std	Y+2, r25	; 0x02
    20a6:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    20a8:	29 81       	ldd	r18, Y+1	; 0x01
    20aa:	3a 81       	ldd	r19, Y+2	; 0x02
    20ac:	ed 81       	ldd	r30, Y+5	; 0x05
    20ae:	fe 81       	ldd	r31, Y+6	; 0x06
    20b0:	8f 81       	ldd	r24, Y+7	; 0x07
    20b2:	68 85       	ldd	r22, Y+8	; 0x08
    20b4:	a9 01       	movw	r20, r18
    20b6:	29 85       	ldd	r18, Y+9	; 0x09
    20b8:	8f 01       	movw	r16, r30
    20ba:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    20be:	8d 81       	ldd	r24, Y+5	; 0x05
    20c0:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    20c2:	29 96       	adiw	r28, 0x09	; 9
    20c4:	0f b6       	in	r0, 0x3f	; 63
    20c6:	f8 94       	cli
    20c8:	de bf       	out	0x3e, r29	; 62
    20ca:	0f be       	out	0x3f, r0	; 63
    20cc:	cd bf       	out	0x3d, r28	; 61
    20ce:	cf 91       	pop	r28
    20d0:	df 91       	pop	r29
    20d2:	1f 91       	pop	r17
    20d4:	0f 91       	pop	r16
    20d6:	08 95       	ret

000020d8 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    20d8:	0f 93       	push	r16
    20da:	1f 93       	push	r17
    20dc:	df 93       	push	r29
    20de:	cf 93       	push	r28
    20e0:	cd b7       	in	r28, 0x3d	; 61
    20e2:	de b7       	in	r29, 0x3e	; 62
    20e4:	27 97       	sbiw	r28, 0x07	; 7
    20e6:	0f b6       	in	r0, 0x3f	; 63
    20e8:	f8 94       	cli
    20ea:	de bf       	out	0x3e, r29	; 62
    20ec:	0f be       	out	0x3f, r0	; 63
    20ee:	cd bf       	out	0x3d, r28	; 61
    20f0:	89 83       	std	Y+1, r24	; 0x01
    20f2:	6a 83       	std	Y+2, r22	; 0x02
    20f4:	5c 83       	std	Y+4, r21	; 0x04
    20f6:	4b 83       	std	Y+3, r20	; 0x03
    20f8:	2d 83       	std	Y+5, r18	; 0x05
    20fa:	1f 83       	std	Y+7, r17	; 0x07
    20fc:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    20fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2100:	88 23       	and	r24, r24
    2102:	39 f4       	brne	.+14     	; 0x2112 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2104:	8e 81       	ldd	r24, Y+6	; 0x06
    2106:	9f 81       	ldd	r25, Y+7	; 0x07
    2108:	ee 81       	ldd	r30, Y+6	; 0x06
    210a:	ff 81       	ldd	r31, Y+7	; 0x07
    210c:	91 83       	std	Z+1, r25	; 0x01
    210e:	80 83       	st	Z, r24
    2110:	06 c0       	rjmp	.+12     	; 0x211e <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2112:	8b 81       	ldd	r24, Y+3	; 0x03
    2114:	9c 81       	ldd	r25, Y+4	; 0x04
    2116:	ee 81       	ldd	r30, Y+6	; 0x06
    2118:	ff 81       	ldd	r31, Y+7	; 0x07
    211a:	91 83       	std	Z+1, r25	; 0x01
    211c:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    211e:	ee 81       	ldd	r30, Y+6	; 0x06
    2120:	ff 81       	ldd	r31, Y+7	; 0x07
    2122:	89 81       	ldd	r24, Y+1	; 0x01
    2124:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    2126:	ee 81       	ldd	r30, Y+6	; 0x06
    2128:	ff 81       	ldd	r31, Y+7	; 0x07
    212a:	8a 81       	ldd	r24, Y+2	; 0x02
    212c:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    212e:	8e 81       	ldd	r24, Y+6	; 0x06
    2130:	9f 81       	ldd	r25, Y+7	; 0x07
    2132:	61 e0       	ldi	r22, 0x01	; 1
    2134:	0e 94 95 0f 	call	0x1f2a	; 0x1f2a <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    2138:	27 96       	adiw	r28, 0x07	; 7
    213a:	0f b6       	in	r0, 0x3f	; 63
    213c:	f8 94       	cli
    213e:	de bf       	out	0x3e, r29	; 62
    2140:	0f be       	out	0x3f, r0	; 63
    2142:	cd bf       	out	0x3d, r28	; 61
    2144:	cf 91       	pop	r28
    2146:	df 91       	pop	r29
    2148:	1f 91       	pop	r17
    214a:	0f 91       	pop	r16
    214c:	08 95       	ret

0000214e <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    214e:	df 93       	push	r29
    2150:	cf 93       	push	r28
    2152:	cd b7       	in	r28, 0x3d	; 61
    2154:	de b7       	in	r29, 0x3e	; 62
    2156:	2f 97       	sbiw	r28, 0x0f	; 15
    2158:	0f b6       	in	r0, 0x3f	; 63
    215a:	f8 94       	cli
    215c:	de bf       	out	0x3e, r29	; 62
    215e:	0f be       	out	0x3f, r0	; 63
    2160:	cd bf       	out	0x3d, r28	; 61
    2162:	99 87       	std	Y+9, r25	; 0x09
    2164:	88 87       	std	Y+8, r24	; 0x08
    2166:	7b 87       	std	Y+11, r23	; 0x0b
    2168:	6a 87       	std	Y+10, r22	; 0x0a
    216a:	5d 87       	std	Y+13, r21	; 0x0d
    216c:	4c 87       	std	Y+12, r20	; 0x0c
    216e:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2170:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2172:	88 85       	ldd	r24, Y+8	; 0x08
    2174:	99 85       	ldd	r25, Y+9	; 0x09
    2176:	9a 83       	std	Y+2, r25	; 0x02
    2178:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    217a:	0f b6       	in	r0, 0x3f	; 63
    217c:	f8 94       	cli
    217e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2180:	e9 81       	ldd	r30, Y+1	; 0x01
    2182:	fa 81       	ldd	r31, Y+2	; 0x02
    2184:	92 8d       	ldd	r25, Z+26	; 0x1a
    2186:	e9 81       	ldd	r30, Y+1	; 0x01
    2188:	fa 81       	ldd	r31, Y+2	; 0x02
    218a:	83 8d       	ldd	r24, Z+27	; 0x1b
    218c:	98 17       	cp	r25, r24
    218e:	18 f0       	brcs	.+6      	; 0x2196 <xQueueGenericSend+0x48>
    2190:	8e 85       	ldd	r24, Y+14	; 0x0e
    2192:	82 30       	cpi	r24, 0x02	; 2
    2194:	11 f5       	brne	.+68     	; 0x21da <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2196:	89 81       	ldd	r24, Y+1	; 0x01
    2198:	9a 81       	ldd	r25, Y+2	; 0x02
    219a:	2a 85       	ldd	r18, Y+10	; 0x0a
    219c:	3b 85       	ldd	r19, Y+11	; 0x0b
    219e:	b9 01       	movw	r22, r18
    21a0:	4e 85       	ldd	r20, Y+14	; 0x0e
    21a2:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <prvCopyDataToQueue>
    21a6:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    21a8:	e9 81       	ldd	r30, Y+1	; 0x01
    21aa:	fa 81       	ldd	r31, Y+2	; 0x02
    21ac:	81 89       	ldd	r24, Z+17	; 0x11
    21ae:	88 23       	and	r24, r24
    21b0:	51 f0       	breq	.+20     	; 0x21c6 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    21b2:	89 81       	ldd	r24, Y+1	; 0x01
    21b4:	9a 81       	ldd	r25, Y+2	; 0x02
    21b6:	41 96       	adiw	r24, 0x11	; 17
    21b8:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <xTaskRemoveFromEventList>
    21bc:	88 23       	and	r24, r24
    21be:	41 f0       	breq	.+16     	; 0x21d0 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    21c0:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
    21c4:	05 c0       	rjmp	.+10     	; 0x21d0 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    21c6:	8b 81       	ldd	r24, Y+3	; 0x03
    21c8:	88 23       	and	r24, r24
    21ca:	11 f0       	breq	.+4      	; 0x21d0 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    21cc:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    21d0:	0f 90       	pop	r0
    21d2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	8f 87       	std	Y+15, r24	; 0x0f
    21d8:	5c c0       	rjmp	.+184    	; 0x2292 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    21da:	8c 85       	ldd	r24, Y+12	; 0x0c
    21dc:	9d 85       	ldd	r25, Y+13	; 0x0d
    21de:	00 97       	sbiw	r24, 0x00	; 0
    21e0:	21 f4       	brne	.+8      	; 0x21ea <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    21e2:	0f 90       	pop	r0
    21e4:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    21e6:	1f 86       	std	Y+15, r1	; 0x0f
    21e8:	54 c0       	rjmp	.+168    	; 0x2292 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    21ea:	8c 81       	ldd	r24, Y+4	; 0x04
    21ec:	88 23       	and	r24, r24
    21ee:	31 f4       	brne	.+12     	; 0x21fc <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    21f0:	ce 01       	movw	r24, r28
    21f2:	05 96       	adiw	r24, 0x05	; 5
    21f4:	0e 94 bb 1c 	call	0x3976	; 0x3976 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    21f8:	81 e0       	ldi	r24, 0x01	; 1
    21fa:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    21fc:	0f 90       	pop	r0
    21fe:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2200:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2204:	0f b6       	in	r0, 0x3f	; 63
    2206:	f8 94       	cli
    2208:	0f 92       	push	r0
    220a:	e9 81       	ldd	r30, Y+1	; 0x01
    220c:	fa 81       	ldd	r31, Y+2	; 0x02
    220e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2210:	8f 3f       	cpi	r24, 0xFF	; 255
    2212:	19 f4       	brne	.+6      	; 0x221a <xQueueGenericSend+0xcc>
    2214:	e9 81       	ldd	r30, Y+1	; 0x01
    2216:	fa 81       	ldd	r31, Y+2	; 0x02
    2218:	15 8e       	std	Z+29, r1	; 0x1d
    221a:	e9 81       	ldd	r30, Y+1	; 0x01
    221c:	fa 81       	ldd	r31, Y+2	; 0x02
    221e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2220:	8f 3f       	cpi	r24, 0xFF	; 255
    2222:	19 f4       	brne	.+6      	; 0x222a <xQueueGenericSend+0xdc>
    2224:	e9 81       	ldd	r30, Y+1	; 0x01
    2226:	fa 81       	ldd	r31, Y+2	; 0x02
    2228:	16 8e       	std	Z+30, r1	; 0x1e
    222a:	0f 90       	pop	r0
    222c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    222e:	ce 01       	movw	r24, r28
    2230:	05 96       	adiw	r24, 0x05	; 5
    2232:	9e 01       	movw	r18, r28
    2234:	24 5f       	subi	r18, 0xF4	; 244
    2236:	3f 4f       	sbci	r19, 0xFF	; 255
    2238:	b9 01       	movw	r22, r18
    223a:	0e 94 d4 1c 	call	0x39a8	; 0x39a8 <xTaskCheckForTimeOut>
    223e:	88 23       	and	r24, r24
    2240:	09 f5       	brne	.+66     	; 0x2284 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2242:	89 81       	ldd	r24, Y+1	; 0x01
    2244:	9a 81       	ldd	r25, Y+2	; 0x02
    2246:	0e 94 75 16 	call	0x2cea	; 0x2cea <prvIsQueueFull>
    224a:	88 23       	and	r24, r24
    224c:	a1 f0       	breq	.+40     	; 0x2276 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    224e:	89 81       	ldd	r24, Y+1	; 0x01
    2250:	9a 81       	ldd	r25, Y+2	; 0x02
    2252:	08 96       	adiw	r24, 0x08	; 8
    2254:	2c 85       	ldd	r18, Y+12	; 0x0c
    2256:	3d 85       	ldd	r19, Y+13	; 0x0d
    2258:	b9 01       	movw	r22, r18
    225a:	0e 94 83 1b 	call	0x3706	; 0x3706 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    225e:	89 81       	ldd	r24, Y+1	; 0x01
    2260:	9a 81       	ldd	r25, Y+2	; 0x02
    2262:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2266:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    226a:	88 23       	and	r24, r24
    226c:	09 f0       	breq	.+2      	; 0x2270 <xQueueGenericSend+0x122>
    226e:	85 cf       	rjmp	.-246    	; 0x217a <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2270:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
    2274:	82 cf       	rjmp	.-252    	; 0x217a <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2276:	89 81       	ldd	r24, Y+1	; 0x01
    2278:	9a 81       	ldd	r25, Y+2	; 0x02
    227a:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    227e:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    2282:	7b cf       	rjmp	.-266    	; 0x217a <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2284:	89 81       	ldd	r24, Y+1	; 0x01
    2286:	9a 81       	ldd	r25, Y+2	; 0x02
    2288:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    228c:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2290:	1f 86       	std	Y+15, r1	; 0x0f
    2292:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    2294:	2f 96       	adiw	r28, 0x0f	; 15
    2296:	0f b6       	in	r0, 0x3f	; 63
    2298:	f8 94       	cli
    229a:	de bf       	out	0x3e, r29	; 62
    229c:	0f be       	out	0x3f, r0	; 63
    229e:	cd bf       	out	0x3d, r28	; 61
    22a0:	cf 91       	pop	r28
    22a2:	df 91       	pop	r29
    22a4:	08 95       	ret

000022a6 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    22a6:	df 93       	push	r29
    22a8:	cf 93       	push	r28
    22aa:	cd b7       	in	r28, 0x3d	; 61
    22ac:	de b7       	in	r29, 0x3e	; 62
    22ae:	2c 97       	sbiw	r28, 0x0c	; 12
    22b0:	0f b6       	in	r0, 0x3f	; 63
    22b2:	f8 94       	cli
    22b4:	de bf       	out	0x3e, r29	; 62
    22b6:	0f be       	out	0x3f, r0	; 63
    22b8:	cd bf       	out	0x3d, r28	; 61
    22ba:	9f 83       	std	Y+7, r25	; 0x07
    22bc:	8e 83       	std	Y+6, r24	; 0x06
    22be:	79 87       	std	Y+9, r23	; 0x09
    22c0:	68 87       	std	Y+8, r22	; 0x08
    22c2:	5b 87       	std	Y+11, r21	; 0x0b
    22c4:	4a 87       	std	Y+10, r20	; 0x0a
    22c6:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    22c8:	8e 81       	ldd	r24, Y+6	; 0x06
    22ca:	9f 81       	ldd	r25, Y+7	; 0x07
    22cc:	9b 83       	std	Y+3, r25	; 0x03
    22ce:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    22d0:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    22d2:	ea 81       	ldd	r30, Y+2	; 0x02
    22d4:	fb 81       	ldd	r31, Y+3	; 0x03
    22d6:	92 8d       	ldd	r25, Z+26	; 0x1a
    22d8:	ea 81       	ldd	r30, Y+2	; 0x02
    22da:	fb 81       	ldd	r31, Y+3	; 0x03
    22dc:	83 8d       	ldd	r24, Z+27	; 0x1b
    22de:	98 17       	cp	r25, r24
    22e0:	18 f0       	brcs	.+6      	; 0x22e8 <xQueueGenericSendFromISR+0x42>
    22e2:	8c 85       	ldd	r24, Y+12	; 0x0c
    22e4:	82 30       	cpi	r24, 0x02	; 2
    22e6:	61 f5       	brne	.+88     	; 0x2340 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    22e8:	ea 81       	ldd	r30, Y+2	; 0x02
    22ea:	fb 81       	ldd	r31, Y+3	; 0x03
    22ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    22ee:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    22f0:	8a 81       	ldd	r24, Y+2	; 0x02
    22f2:	9b 81       	ldd	r25, Y+3	; 0x03
    22f4:	28 85       	ldd	r18, Y+8	; 0x08
    22f6:	39 85       	ldd	r19, Y+9	; 0x09
    22f8:	b9 01       	movw	r22, r18
    22fa:	4c 85       	ldd	r20, Y+12	; 0x0c
    22fc:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2300:	89 81       	ldd	r24, Y+1	; 0x01
    2302:	8f 3f       	cpi	r24, 0xFF	; 255
    2304:	a9 f4       	brne	.+42     	; 0x2330 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2306:	ea 81       	ldd	r30, Y+2	; 0x02
    2308:	fb 81       	ldd	r31, Y+3	; 0x03
    230a:	81 89       	ldd	r24, Z+17	; 0x11
    230c:	88 23       	and	r24, r24
    230e:	a9 f0       	breq	.+42     	; 0x233a <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2310:	8a 81       	ldd	r24, Y+2	; 0x02
    2312:	9b 81       	ldd	r25, Y+3	; 0x03
    2314:	41 96       	adiw	r24, 0x11	; 17
    2316:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <xTaskRemoveFromEventList>
    231a:	88 23       	and	r24, r24
    231c:	71 f0       	breq	.+28     	; 0x233a <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    231e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2320:	9b 85       	ldd	r25, Y+11	; 0x0b
    2322:	00 97       	sbiw	r24, 0x00	; 0
    2324:	51 f0       	breq	.+20     	; 0x233a <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2326:	ea 85       	ldd	r30, Y+10	; 0x0a
    2328:	fb 85       	ldd	r31, Y+11	; 0x0b
    232a:	81 e0       	ldi	r24, 0x01	; 1
    232c:	80 83       	st	Z, r24
    232e:	05 c0       	rjmp	.+10     	; 0x233a <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2330:	89 81       	ldd	r24, Y+1	; 0x01
    2332:	8f 5f       	subi	r24, 0xFF	; 255
    2334:	ea 81       	ldd	r30, Y+2	; 0x02
    2336:	fb 81       	ldd	r31, Y+3	; 0x03
    2338:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    233a:	81 e0       	ldi	r24, 0x01	; 1
    233c:	8d 83       	std	Y+5, r24	; 0x05
    233e:	01 c0       	rjmp	.+2      	; 0x2342 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2340:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2342:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2344:	2c 96       	adiw	r28, 0x0c	; 12
    2346:	0f b6       	in	r0, 0x3f	; 63
    2348:	f8 94       	cli
    234a:	de bf       	out	0x3e, r29	; 62
    234c:	0f be       	out	0x3f, r0	; 63
    234e:	cd bf       	out	0x3d, r28	; 61
    2350:	cf 91       	pop	r28
    2352:	df 91       	pop	r29
    2354:	08 95       	ret

00002356 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2356:	df 93       	push	r29
    2358:	cf 93       	push	r28
    235a:	cd b7       	in	r28, 0x3d	; 61
    235c:	de b7       	in	r29, 0x3e	; 62
    235e:	2a 97       	sbiw	r28, 0x0a	; 10
    2360:	0f b6       	in	r0, 0x3f	; 63
    2362:	f8 94       	cli
    2364:	de bf       	out	0x3e, r29	; 62
    2366:	0f be       	out	0x3f, r0	; 63
    2368:	cd bf       	out	0x3d, r28	; 61
    236a:	98 87       	std	Y+8, r25	; 0x08
    236c:	8f 83       	std	Y+7, r24	; 0x07
    236e:	7a 87       	std	Y+10, r23	; 0x0a
    2370:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2372:	8f 81       	ldd	r24, Y+7	; 0x07
    2374:	98 85       	ldd	r25, Y+8	; 0x08
    2376:	9c 83       	std	Y+4, r25	; 0x04
    2378:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    237a:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    237c:	eb 81       	ldd	r30, Y+3	; 0x03
    237e:	fc 81       	ldd	r31, Y+4	; 0x04
    2380:	82 8d       	ldd	r24, Z+26	; 0x1a
    2382:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    2384:	eb 81       	ldd	r30, Y+3	; 0x03
    2386:	fc 81       	ldd	r31, Y+4	; 0x04
    2388:	93 8d       	ldd	r25, Z+27	; 0x1b
    238a:	8a 81       	ldd	r24, Y+2	; 0x02
    238c:	89 17       	cp	r24, r25
    238e:	48 f5       	brcc	.+82     	; 0x23e2 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2390:	eb 81       	ldd	r30, Y+3	; 0x03
    2392:	fc 81       	ldd	r31, Y+4	; 0x04
    2394:	86 8d       	ldd	r24, Z+30	; 0x1e
    2396:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2398:	8a 81       	ldd	r24, Y+2	; 0x02
    239a:	8f 5f       	subi	r24, 0xFF	; 255
    239c:	eb 81       	ldd	r30, Y+3	; 0x03
    239e:	fc 81       	ldd	r31, Y+4	; 0x04
    23a0:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    23a2:	89 81       	ldd	r24, Y+1	; 0x01
    23a4:	8f 3f       	cpi	r24, 0xFF	; 255
    23a6:	a9 f4       	brne	.+42     	; 0x23d2 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23a8:	eb 81       	ldd	r30, Y+3	; 0x03
    23aa:	fc 81       	ldd	r31, Y+4	; 0x04
    23ac:	81 89       	ldd	r24, Z+17	; 0x11
    23ae:	88 23       	and	r24, r24
    23b0:	a9 f0       	breq	.+42     	; 0x23dc <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23b2:	8b 81       	ldd	r24, Y+3	; 0x03
    23b4:	9c 81       	ldd	r25, Y+4	; 0x04
    23b6:	41 96       	adiw	r24, 0x11	; 17
    23b8:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <xTaskRemoveFromEventList>
    23bc:	88 23       	and	r24, r24
    23be:	71 f0       	breq	.+28     	; 0x23dc <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    23c0:	89 85       	ldd	r24, Y+9	; 0x09
    23c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    23c4:	00 97       	sbiw	r24, 0x00	; 0
    23c6:	51 f0       	breq	.+20     	; 0x23dc <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    23c8:	e9 85       	ldd	r30, Y+9	; 0x09
    23ca:	fa 85       	ldd	r31, Y+10	; 0x0a
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	80 83       	st	Z, r24
    23d0:	05 c0       	rjmp	.+10     	; 0x23dc <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    23d2:	89 81       	ldd	r24, Y+1	; 0x01
    23d4:	8f 5f       	subi	r24, 0xFF	; 255
    23d6:	eb 81       	ldd	r30, Y+3	; 0x03
    23d8:	fc 81       	ldd	r31, Y+4	; 0x04
    23da:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    23dc:	81 e0       	ldi	r24, 0x01	; 1
    23de:	8e 83       	std	Y+6, r24	; 0x06
    23e0:	01 c0       	rjmp	.+2      	; 0x23e4 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    23e2:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    23e4:	8e 81       	ldd	r24, Y+6	; 0x06
}
    23e6:	2a 96       	adiw	r28, 0x0a	; 10
    23e8:	0f b6       	in	r0, 0x3f	; 63
    23ea:	f8 94       	cli
    23ec:	de bf       	out	0x3e, r29	; 62
    23ee:	0f be       	out	0x3f, r0	; 63
    23f0:	cd bf       	out	0x3d, r28	; 61
    23f2:	cf 91       	pop	r28
    23f4:	df 91       	pop	r29
    23f6:	08 95       	ret

000023f8 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    23f8:	df 93       	push	r29
    23fa:	cf 93       	push	r28
    23fc:	cd b7       	in	r28, 0x3d	; 61
    23fe:	de b7       	in	r29, 0x3e	; 62
    2400:	2e 97       	sbiw	r28, 0x0e	; 14
    2402:	0f b6       	in	r0, 0x3f	; 63
    2404:	f8 94       	cli
    2406:	de bf       	out	0x3e, r29	; 62
    2408:	0f be       	out	0x3f, r0	; 63
    240a:	cd bf       	out	0x3d, r28	; 61
    240c:	99 87       	std	Y+9, r25	; 0x09
    240e:	88 87       	std	Y+8, r24	; 0x08
    2410:	7b 87       	std	Y+11, r23	; 0x0b
    2412:	6a 87       	std	Y+10, r22	; 0x0a
    2414:	5d 87       	std	Y+13, r21	; 0x0d
    2416:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    2418:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    241a:	88 85       	ldd	r24, Y+8	; 0x08
    241c:	99 85       	ldd	r25, Y+9	; 0x09
    241e:	9b 83       	std	Y+3, r25	; 0x03
    2420:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2422:	0f b6       	in	r0, 0x3f	; 63
    2424:	f8 94       	cli
    2426:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2428:	ea 81       	ldd	r30, Y+2	; 0x02
    242a:	fb 81       	ldd	r31, Y+3	; 0x03
    242c:	82 8d       	ldd	r24, Z+26	; 0x1a
    242e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2430:	89 81       	ldd	r24, Y+1	; 0x01
    2432:	88 23       	and	r24, r24
    2434:	f9 f0       	breq	.+62     	; 0x2474 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2436:	8a 81       	ldd	r24, Y+2	; 0x02
    2438:	9b 81       	ldd	r25, Y+3	; 0x03
    243a:	2a 85       	ldd	r18, Y+10	; 0x0a
    243c:	3b 85       	ldd	r19, Y+11	; 0x0b
    243e:	b9 01       	movw	r22, r18
    2440:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2444:	89 81       	ldd	r24, Y+1	; 0x01
    2446:	81 50       	subi	r24, 0x01	; 1
    2448:	ea 81       	ldd	r30, Y+2	; 0x02
    244a:	fb 81       	ldd	r31, Y+3	; 0x03
    244c:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    244e:	ea 81       	ldd	r30, Y+2	; 0x02
    2450:	fb 81       	ldd	r31, Y+3	; 0x03
    2452:	80 85       	ldd	r24, Z+8	; 0x08
    2454:	88 23       	and	r24, r24
    2456:	49 f0       	breq	.+18     	; 0x246a <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2458:	8a 81       	ldd	r24, Y+2	; 0x02
    245a:	9b 81       	ldd	r25, Y+3	; 0x03
    245c:	08 96       	adiw	r24, 0x08	; 8
    245e:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <xTaskRemoveFromEventList>
    2462:	88 23       	and	r24, r24
    2464:	11 f0       	breq	.+4      	; 0x246a <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2466:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    246a:	0f 90       	pop	r0
    246c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    246e:	81 e0       	ldi	r24, 0x01	; 1
    2470:	8e 87       	std	Y+14, r24	; 0x0e
    2472:	63 c0       	rjmp	.+198    	; 0x253a <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2474:	8c 85       	ldd	r24, Y+12	; 0x0c
    2476:	9d 85       	ldd	r25, Y+13	; 0x0d
    2478:	00 97       	sbiw	r24, 0x00	; 0
    247a:	21 f4       	brne	.+8      	; 0x2484 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    247c:	0f 90       	pop	r0
    247e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2480:	1e 86       	std	Y+14, r1	; 0x0e
    2482:	5b c0       	rjmp	.+182    	; 0x253a <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    2484:	8c 81       	ldd	r24, Y+4	; 0x04
    2486:	88 23       	and	r24, r24
    2488:	31 f4       	brne	.+12     	; 0x2496 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    248a:	ce 01       	movw	r24, r28
    248c:	05 96       	adiw	r24, 0x05	; 5
    248e:	0e 94 bb 1c 	call	0x3976	; 0x3976 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2492:	81 e0       	ldi	r24, 0x01	; 1
    2494:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2496:	0f 90       	pop	r0
    2498:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    249a:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    249e:	0f b6       	in	r0, 0x3f	; 63
    24a0:	f8 94       	cli
    24a2:	0f 92       	push	r0
    24a4:	ea 81       	ldd	r30, Y+2	; 0x02
    24a6:	fb 81       	ldd	r31, Y+3	; 0x03
    24a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    24aa:	8f 3f       	cpi	r24, 0xFF	; 255
    24ac:	19 f4       	brne	.+6      	; 0x24b4 <xQueueReceive+0xbc>
    24ae:	ea 81       	ldd	r30, Y+2	; 0x02
    24b0:	fb 81       	ldd	r31, Y+3	; 0x03
    24b2:	15 8e       	std	Z+29, r1	; 0x1d
    24b4:	ea 81       	ldd	r30, Y+2	; 0x02
    24b6:	fb 81       	ldd	r31, Y+3	; 0x03
    24b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    24ba:	8f 3f       	cpi	r24, 0xFF	; 255
    24bc:	19 f4       	brne	.+6      	; 0x24c4 <xQueueReceive+0xcc>
    24be:	ea 81       	ldd	r30, Y+2	; 0x02
    24c0:	fb 81       	ldd	r31, Y+3	; 0x03
    24c2:	16 8e       	std	Z+30, r1	; 0x1e
    24c4:	0f 90       	pop	r0
    24c6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    24c8:	ce 01       	movw	r24, r28
    24ca:	05 96       	adiw	r24, 0x05	; 5
    24cc:	9e 01       	movw	r18, r28
    24ce:	24 5f       	subi	r18, 0xF4	; 244
    24d0:	3f 4f       	sbci	r19, 0xFF	; 255
    24d2:	b9 01       	movw	r22, r18
    24d4:	0e 94 d4 1c 	call	0x39a8	; 0x39a8 <xTaskCheckForTimeOut>
    24d8:	88 23       	and	r24, r24
    24da:	09 f5       	brne	.+66     	; 0x251e <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    24dc:	8a 81       	ldd	r24, Y+2	; 0x02
    24de:	9b 81       	ldd	r25, Y+3	; 0x03
    24e0:	0e 94 39 16 	call	0x2c72	; 0x2c72 <prvIsQueueEmpty>
    24e4:	88 23       	and	r24, r24
    24e6:	a1 f0       	breq	.+40     	; 0x2510 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    24e8:	8a 81       	ldd	r24, Y+2	; 0x02
    24ea:	9b 81       	ldd	r25, Y+3	; 0x03
    24ec:	41 96       	adiw	r24, 0x11	; 17
    24ee:	2c 85       	ldd	r18, Y+12	; 0x0c
    24f0:	3d 85       	ldd	r19, Y+13	; 0x0d
    24f2:	b9 01       	movw	r22, r18
    24f4:	0e 94 83 1b 	call	0x3706	; 0x3706 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    24f8:	8a 81       	ldd	r24, Y+2	; 0x02
    24fa:	9b 81       	ldd	r25, Y+3	; 0x03
    24fc:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2500:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    2504:	88 23       	and	r24, r24
    2506:	09 f0       	breq	.+2      	; 0x250a <xQueueReceive+0x112>
    2508:	8c cf       	rjmp	.-232    	; 0x2422 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    250a:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
    250e:	89 cf       	rjmp	.-238    	; 0x2422 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    2510:	8a 81       	ldd	r24, Y+2	; 0x02
    2512:	9b 81       	ldd	r25, Y+3	; 0x03
    2514:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2518:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    251c:	82 cf       	rjmp	.-252    	; 0x2422 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    251e:	8a 81       	ldd	r24, Y+2	; 0x02
    2520:	9b 81       	ldd	r25, Y+3	; 0x03
    2522:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2526:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    252a:	8a 81       	ldd	r24, Y+2	; 0x02
    252c:	9b 81       	ldd	r25, Y+3	; 0x03
    252e:	0e 94 39 16 	call	0x2c72	; 0x2c72 <prvIsQueueEmpty>
    2532:	88 23       	and	r24, r24
    2534:	09 f4       	brne	.+2      	; 0x2538 <xQueueReceive+0x140>
    2536:	75 cf       	rjmp	.-278    	; 0x2422 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2538:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    253a:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    253c:	2e 96       	adiw	r28, 0x0e	; 14
    253e:	0f b6       	in	r0, 0x3f	; 63
    2540:	f8 94       	cli
    2542:	de bf       	out	0x3e, r29	; 62
    2544:	0f be       	out	0x3f, r0	; 63
    2546:	cd bf       	out	0x3d, r28	; 61
    2548:	cf 91       	pop	r28
    254a:	df 91       	pop	r29
    254c:	08 95       	ret

0000254e <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    254e:	df 93       	push	r29
    2550:	cf 93       	push	r28
    2552:	cd b7       	in	r28, 0x3d	; 61
    2554:	de b7       	in	r29, 0x3e	; 62
    2556:	2c 97       	sbiw	r28, 0x0c	; 12
    2558:	0f b6       	in	r0, 0x3f	; 63
    255a:	f8 94       	cli
    255c:	de bf       	out	0x3e, r29	; 62
    255e:	0f be       	out	0x3f, r0	; 63
    2560:	cd bf       	out	0x3d, r28	; 61
    2562:	99 87       	std	Y+9, r25	; 0x09
    2564:	88 87       	std	Y+8, r24	; 0x08
    2566:	7b 87       	std	Y+11, r23	; 0x0b
    2568:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    256a:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    256c:	88 85       	ldd	r24, Y+8	; 0x08
    256e:	99 85       	ldd	r25, Y+9	; 0x09
    2570:	9b 83       	std	Y+3, r25	; 0x03
    2572:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2574:	0f b6       	in	r0, 0x3f	; 63
    2576:	f8 94       	cli
    2578:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    257a:	ea 81       	ldd	r30, Y+2	; 0x02
    257c:	fb 81       	ldd	r31, Y+3	; 0x03
    257e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2580:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2582:	89 81       	ldd	r24, Y+1	; 0x01
    2584:	88 23       	and	r24, r24
    2586:	c1 f0       	breq	.+48     	; 0x25b8 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2588:	89 81       	ldd	r24, Y+1	; 0x01
    258a:	81 50       	subi	r24, 0x01	; 1
    258c:	ea 81       	ldd	r30, Y+2	; 0x02
    258e:	fb 81       	ldd	r31, Y+3	; 0x03
    2590:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2592:	ea 81       	ldd	r30, Y+2	; 0x02
    2594:	fb 81       	ldd	r31, Y+3	; 0x03
    2596:	80 85       	ldd	r24, Z+8	; 0x08
    2598:	88 23       	and	r24, r24
    259a:	49 f0       	breq	.+18     	; 0x25ae <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    259c:	8a 81       	ldd	r24, Y+2	; 0x02
    259e:	9b 81       	ldd	r25, Y+3	; 0x03
    25a0:	08 96       	adiw	r24, 0x08	; 8
    25a2:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <xTaskRemoveFromEventList>
    25a6:	88 23       	and	r24, r24
    25a8:	11 f0       	breq	.+4      	; 0x25ae <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    25aa:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    25ae:	0f 90       	pop	r0
    25b0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    25b2:	81 e0       	ldi	r24, 0x01	; 1
    25b4:	8c 87       	std	Y+12, r24	; 0x0c
    25b6:	63 c0       	rjmp	.+198    	; 0x267e <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    25b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    25ba:	9b 85       	ldd	r25, Y+11	; 0x0b
    25bc:	00 97       	sbiw	r24, 0x00	; 0
    25be:	21 f4       	brne	.+8      	; 0x25c8 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    25c0:	0f 90       	pop	r0
    25c2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    25c4:	1c 86       	std	Y+12, r1	; 0x0c
    25c6:	5b c0       	rjmp	.+182    	; 0x267e <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    25c8:	8c 81       	ldd	r24, Y+4	; 0x04
    25ca:	88 23       	and	r24, r24
    25cc:	31 f4       	brne	.+12     	; 0x25da <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    25ce:	ce 01       	movw	r24, r28
    25d0:	05 96       	adiw	r24, 0x05	; 5
    25d2:	0e 94 bb 1c 	call	0x3976	; 0x3976 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    25d6:	81 e0       	ldi	r24, 0x01	; 1
    25d8:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    25da:	0f 90       	pop	r0
    25dc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    25de:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    25e2:	0f b6       	in	r0, 0x3f	; 63
    25e4:	f8 94       	cli
    25e6:	0f 92       	push	r0
    25e8:	ea 81       	ldd	r30, Y+2	; 0x02
    25ea:	fb 81       	ldd	r31, Y+3	; 0x03
    25ec:	85 8d       	ldd	r24, Z+29	; 0x1d
    25ee:	8f 3f       	cpi	r24, 0xFF	; 255
    25f0:	19 f4       	brne	.+6      	; 0x25f8 <xQueueSemaphoreTake+0xaa>
    25f2:	ea 81       	ldd	r30, Y+2	; 0x02
    25f4:	fb 81       	ldd	r31, Y+3	; 0x03
    25f6:	15 8e       	std	Z+29, r1	; 0x1d
    25f8:	ea 81       	ldd	r30, Y+2	; 0x02
    25fa:	fb 81       	ldd	r31, Y+3	; 0x03
    25fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    25fe:	8f 3f       	cpi	r24, 0xFF	; 255
    2600:	19 f4       	brne	.+6      	; 0x2608 <xQueueSemaphoreTake+0xba>
    2602:	ea 81       	ldd	r30, Y+2	; 0x02
    2604:	fb 81       	ldd	r31, Y+3	; 0x03
    2606:	16 8e       	std	Z+30, r1	; 0x1e
    2608:	0f 90       	pop	r0
    260a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    260c:	ce 01       	movw	r24, r28
    260e:	05 96       	adiw	r24, 0x05	; 5
    2610:	9e 01       	movw	r18, r28
    2612:	26 5f       	subi	r18, 0xF6	; 246
    2614:	3f 4f       	sbci	r19, 0xFF	; 255
    2616:	b9 01       	movw	r22, r18
    2618:	0e 94 d4 1c 	call	0x39a8	; 0x39a8 <xTaskCheckForTimeOut>
    261c:	88 23       	and	r24, r24
    261e:	09 f5       	brne	.+66     	; 0x2662 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2620:	8a 81       	ldd	r24, Y+2	; 0x02
    2622:	9b 81       	ldd	r25, Y+3	; 0x03
    2624:	0e 94 39 16 	call	0x2c72	; 0x2c72 <prvIsQueueEmpty>
    2628:	88 23       	and	r24, r24
    262a:	a1 f0       	breq	.+40     	; 0x2654 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    262c:	8a 81       	ldd	r24, Y+2	; 0x02
    262e:	9b 81       	ldd	r25, Y+3	; 0x03
    2630:	41 96       	adiw	r24, 0x11	; 17
    2632:	2a 85       	ldd	r18, Y+10	; 0x0a
    2634:	3b 85       	ldd	r19, Y+11	; 0x0b
    2636:	b9 01       	movw	r22, r18
    2638:	0e 94 83 1b 	call	0x3706	; 0x3706 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    263c:	8a 81       	ldd	r24, Y+2	; 0x02
    263e:	9b 81       	ldd	r25, Y+3	; 0x03
    2640:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2644:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    2648:	88 23       	and	r24, r24
    264a:	09 f0       	breq	.+2      	; 0x264e <xQueueSemaphoreTake+0x100>
    264c:	93 cf       	rjmp	.-218    	; 0x2574 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    264e:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
    2652:	90 cf       	rjmp	.-224    	; 0x2574 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    2654:	8a 81       	ldd	r24, Y+2	; 0x02
    2656:	9b 81       	ldd	r25, Y+3	; 0x03
    2658:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    265c:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    2660:	89 cf       	rjmp	.-238    	; 0x2574 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2662:	8a 81       	ldd	r24, Y+2	; 0x02
    2664:	9b 81       	ldd	r25, Y+3	; 0x03
    2666:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    266a:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    266e:	8a 81       	ldd	r24, Y+2	; 0x02
    2670:	9b 81       	ldd	r25, Y+3	; 0x03
    2672:	0e 94 39 16 	call	0x2c72	; 0x2c72 <prvIsQueueEmpty>
    2676:	88 23       	and	r24, r24
    2678:	09 f4       	brne	.+2      	; 0x267c <xQueueSemaphoreTake+0x12e>
    267a:	7c cf       	rjmp	.-264    	; 0x2574 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    267c:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    267e:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2680:	2c 96       	adiw	r28, 0x0c	; 12
    2682:	0f b6       	in	r0, 0x3f	; 63
    2684:	f8 94       	cli
    2686:	de bf       	out	0x3e, r29	; 62
    2688:	0f be       	out	0x3f, r0	; 63
    268a:	cd bf       	out	0x3d, r28	; 61
    268c:	cf 91       	pop	r28
    268e:	df 91       	pop	r29
    2690:	08 95       	ret

00002692 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2692:	df 93       	push	r29
    2694:	cf 93       	push	r28
    2696:	cd b7       	in	r28, 0x3d	; 61
    2698:	de b7       	in	r29, 0x3e	; 62
    269a:	60 97       	sbiw	r28, 0x10	; 16
    269c:	0f b6       	in	r0, 0x3f	; 63
    269e:	f8 94       	cli
    26a0:	de bf       	out	0x3e, r29	; 62
    26a2:	0f be       	out	0x3f, r0	; 63
    26a4:	cd bf       	out	0x3d, r28	; 61
    26a6:	9b 87       	std	Y+11, r25	; 0x0b
    26a8:	8a 87       	std	Y+10, r24	; 0x0a
    26aa:	7d 87       	std	Y+13, r23	; 0x0d
    26ac:	6c 87       	std	Y+12, r22	; 0x0c
    26ae:	5f 87       	std	Y+15, r21	; 0x0f
    26b0:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    26b2:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    26b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    26b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    26b8:	9b 83       	std	Y+3, r25	; 0x03
    26ba:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    26bc:	0f b6       	in	r0, 0x3f	; 63
    26be:	f8 94       	cli
    26c0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    26c2:	ea 81       	ldd	r30, Y+2	; 0x02
    26c4:	fb 81       	ldd	r31, Y+3	; 0x03
    26c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    26c8:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    26ca:	89 81       	ldd	r24, Y+1	; 0x01
    26cc:	88 23       	and	r24, r24
    26ce:	31 f1       	breq	.+76     	; 0x271c <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    26d0:	ea 81       	ldd	r30, Y+2	; 0x02
    26d2:	fb 81       	ldd	r31, Y+3	; 0x03
    26d4:	86 81       	ldd	r24, Z+6	; 0x06
    26d6:	97 81       	ldd	r25, Z+7	; 0x07
    26d8:	9d 83       	std	Y+5, r25	; 0x05
    26da:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    26dc:	8a 81       	ldd	r24, Y+2	; 0x02
    26de:	9b 81       	ldd	r25, Y+3	; 0x03
    26e0:	2c 85       	ldd	r18, Y+12	; 0x0c
    26e2:	3d 85       	ldd	r19, Y+13	; 0x0d
    26e4:	b9 01       	movw	r22, r18
    26e6:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    26ea:	ea 81       	ldd	r30, Y+2	; 0x02
    26ec:	fb 81       	ldd	r31, Y+3	; 0x03
    26ee:	8c 81       	ldd	r24, Y+4	; 0x04
    26f0:	9d 81       	ldd	r25, Y+5	; 0x05
    26f2:	97 83       	std	Z+7, r25	; 0x07
    26f4:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26f6:	ea 81       	ldd	r30, Y+2	; 0x02
    26f8:	fb 81       	ldd	r31, Y+3	; 0x03
    26fa:	81 89       	ldd	r24, Z+17	; 0x11
    26fc:	88 23       	and	r24, r24
    26fe:	49 f0       	breq	.+18     	; 0x2712 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2700:	8a 81       	ldd	r24, Y+2	; 0x02
    2702:	9b 81       	ldd	r25, Y+3	; 0x03
    2704:	41 96       	adiw	r24, 0x11	; 17
    2706:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <xTaskRemoveFromEventList>
    270a:	88 23       	and	r24, r24
    270c:	11 f0       	breq	.+4      	; 0x2712 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    270e:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2712:	0f 90       	pop	r0
    2714:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2716:	81 e0       	ldi	r24, 0x01	; 1
    2718:	88 8b       	std	Y+16, r24	; 0x10
    271a:	63 c0       	rjmp	.+198    	; 0x27e2 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    271c:	8e 85       	ldd	r24, Y+14	; 0x0e
    271e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2720:	00 97       	sbiw	r24, 0x00	; 0
    2722:	21 f4       	brne	.+8      	; 0x272c <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2724:	0f 90       	pop	r0
    2726:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2728:	18 8a       	std	Y+16, r1	; 0x10
    272a:	5b c0       	rjmp	.+182    	; 0x27e2 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    272c:	8e 81       	ldd	r24, Y+6	; 0x06
    272e:	88 23       	and	r24, r24
    2730:	31 f4       	brne	.+12     	; 0x273e <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2732:	ce 01       	movw	r24, r28
    2734:	07 96       	adiw	r24, 0x07	; 7
    2736:	0e 94 bb 1c 	call	0x3976	; 0x3976 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    273a:	81 e0       	ldi	r24, 0x01	; 1
    273c:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    273e:	0f 90       	pop	r0
    2740:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2742:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2746:	0f b6       	in	r0, 0x3f	; 63
    2748:	f8 94       	cli
    274a:	0f 92       	push	r0
    274c:	ea 81       	ldd	r30, Y+2	; 0x02
    274e:	fb 81       	ldd	r31, Y+3	; 0x03
    2750:	85 8d       	ldd	r24, Z+29	; 0x1d
    2752:	8f 3f       	cpi	r24, 0xFF	; 255
    2754:	19 f4       	brne	.+6      	; 0x275c <xQueuePeek+0xca>
    2756:	ea 81       	ldd	r30, Y+2	; 0x02
    2758:	fb 81       	ldd	r31, Y+3	; 0x03
    275a:	15 8e       	std	Z+29, r1	; 0x1d
    275c:	ea 81       	ldd	r30, Y+2	; 0x02
    275e:	fb 81       	ldd	r31, Y+3	; 0x03
    2760:	86 8d       	ldd	r24, Z+30	; 0x1e
    2762:	8f 3f       	cpi	r24, 0xFF	; 255
    2764:	19 f4       	brne	.+6      	; 0x276c <xQueuePeek+0xda>
    2766:	ea 81       	ldd	r30, Y+2	; 0x02
    2768:	fb 81       	ldd	r31, Y+3	; 0x03
    276a:	16 8e       	std	Z+30, r1	; 0x1e
    276c:	0f 90       	pop	r0
    276e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2770:	ce 01       	movw	r24, r28
    2772:	07 96       	adiw	r24, 0x07	; 7
    2774:	9e 01       	movw	r18, r28
    2776:	22 5f       	subi	r18, 0xF2	; 242
    2778:	3f 4f       	sbci	r19, 0xFF	; 255
    277a:	b9 01       	movw	r22, r18
    277c:	0e 94 d4 1c 	call	0x39a8	; 0x39a8 <xTaskCheckForTimeOut>
    2780:	88 23       	and	r24, r24
    2782:	09 f5       	brne	.+66     	; 0x27c6 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2784:	8a 81       	ldd	r24, Y+2	; 0x02
    2786:	9b 81       	ldd	r25, Y+3	; 0x03
    2788:	0e 94 39 16 	call	0x2c72	; 0x2c72 <prvIsQueueEmpty>
    278c:	88 23       	and	r24, r24
    278e:	a1 f0       	breq	.+40     	; 0x27b8 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2790:	8a 81       	ldd	r24, Y+2	; 0x02
    2792:	9b 81       	ldd	r25, Y+3	; 0x03
    2794:	41 96       	adiw	r24, 0x11	; 17
    2796:	2e 85       	ldd	r18, Y+14	; 0x0e
    2798:	3f 85       	ldd	r19, Y+15	; 0x0f
    279a:	b9 01       	movw	r22, r18
    279c:	0e 94 83 1b 	call	0x3706	; 0x3706 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    27a0:	8a 81       	ldd	r24, Y+2	; 0x02
    27a2:	9b 81       	ldd	r25, Y+3	; 0x03
    27a4:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    27a8:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    27ac:	88 23       	and	r24, r24
    27ae:	09 f0       	breq	.+2      	; 0x27b2 <xQueuePeek+0x120>
    27b0:	85 cf       	rjmp	.-246    	; 0x26bc <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    27b2:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
    27b6:	82 cf       	rjmp	.-252    	; 0x26bc <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    27b8:	8a 81       	ldd	r24, Y+2	; 0x02
    27ba:	9b 81       	ldd	r25, Y+3	; 0x03
    27bc:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    27c0:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    27c4:	7b cf       	rjmp	.-266    	; 0x26bc <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    27c6:	8a 81       	ldd	r24, Y+2	; 0x02
    27c8:	9b 81       	ldd	r25, Y+3	; 0x03
    27ca:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    27ce:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    27d2:	8a 81       	ldd	r24, Y+2	; 0x02
    27d4:	9b 81       	ldd	r25, Y+3	; 0x03
    27d6:	0e 94 39 16 	call	0x2c72	; 0x2c72 <prvIsQueueEmpty>
    27da:	88 23       	and	r24, r24
    27dc:	09 f4       	brne	.+2      	; 0x27e0 <xQueuePeek+0x14e>
    27de:	6e cf       	rjmp	.-292    	; 0x26bc <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    27e0:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    27e2:	88 89       	ldd	r24, Y+16	; 0x10
}
    27e4:	60 96       	adiw	r28, 0x10	; 16
    27e6:	0f b6       	in	r0, 0x3f	; 63
    27e8:	f8 94       	cli
    27ea:	de bf       	out	0x3e, r29	; 62
    27ec:	0f be       	out	0x3f, r0	; 63
    27ee:	cd bf       	out	0x3d, r28	; 61
    27f0:	cf 91       	pop	r28
    27f2:	df 91       	pop	r29
    27f4:	08 95       	ret

000027f6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    27f6:	df 93       	push	r29
    27f8:	cf 93       	push	r28
    27fa:	cd b7       	in	r28, 0x3d	; 61
    27fc:	de b7       	in	r29, 0x3e	; 62
    27fe:	2c 97       	sbiw	r28, 0x0c	; 12
    2800:	0f b6       	in	r0, 0x3f	; 63
    2802:	f8 94       	cli
    2804:	de bf       	out	0x3e, r29	; 62
    2806:	0f be       	out	0x3f, r0	; 63
    2808:	cd bf       	out	0x3d, r28	; 61
    280a:	98 87       	std	Y+8, r25	; 0x08
    280c:	8f 83       	std	Y+7, r24	; 0x07
    280e:	7a 87       	std	Y+10, r23	; 0x0a
    2810:	69 87       	std	Y+9, r22	; 0x09
    2812:	5c 87       	std	Y+12, r21	; 0x0c
    2814:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2816:	8f 81       	ldd	r24, Y+7	; 0x07
    2818:	98 85       	ldd	r25, Y+8	; 0x08
    281a:	9c 83       	std	Y+4, r25	; 0x04
    281c:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    281e:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2820:	eb 81       	ldd	r30, Y+3	; 0x03
    2822:	fc 81       	ldd	r31, Y+4	; 0x04
    2824:	82 8d       	ldd	r24, Z+26	; 0x1a
    2826:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2828:	8a 81       	ldd	r24, Y+2	; 0x02
    282a:	88 23       	and	r24, r24
    282c:	81 f1       	breq	.+96     	; 0x288e <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    282e:	eb 81       	ldd	r30, Y+3	; 0x03
    2830:	fc 81       	ldd	r31, Y+4	; 0x04
    2832:	85 8d       	ldd	r24, Z+29	; 0x1d
    2834:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2836:	8b 81       	ldd	r24, Y+3	; 0x03
    2838:	9c 81       	ldd	r25, Y+4	; 0x04
    283a:	29 85       	ldd	r18, Y+9	; 0x09
    283c:	3a 85       	ldd	r19, Y+10	; 0x0a
    283e:	b9 01       	movw	r22, r18
    2840:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2844:	8a 81       	ldd	r24, Y+2	; 0x02
    2846:	81 50       	subi	r24, 0x01	; 1
    2848:	eb 81       	ldd	r30, Y+3	; 0x03
    284a:	fc 81       	ldd	r31, Y+4	; 0x04
    284c:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    284e:	89 81       	ldd	r24, Y+1	; 0x01
    2850:	8f 3f       	cpi	r24, 0xFF	; 255
    2852:	a9 f4       	brne	.+42     	; 0x287e <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2854:	eb 81       	ldd	r30, Y+3	; 0x03
    2856:	fc 81       	ldd	r31, Y+4	; 0x04
    2858:	80 85       	ldd	r24, Z+8	; 0x08
    285a:	88 23       	and	r24, r24
    285c:	a9 f0       	breq	.+42     	; 0x2888 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    285e:	8b 81       	ldd	r24, Y+3	; 0x03
    2860:	9c 81       	ldd	r25, Y+4	; 0x04
    2862:	08 96       	adiw	r24, 0x08	; 8
    2864:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <xTaskRemoveFromEventList>
    2868:	88 23       	and	r24, r24
    286a:	71 f0       	breq	.+28     	; 0x2888 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    286c:	8b 85       	ldd	r24, Y+11	; 0x0b
    286e:	9c 85       	ldd	r25, Y+12	; 0x0c
    2870:	00 97       	sbiw	r24, 0x00	; 0
    2872:	51 f0       	breq	.+20     	; 0x2888 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2874:	eb 85       	ldd	r30, Y+11	; 0x0b
    2876:	fc 85       	ldd	r31, Y+12	; 0x0c
    2878:	81 e0       	ldi	r24, 0x01	; 1
    287a:	80 83       	st	Z, r24
    287c:	05 c0       	rjmp	.+10     	; 0x2888 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    287e:	89 81       	ldd	r24, Y+1	; 0x01
    2880:	8f 5f       	subi	r24, 0xFF	; 255
    2882:	eb 81       	ldd	r30, Y+3	; 0x03
    2884:	fc 81       	ldd	r31, Y+4	; 0x04
    2886:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2888:	81 e0       	ldi	r24, 0x01	; 1
    288a:	8e 83       	std	Y+6, r24	; 0x06
    288c:	01 c0       	rjmp	.+2      	; 0x2890 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    288e:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2890:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2892:	2c 96       	adiw	r28, 0x0c	; 12
    2894:	0f b6       	in	r0, 0x3f	; 63
    2896:	f8 94       	cli
    2898:	de bf       	out	0x3e, r29	; 62
    289a:	0f be       	out	0x3f, r0	; 63
    289c:	cd bf       	out	0x3d, r28	; 61
    289e:	cf 91       	pop	r28
    28a0:	df 91       	pop	r29
    28a2:	08 95       	ret

000028a4 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    28a4:	df 93       	push	r29
    28a6:	cf 93       	push	r28
    28a8:	cd b7       	in	r28, 0x3d	; 61
    28aa:	de b7       	in	r29, 0x3e	; 62
    28ac:	2a 97       	sbiw	r28, 0x0a	; 10
    28ae:	0f b6       	in	r0, 0x3f	; 63
    28b0:	f8 94       	cli
    28b2:	de bf       	out	0x3e, r29	; 62
    28b4:	0f be       	out	0x3f, r0	; 63
    28b6:	cd bf       	out	0x3d, r28	; 61
    28b8:	98 87       	std	Y+8, r25	; 0x08
    28ba:	8f 83       	std	Y+7, r24	; 0x07
    28bc:	7a 87       	std	Y+10, r23	; 0x0a
    28be:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    28c0:	8f 81       	ldd	r24, Y+7	; 0x07
    28c2:	98 85       	ldd	r25, Y+8	; 0x08
    28c4:	9a 83       	std	Y+2, r25	; 0x02
    28c6:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    28c8:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    28ca:	e9 81       	ldd	r30, Y+1	; 0x01
    28cc:	fa 81       	ldd	r31, Y+2	; 0x02
    28ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    28d0:	88 23       	and	r24, r24
    28d2:	b1 f0       	breq	.+44     	; 0x2900 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    28d4:	e9 81       	ldd	r30, Y+1	; 0x01
    28d6:	fa 81       	ldd	r31, Y+2	; 0x02
    28d8:	86 81       	ldd	r24, Z+6	; 0x06
    28da:	97 81       	ldd	r25, Z+7	; 0x07
    28dc:	9c 83       	std	Y+4, r25	; 0x04
    28de:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    28e0:	89 81       	ldd	r24, Y+1	; 0x01
    28e2:	9a 81       	ldd	r25, Y+2	; 0x02
    28e4:	29 85       	ldd	r18, Y+9	; 0x09
    28e6:	3a 85       	ldd	r19, Y+10	; 0x0a
    28e8:	b9 01       	movw	r22, r18
    28ea:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    28ee:	e9 81       	ldd	r30, Y+1	; 0x01
    28f0:	fa 81       	ldd	r31, Y+2	; 0x02
    28f2:	8b 81       	ldd	r24, Y+3	; 0x03
    28f4:	9c 81       	ldd	r25, Y+4	; 0x04
    28f6:	97 83       	std	Z+7, r25	; 0x07
    28f8:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    28fa:	81 e0       	ldi	r24, 0x01	; 1
    28fc:	8e 83       	std	Y+6, r24	; 0x06
    28fe:	01 c0       	rjmp	.+2      	; 0x2902 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2900:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2902:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2904:	2a 96       	adiw	r28, 0x0a	; 10
    2906:	0f b6       	in	r0, 0x3f	; 63
    2908:	f8 94       	cli
    290a:	de bf       	out	0x3e, r29	; 62
    290c:	0f be       	out	0x3f, r0	; 63
    290e:	cd bf       	out	0x3d, r28	; 61
    2910:	cf 91       	pop	r28
    2912:	df 91       	pop	r29
    2914:	08 95       	ret

00002916 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2916:	df 93       	push	r29
    2918:	cf 93       	push	r28
    291a:	00 d0       	rcall	.+0      	; 0x291c <uxQueueMessagesWaiting+0x6>
    291c:	0f 92       	push	r0
    291e:	cd b7       	in	r28, 0x3d	; 61
    2920:	de b7       	in	r29, 0x3e	; 62
    2922:	9b 83       	std	Y+3, r25	; 0x03
    2924:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2926:	0f b6       	in	r0, 0x3f	; 63
    2928:	f8 94       	cli
    292a:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    292c:	ea 81       	ldd	r30, Y+2	; 0x02
    292e:	fb 81       	ldd	r31, Y+3	; 0x03
    2930:	82 8d       	ldd	r24, Z+26	; 0x1a
    2932:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2934:	0f 90       	pop	r0
    2936:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2938:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    293a:	0f 90       	pop	r0
    293c:	0f 90       	pop	r0
    293e:	0f 90       	pop	r0
    2940:	cf 91       	pop	r28
    2942:	df 91       	pop	r29
    2944:	08 95       	ret

00002946 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2946:	df 93       	push	r29
    2948:	cf 93       	push	r28
    294a:	00 d0       	rcall	.+0      	; 0x294c <uxQueueSpacesAvailable+0x6>
    294c:	00 d0       	rcall	.+0      	; 0x294e <uxQueueSpacesAvailable+0x8>
    294e:	0f 92       	push	r0
    2950:	cd b7       	in	r28, 0x3d	; 61
    2952:	de b7       	in	r29, 0x3e	; 62
    2954:	9d 83       	std	Y+5, r25	; 0x05
    2956:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2958:	8c 81       	ldd	r24, Y+4	; 0x04
    295a:	9d 81       	ldd	r25, Y+5	; 0x05
    295c:	9a 83       	std	Y+2, r25	; 0x02
    295e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2960:	0f b6       	in	r0, 0x3f	; 63
    2962:	f8 94       	cli
    2964:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2966:	e9 81       	ldd	r30, Y+1	; 0x01
    2968:	fa 81       	ldd	r31, Y+2	; 0x02
    296a:	93 8d       	ldd	r25, Z+27	; 0x1b
    296c:	e9 81       	ldd	r30, Y+1	; 0x01
    296e:	fa 81       	ldd	r31, Y+2	; 0x02
    2970:	82 8d       	ldd	r24, Z+26	; 0x1a
    2972:	29 2f       	mov	r18, r25
    2974:	28 1b       	sub	r18, r24
    2976:	82 2f       	mov	r24, r18
    2978:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    297a:	0f 90       	pop	r0
    297c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    297e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2980:	0f 90       	pop	r0
    2982:	0f 90       	pop	r0
    2984:	0f 90       	pop	r0
    2986:	0f 90       	pop	r0
    2988:	0f 90       	pop	r0
    298a:	cf 91       	pop	r28
    298c:	df 91       	pop	r29
    298e:	08 95       	ret

00002990 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2990:	df 93       	push	r29
    2992:	cf 93       	push	r28
    2994:	00 d0       	rcall	.+0      	; 0x2996 <uxQueueMessagesWaitingFromISR+0x6>
    2996:	00 d0       	rcall	.+0      	; 0x2998 <uxQueueMessagesWaitingFromISR+0x8>
    2998:	0f 92       	push	r0
    299a:	cd b7       	in	r28, 0x3d	; 61
    299c:	de b7       	in	r29, 0x3e	; 62
    299e:	9d 83       	std	Y+5, r25	; 0x05
    29a0:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    29a2:	8c 81       	ldd	r24, Y+4	; 0x04
    29a4:	9d 81       	ldd	r25, Y+5	; 0x05
    29a6:	9a 83       	std	Y+2, r25	; 0x02
    29a8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    29aa:	e9 81       	ldd	r30, Y+1	; 0x01
    29ac:	fa 81       	ldd	r31, Y+2	; 0x02
    29ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    29b0:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    29b2:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    29b4:	0f 90       	pop	r0
    29b6:	0f 90       	pop	r0
    29b8:	0f 90       	pop	r0
    29ba:	0f 90       	pop	r0
    29bc:	0f 90       	pop	r0
    29be:	cf 91       	pop	r28
    29c0:	df 91       	pop	r29
    29c2:	08 95       	ret

000029c4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    29c4:	df 93       	push	r29
    29c6:	cf 93       	push	r28
    29c8:	00 d0       	rcall	.+0      	; 0x29ca <vQueueDelete+0x6>
    29ca:	00 d0       	rcall	.+0      	; 0x29cc <vQueueDelete+0x8>
    29cc:	cd b7       	in	r28, 0x3d	; 61
    29ce:	de b7       	in	r29, 0x3e	; 62
    29d0:	9c 83       	std	Y+4, r25	; 0x04
    29d2:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    29d4:	8b 81       	ldd	r24, Y+3	; 0x03
    29d6:	9c 81       	ldd	r25, Y+4	; 0x04
    29d8:	9a 83       	std	Y+2, r25	; 0x02
    29da:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    29dc:	89 81       	ldd	r24, Y+1	; 0x01
    29de:	9a 81       	ldd	r25, Y+2	; 0x02
    29e0:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    29e4:	0f 90       	pop	r0
    29e6:	0f 90       	pop	r0
    29e8:	0f 90       	pop	r0
    29ea:	0f 90       	pop	r0
    29ec:	cf 91       	pop	r28
    29ee:	df 91       	pop	r29
    29f0:	08 95       	ret

000029f2 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    29f2:	df 93       	push	r29
    29f4:	cf 93       	push	r28
    29f6:	cd b7       	in	r28, 0x3d	; 61
    29f8:	de b7       	in	r29, 0x3e	; 62
    29fa:	27 97       	sbiw	r28, 0x07	; 7
    29fc:	0f b6       	in	r0, 0x3f	; 63
    29fe:	f8 94       	cli
    2a00:	de bf       	out	0x3e, r29	; 62
    2a02:	0f be       	out	0x3f, r0	; 63
    2a04:	cd bf       	out	0x3d, r28	; 61
    2a06:	9c 83       	std	Y+4, r25	; 0x04
    2a08:	8b 83       	std	Y+3, r24	; 0x03
    2a0a:	7e 83       	std	Y+6, r23	; 0x06
    2a0c:	6d 83       	std	Y+5, r22	; 0x05
    2a0e:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    2a10:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2a12:	eb 81       	ldd	r30, Y+3	; 0x03
    2a14:	fc 81       	ldd	r31, Y+4	; 0x04
    2a16:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a18:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2a1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a1e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a20:	88 23       	and	r24, r24
    2a22:	09 f4       	brne	.+2      	; 0x2a26 <prvCopyDataToQueue+0x34>
    2a24:	7d c0       	rjmp	.+250    	; 0x2b20 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2a26:	8f 81       	ldd	r24, Y+7	; 0x07
    2a28:	88 23       	and	r24, r24
    2a2a:	99 f5       	brne	.+102    	; 0x2a92 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2a2c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a2e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a30:	62 81       	ldd	r22, Z+2	; 0x02
    2a32:	73 81       	ldd	r23, Z+3	; 0x03
    2a34:	eb 81       	ldd	r30, Y+3	; 0x03
    2a36:	fc 81       	ldd	r31, Y+4	; 0x04
    2a38:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a3a:	48 2f       	mov	r20, r24
    2a3c:	50 e0       	ldi	r21, 0x00	; 0
    2a3e:	2d 81       	ldd	r18, Y+5	; 0x05
    2a40:	3e 81       	ldd	r19, Y+6	; 0x06
    2a42:	cb 01       	movw	r24, r22
    2a44:	b9 01       	movw	r22, r18
    2a46:	0e 94 14 25 	call	0x4a28	; 0x4a28 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2a4a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a4c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a4e:	22 81       	ldd	r18, Z+2	; 0x02
    2a50:	33 81       	ldd	r19, Z+3	; 0x03
    2a52:	eb 81       	ldd	r30, Y+3	; 0x03
    2a54:	fc 81       	ldd	r31, Y+4	; 0x04
    2a56:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a58:	88 2f       	mov	r24, r24
    2a5a:	90 e0       	ldi	r25, 0x00	; 0
    2a5c:	82 0f       	add	r24, r18
    2a5e:	93 1f       	adc	r25, r19
    2a60:	eb 81       	ldd	r30, Y+3	; 0x03
    2a62:	fc 81       	ldd	r31, Y+4	; 0x04
    2a64:	93 83       	std	Z+3, r25	; 0x03
    2a66:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2a68:	eb 81       	ldd	r30, Y+3	; 0x03
    2a6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a6c:	22 81       	ldd	r18, Z+2	; 0x02
    2a6e:	33 81       	ldd	r19, Z+3	; 0x03
    2a70:	eb 81       	ldd	r30, Y+3	; 0x03
    2a72:	fc 81       	ldd	r31, Y+4	; 0x04
    2a74:	84 81       	ldd	r24, Z+4	; 0x04
    2a76:	95 81       	ldd	r25, Z+5	; 0x05
    2a78:	28 17       	cp	r18, r24
    2a7a:	39 07       	cpc	r19, r25
    2a7c:	08 f4       	brcc	.+2      	; 0x2a80 <prvCopyDataToQueue+0x8e>
    2a7e:	50 c0       	rjmp	.+160    	; 0x2b20 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2a80:	eb 81       	ldd	r30, Y+3	; 0x03
    2a82:	fc 81       	ldd	r31, Y+4	; 0x04
    2a84:	80 81       	ld	r24, Z
    2a86:	91 81       	ldd	r25, Z+1	; 0x01
    2a88:	eb 81       	ldd	r30, Y+3	; 0x03
    2a8a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a8c:	93 83       	std	Z+3, r25	; 0x03
    2a8e:	82 83       	std	Z+2, r24	; 0x02
    2a90:	47 c0       	rjmp	.+142    	; 0x2b20 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2a92:	eb 81       	ldd	r30, Y+3	; 0x03
    2a94:	fc 81       	ldd	r31, Y+4	; 0x04
    2a96:	66 81       	ldd	r22, Z+6	; 0x06
    2a98:	77 81       	ldd	r23, Z+7	; 0x07
    2a9a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a9c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a9e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2aa0:	48 2f       	mov	r20, r24
    2aa2:	50 e0       	ldi	r21, 0x00	; 0
    2aa4:	2d 81       	ldd	r18, Y+5	; 0x05
    2aa6:	3e 81       	ldd	r19, Y+6	; 0x06
    2aa8:	cb 01       	movw	r24, r22
    2aaa:	b9 01       	movw	r22, r18
    2aac:	0e 94 14 25 	call	0x4a28	; 0x4a28 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2ab0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ab4:	26 81       	ldd	r18, Z+6	; 0x06
    2ab6:	37 81       	ldd	r19, Z+7	; 0x07
    2ab8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aba:	fc 81       	ldd	r31, Y+4	; 0x04
    2abc:	84 8d       	ldd	r24, Z+28	; 0x1c
    2abe:	88 2f       	mov	r24, r24
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	90 95       	com	r25
    2ac4:	81 95       	neg	r24
    2ac6:	9f 4f       	sbci	r25, 0xFF	; 255
    2ac8:	82 0f       	add	r24, r18
    2aca:	93 1f       	adc	r25, r19
    2acc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ace:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad0:	97 83       	std	Z+7, r25	; 0x07
    2ad2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2ad4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ad6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad8:	26 81       	ldd	r18, Z+6	; 0x06
    2ada:	37 81       	ldd	r19, Z+7	; 0x07
    2adc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ade:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae0:	80 81       	ld	r24, Z
    2ae2:	91 81       	ldd	r25, Z+1	; 0x01
    2ae4:	28 17       	cp	r18, r24
    2ae6:	39 07       	cpc	r19, r25
    2ae8:	90 f4       	brcc	.+36     	; 0x2b0e <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2aea:	eb 81       	ldd	r30, Y+3	; 0x03
    2aec:	fc 81       	ldd	r31, Y+4	; 0x04
    2aee:	24 81       	ldd	r18, Z+4	; 0x04
    2af0:	35 81       	ldd	r19, Z+5	; 0x05
    2af2:	eb 81       	ldd	r30, Y+3	; 0x03
    2af4:	fc 81       	ldd	r31, Y+4	; 0x04
    2af6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2af8:	88 2f       	mov	r24, r24
    2afa:	90 e0       	ldi	r25, 0x00	; 0
    2afc:	90 95       	com	r25
    2afe:	81 95       	neg	r24
    2b00:	9f 4f       	sbci	r25, 0xFF	; 255
    2b02:	82 0f       	add	r24, r18
    2b04:	93 1f       	adc	r25, r19
    2b06:	eb 81       	ldd	r30, Y+3	; 0x03
    2b08:	fc 81       	ldd	r31, Y+4	; 0x04
    2b0a:	97 83       	std	Z+7, r25	; 0x07
    2b0c:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2b0e:	8f 81       	ldd	r24, Y+7	; 0x07
    2b10:	82 30       	cpi	r24, 0x02	; 2
    2b12:	31 f4       	brne	.+12     	; 0x2b20 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2b14:	89 81       	ldd	r24, Y+1	; 0x01
    2b16:	88 23       	and	r24, r24
    2b18:	19 f0       	breq	.+6      	; 0x2b20 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2b1a:	89 81       	ldd	r24, Y+1	; 0x01
    2b1c:	81 50       	subi	r24, 0x01	; 1
    2b1e:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2b20:	89 81       	ldd	r24, Y+1	; 0x01
    2b22:	8f 5f       	subi	r24, 0xFF	; 255
    2b24:	eb 81       	ldd	r30, Y+3	; 0x03
    2b26:	fc 81       	ldd	r31, Y+4	; 0x04
    2b28:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2b2a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2b2c:	27 96       	adiw	r28, 0x07	; 7
    2b2e:	0f b6       	in	r0, 0x3f	; 63
    2b30:	f8 94       	cli
    2b32:	de bf       	out	0x3e, r29	; 62
    2b34:	0f be       	out	0x3f, r0	; 63
    2b36:	cd bf       	out	0x3d, r28	; 61
    2b38:	cf 91       	pop	r28
    2b3a:	df 91       	pop	r29
    2b3c:	08 95       	ret

00002b3e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2b3e:	df 93       	push	r29
    2b40:	cf 93       	push	r28
    2b42:	00 d0       	rcall	.+0      	; 0x2b44 <prvCopyDataFromQueue+0x6>
    2b44:	00 d0       	rcall	.+0      	; 0x2b46 <prvCopyDataFromQueue+0x8>
    2b46:	cd b7       	in	r28, 0x3d	; 61
    2b48:	de b7       	in	r29, 0x3e	; 62
    2b4a:	9a 83       	std	Y+2, r25	; 0x02
    2b4c:	89 83       	std	Y+1, r24	; 0x01
    2b4e:	7c 83       	std	Y+4, r23	; 0x04
    2b50:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2b52:	e9 81       	ldd	r30, Y+1	; 0x01
    2b54:	fa 81       	ldd	r31, Y+2	; 0x02
    2b56:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b58:	88 23       	and	r24, r24
    2b5a:	89 f1       	breq	.+98     	; 0x2bbe <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2b5c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b5e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b60:	26 81       	ldd	r18, Z+6	; 0x06
    2b62:	37 81       	ldd	r19, Z+7	; 0x07
    2b64:	e9 81       	ldd	r30, Y+1	; 0x01
    2b66:	fa 81       	ldd	r31, Y+2	; 0x02
    2b68:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b6a:	88 2f       	mov	r24, r24
    2b6c:	90 e0       	ldi	r25, 0x00	; 0
    2b6e:	82 0f       	add	r24, r18
    2b70:	93 1f       	adc	r25, r19
    2b72:	e9 81       	ldd	r30, Y+1	; 0x01
    2b74:	fa 81       	ldd	r31, Y+2	; 0x02
    2b76:	97 83       	std	Z+7, r25	; 0x07
    2b78:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2b7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7e:	26 81       	ldd	r18, Z+6	; 0x06
    2b80:	37 81       	ldd	r19, Z+7	; 0x07
    2b82:	e9 81       	ldd	r30, Y+1	; 0x01
    2b84:	fa 81       	ldd	r31, Y+2	; 0x02
    2b86:	84 81       	ldd	r24, Z+4	; 0x04
    2b88:	95 81       	ldd	r25, Z+5	; 0x05
    2b8a:	28 17       	cp	r18, r24
    2b8c:	39 07       	cpc	r19, r25
    2b8e:	40 f0       	brcs	.+16     	; 0x2ba0 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2b90:	e9 81       	ldd	r30, Y+1	; 0x01
    2b92:	fa 81       	ldd	r31, Y+2	; 0x02
    2b94:	80 81       	ld	r24, Z
    2b96:	91 81       	ldd	r25, Z+1	; 0x01
    2b98:	e9 81       	ldd	r30, Y+1	; 0x01
    2b9a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b9c:	97 83       	std	Z+7, r25	; 0x07
    2b9e:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2ba0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba4:	46 81       	ldd	r20, Z+6	; 0x06
    2ba6:	57 81       	ldd	r21, Z+7	; 0x07
    2ba8:	e9 81       	ldd	r30, Y+1	; 0x01
    2baa:	fa 81       	ldd	r31, Y+2	; 0x02
    2bac:	84 8d       	ldd	r24, Z+28	; 0x1c
    2bae:	28 2f       	mov	r18, r24
    2bb0:	30 e0       	ldi	r19, 0x00	; 0
    2bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb4:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb6:	ba 01       	movw	r22, r20
    2bb8:	a9 01       	movw	r20, r18
    2bba:	0e 94 14 25 	call	0x4a28	; 0x4a28 <memcpy>
	}
}
    2bbe:	0f 90       	pop	r0
    2bc0:	0f 90       	pop	r0
    2bc2:	0f 90       	pop	r0
    2bc4:	0f 90       	pop	r0
    2bc6:	cf 91       	pop	r28
    2bc8:	df 91       	pop	r29
    2bca:	08 95       	ret

00002bcc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2bcc:	df 93       	push	r29
    2bce:	cf 93       	push	r28
    2bd0:	00 d0       	rcall	.+0      	; 0x2bd2 <prvUnlockQueue+0x6>
    2bd2:	00 d0       	rcall	.+0      	; 0x2bd4 <prvUnlockQueue+0x8>
    2bd4:	cd b7       	in	r28, 0x3d	; 61
    2bd6:	de b7       	in	r29, 0x3e	; 62
    2bd8:	9c 83       	std	Y+4, r25	; 0x04
    2bda:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2bdc:	0f b6       	in	r0, 0x3f	; 63
    2bde:	f8 94       	cli
    2be0:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2be2:	eb 81       	ldd	r30, Y+3	; 0x03
    2be4:	fc 81       	ldd	r31, Y+4	; 0x04
    2be6:	86 8d       	ldd	r24, Z+30	; 0x1e
    2be8:	8a 83       	std	Y+2, r24	; 0x02
    2bea:	11 c0       	rjmp	.+34     	; 0x2c0e <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2bec:	eb 81       	ldd	r30, Y+3	; 0x03
    2bee:	fc 81       	ldd	r31, Y+4	; 0x04
    2bf0:	81 89       	ldd	r24, Z+17	; 0x11
    2bf2:	88 23       	and	r24, r24
    2bf4:	79 f0       	breq	.+30     	; 0x2c14 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    2bf8:	9c 81       	ldd	r25, Y+4	; 0x04
    2bfa:	41 96       	adiw	r24, 0x11	; 17
    2bfc:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <xTaskRemoveFromEventList>
    2c00:	88 23       	and	r24, r24
    2c02:	11 f0       	breq	.+4      	; 0x2c08 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2c04:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2c08:	8a 81       	ldd	r24, Y+2	; 0x02
    2c0a:	81 50       	subi	r24, 0x01	; 1
    2c0c:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c10:	18 16       	cp	r1, r24
    2c12:	64 f3       	brlt	.-40     	; 0x2bec <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2c14:	eb 81       	ldd	r30, Y+3	; 0x03
    2c16:	fc 81       	ldd	r31, Y+4	; 0x04
    2c18:	8f ef       	ldi	r24, 0xFF	; 255
    2c1a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2c1c:	0f 90       	pop	r0
    2c1e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2c20:	0f b6       	in	r0, 0x3f	; 63
    2c22:	f8 94       	cli
    2c24:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2c26:	eb 81       	ldd	r30, Y+3	; 0x03
    2c28:	fc 81       	ldd	r31, Y+4	; 0x04
    2c2a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c2c:	89 83       	std	Y+1, r24	; 0x01
    2c2e:	11 c0       	rjmp	.+34     	; 0x2c52 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2c30:	eb 81       	ldd	r30, Y+3	; 0x03
    2c32:	fc 81       	ldd	r31, Y+4	; 0x04
    2c34:	80 85       	ldd	r24, Z+8	; 0x08
    2c36:	88 23       	and	r24, r24
    2c38:	79 f0       	breq	.+30     	; 0x2c58 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2c3a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c3c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c3e:	08 96       	adiw	r24, 0x08	; 8
    2c40:	0e 94 d5 1b 	call	0x37aa	; 0x37aa <xTaskRemoveFromEventList>
    2c44:	88 23       	and	r24, r24
    2c46:	11 f0       	breq	.+4      	; 0x2c4c <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2c48:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2c4c:	89 81       	ldd	r24, Y+1	; 0x01
    2c4e:	81 50       	subi	r24, 0x01	; 1
    2c50:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2c52:	89 81       	ldd	r24, Y+1	; 0x01
    2c54:	18 16       	cp	r1, r24
    2c56:	64 f3       	brlt	.-40     	; 0x2c30 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2c58:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c5c:	8f ef       	ldi	r24, 0xFF	; 255
    2c5e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2c60:	0f 90       	pop	r0
    2c62:	0f be       	out	0x3f, r0	; 63
}
    2c64:	0f 90       	pop	r0
    2c66:	0f 90       	pop	r0
    2c68:	0f 90       	pop	r0
    2c6a:	0f 90       	pop	r0
    2c6c:	cf 91       	pop	r28
    2c6e:	df 91       	pop	r29
    2c70:	08 95       	ret

00002c72 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2c72:	df 93       	push	r29
    2c74:	cf 93       	push	r28
    2c76:	00 d0       	rcall	.+0      	; 0x2c78 <prvIsQueueEmpty+0x6>
    2c78:	0f 92       	push	r0
    2c7a:	cd b7       	in	r28, 0x3d	; 61
    2c7c:	de b7       	in	r29, 0x3e	; 62
    2c7e:	9b 83       	std	Y+3, r25	; 0x03
    2c80:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2c82:	0f b6       	in	r0, 0x3f	; 63
    2c84:	f8 94       	cli
    2c86:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2c88:	ea 81       	ldd	r30, Y+2	; 0x02
    2c8a:	fb 81       	ldd	r31, Y+3	; 0x03
    2c8c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c8e:	88 23       	and	r24, r24
    2c90:	19 f4       	brne	.+6      	; 0x2c98 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2c92:	81 e0       	ldi	r24, 0x01	; 1
    2c94:	89 83       	std	Y+1, r24	; 0x01
    2c96:	01 c0       	rjmp	.+2      	; 0x2c9a <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2c98:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2c9a:	0f 90       	pop	r0
    2c9c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2c9e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ca0:	0f 90       	pop	r0
    2ca2:	0f 90       	pop	r0
    2ca4:	0f 90       	pop	r0
    2ca6:	cf 91       	pop	r28
    2ca8:	df 91       	pop	r29
    2caa:	08 95       	ret

00002cac <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2cac:	df 93       	push	r29
    2cae:	cf 93       	push	r28
    2cb0:	00 d0       	rcall	.+0      	; 0x2cb2 <xQueueIsQueueEmptyFromISR+0x6>
    2cb2:	00 d0       	rcall	.+0      	; 0x2cb4 <xQueueIsQueueEmptyFromISR+0x8>
    2cb4:	0f 92       	push	r0
    2cb6:	cd b7       	in	r28, 0x3d	; 61
    2cb8:	de b7       	in	r29, 0x3e	; 62
    2cba:	9d 83       	std	Y+5, r25	; 0x05
    2cbc:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2cbe:	8c 81       	ldd	r24, Y+4	; 0x04
    2cc0:	9d 81       	ldd	r25, Y+5	; 0x05
    2cc2:	9a 83       	std	Y+2, r25	; 0x02
    2cc4:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2cc6:	e9 81       	ldd	r30, Y+1	; 0x01
    2cc8:	fa 81       	ldd	r31, Y+2	; 0x02
    2cca:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ccc:	88 23       	and	r24, r24
    2cce:	19 f4       	brne	.+6      	; 0x2cd6 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2cd0:	81 e0       	ldi	r24, 0x01	; 1
    2cd2:	8b 83       	std	Y+3, r24	; 0x03
    2cd4:	01 c0       	rjmp	.+2      	; 0x2cd8 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2cd6:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2cd8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2cda:	0f 90       	pop	r0
    2cdc:	0f 90       	pop	r0
    2cde:	0f 90       	pop	r0
    2ce0:	0f 90       	pop	r0
    2ce2:	0f 90       	pop	r0
    2ce4:	cf 91       	pop	r28
    2ce6:	df 91       	pop	r29
    2ce8:	08 95       	ret

00002cea <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2cea:	df 93       	push	r29
    2cec:	cf 93       	push	r28
    2cee:	00 d0       	rcall	.+0      	; 0x2cf0 <prvIsQueueFull+0x6>
    2cf0:	0f 92       	push	r0
    2cf2:	cd b7       	in	r28, 0x3d	; 61
    2cf4:	de b7       	in	r29, 0x3e	; 62
    2cf6:	9b 83       	std	Y+3, r25	; 0x03
    2cf8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2cfa:	0f b6       	in	r0, 0x3f	; 63
    2cfc:	f8 94       	cli
    2cfe:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2d00:	ea 81       	ldd	r30, Y+2	; 0x02
    2d02:	fb 81       	ldd	r31, Y+3	; 0x03
    2d04:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d06:	ea 81       	ldd	r30, Y+2	; 0x02
    2d08:	fb 81       	ldd	r31, Y+3	; 0x03
    2d0a:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d0c:	98 17       	cp	r25, r24
    2d0e:	19 f4       	brne	.+6      	; 0x2d16 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2d10:	81 e0       	ldi	r24, 0x01	; 1
    2d12:	89 83       	std	Y+1, r24	; 0x01
    2d14:	01 c0       	rjmp	.+2      	; 0x2d18 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2d16:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2d18:	0f 90       	pop	r0
    2d1a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2d1c:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d1e:	0f 90       	pop	r0
    2d20:	0f 90       	pop	r0
    2d22:	0f 90       	pop	r0
    2d24:	cf 91       	pop	r28
    2d26:	df 91       	pop	r29
    2d28:	08 95       	ret

00002d2a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2d2a:	df 93       	push	r29
    2d2c:	cf 93       	push	r28
    2d2e:	00 d0       	rcall	.+0      	; 0x2d30 <xQueueIsQueueFullFromISR+0x6>
    2d30:	00 d0       	rcall	.+0      	; 0x2d32 <xQueueIsQueueFullFromISR+0x8>
    2d32:	0f 92       	push	r0
    2d34:	cd b7       	in	r28, 0x3d	; 61
    2d36:	de b7       	in	r29, 0x3e	; 62
    2d38:	9d 83       	std	Y+5, r25	; 0x05
    2d3a:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2d3c:	8c 81       	ldd	r24, Y+4	; 0x04
    2d3e:	9d 81       	ldd	r25, Y+5	; 0x05
    2d40:	9a 83       	std	Y+2, r25	; 0x02
    2d42:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2d44:	e9 81       	ldd	r30, Y+1	; 0x01
    2d46:	fa 81       	ldd	r31, Y+2	; 0x02
    2d48:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d4e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d50:	98 17       	cp	r25, r24
    2d52:	19 f4       	brne	.+6      	; 0x2d5a <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2d54:	81 e0       	ldi	r24, 0x01	; 1
    2d56:	8b 83       	std	Y+3, r24	; 0x03
    2d58:	01 c0       	rjmp	.+2      	; 0x2d5c <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2d5a:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2d5c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2d5e:	0f 90       	pop	r0
    2d60:	0f 90       	pop	r0
    2d62:	0f 90       	pop	r0
    2d64:	0f 90       	pop	r0
    2d66:	0f 90       	pop	r0
    2d68:	cf 91       	pop	r28
    2d6a:	df 91       	pop	r29
    2d6c:	08 95       	ret

00002d6e <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    2d6e:	8f 92       	push	r8
    2d70:	9f 92       	push	r9
    2d72:	af 92       	push	r10
    2d74:	bf 92       	push	r11
    2d76:	cf 92       	push	r12
    2d78:	df 92       	push	r13
    2d7a:	ef 92       	push	r14
    2d7c:	ff 92       	push	r15
    2d7e:	0f 93       	push	r16
    2d80:	1f 93       	push	r17
    2d82:	df 93       	push	r29
    2d84:	cf 93       	push	r28
    2d86:	cd b7       	in	r28, 0x3d	; 61
    2d88:	de b7       	in	r29, 0x3e	; 62
    2d8a:	60 97       	sbiw	r28, 0x10	; 16
    2d8c:	0f b6       	in	r0, 0x3f	; 63
    2d8e:	f8 94       	cli
    2d90:	de bf       	out	0x3e, r29	; 62
    2d92:	0f be       	out	0x3f, r0	; 63
    2d94:	cd bf       	out	0x3d, r28	; 61
    2d96:	9f 83       	std	Y+7, r25	; 0x07
    2d98:	8e 83       	std	Y+6, r24	; 0x06
    2d9a:	79 87       	std	Y+9, r23	; 0x09
    2d9c:	68 87       	std	Y+8, r22	; 0x08
    2d9e:	5b 87       	std	Y+11, r21	; 0x0b
    2da0:	4a 87       	std	Y+10, r20	; 0x0a
    2da2:	3d 87       	std	Y+13, r19	; 0x0d
    2da4:	2c 87       	std	Y+12, r18	; 0x0c
    2da6:	0e 87       	std	Y+14, r16	; 0x0e
    2da8:	f8 8a       	std	Y+16, r15	; 0x10
    2daa:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2dac:	8a 85       	ldd	r24, Y+10	; 0x0a
    2dae:	9b 85       	ldd	r25, Y+11	; 0x0b
    2db0:	0e 94 0f 0b 	call	0x161e	; 0x161e <pvPortMalloc>
    2db4:	9a 83       	std	Y+2, r25	; 0x02
    2db6:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    2db8:	89 81       	ldd	r24, Y+1	; 0x01
    2dba:	9a 81       	ldd	r25, Y+2	; 0x02
    2dbc:	00 97       	sbiw	r24, 0x00	; 0
    2dbe:	b1 f0       	breq	.+44     	; 0x2dec <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2dc0:	86 e2       	ldi	r24, 0x26	; 38
    2dc2:	90 e0       	ldi	r25, 0x00	; 0
    2dc4:	0e 94 0f 0b 	call	0x161e	; 0x161e <pvPortMalloc>
    2dc8:	9d 83       	std	Y+5, r25	; 0x05
    2dca:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    2dcc:	8c 81       	ldd	r24, Y+4	; 0x04
    2dce:	9d 81       	ldd	r25, Y+5	; 0x05
    2dd0:	00 97       	sbiw	r24, 0x00	; 0
    2dd2:	39 f0       	breq	.+14     	; 0x2de2 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    2dd4:	ec 81       	ldd	r30, Y+4	; 0x04
    2dd6:	fd 81       	ldd	r31, Y+5	; 0x05
    2dd8:	89 81       	ldd	r24, Y+1	; 0x01
    2dda:	9a 81       	ldd	r25, Y+2	; 0x02
    2ddc:	90 8f       	std	Z+24, r25	; 0x18
    2dde:	87 8b       	std	Z+23, r24	; 0x17
    2de0:	07 c0       	rjmp	.+14     	; 0x2df0 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    2de2:	89 81       	ldd	r24, Y+1	; 0x01
    2de4:	9a 81       	ldd	r25, Y+2	; 0x02
    2de6:	0e 94 65 0b 	call	0x16ca	; 0x16ca <vPortFree>
    2dea:	02 c0       	rjmp	.+4      	; 0x2df0 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    2dec:	1d 82       	std	Y+5, r1	; 0x05
    2dee:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    2df0:	8c 81       	ldd	r24, Y+4	; 0x04
    2df2:	9d 81       	ldd	r25, Y+5	; 0x05
    2df4:	00 97       	sbiw	r24, 0x00	; 0
    2df6:	e9 f0       	breq	.+58     	; 0x2e32 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2df8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2dfa:	9b 85       	ldd	r25, Y+11	; 0x0b
    2dfc:	9c 01       	movw	r18, r24
    2dfe:	40 e0       	ldi	r20, 0x00	; 0
    2e00:	50 e0       	ldi	r21, 0x00	; 0
    2e02:	8e 81       	ldd	r24, Y+6	; 0x06
    2e04:	9f 81       	ldd	r25, Y+7	; 0x07
    2e06:	68 85       	ldd	r22, Y+8	; 0x08
    2e08:	79 85       	ldd	r23, Y+9	; 0x09
    2e0a:	ec 85       	ldd	r30, Y+12	; 0x0c
    2e0c:	fd 85       	ldd	r31, Y+13	; 0x0d
    2e0e:	af 85       	ldd	r26, Y+15	; 0x0f
    2e10:	b8 89       	ldd	r27, Y+16	; 0x10
    2e12:	ac 80       	ldd	r10, Y+4	; 0x04
    2e14:	bd 80       	ldd	r11, Y+5	; 0x05
    2e16:	8f 01       	movw	r16, r30
    2e18:	ee 84       	ldd	r14, Y+14	; 0x0e
    2e1a:	6d 01       	movw	r12, r26
    2e1c:	88 24       	eor	r8, r8
    2e1e:	99 24       	eor	r9, r9
    2e20:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    2e24:	8c 81       	ldd	r24, Y+4	; 0x04
    2e26:	9d 81       	ldd	r25, Y+5	; 0x05
    2e28:	0e 94 eb 17 	call	0x2fd6	; 0x2fd6 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    2e2c:	81 e0       	ldi	r24, 0x01	; 1
    2e2e:	8b 83       	std	Y+3, r24	; 0x03
    2e30:	02 c0       	rjmp	.+4      	; 0x2e36 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2e32:	8f ef       	ldi	r24, 0xFF	; 255
    2e34:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    2e36:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2e38:	60 96       	adiw	r28, 0x10	; 16
    2e3a:	0f b6       	in	r0, 0x3f	; 63
    2e3c:	f8 94       	cli
    2e3e:	de bf       	out	0x3e, r29	; 62
    2e40:	0f be       	out	0x3f, r0	; 63
    2e42:	cd bf       	out	0x3d, r28	; 61
    2e44:	cf 91       	pop	r28
    2e46:	df 91       	pop	r29
    2e48:	1f 91       	pop	r17
    2e4a:	0f 91       	pop	r16
    2e4c:	ff 90       	pop	r15
    2e4e:	ef 90       	pop	r14
    2e50:	df 90       	pop	r13
    2e52:	cf 90       	pop	r12
    2e54:	bf 90       	pop	r11
    2e56:	af 90       	pop	r10
    2e58:	9f 90       	pop	r9
    2e5a:	8f 90       	pop	r8
    2e5c:	08 95       	ret

00002e5e <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    2e5e:	8f 92       	push	r8
    2e60:	9f 92       	push	r9
    2e62:	af 92       	push	r10
    2e64:	bf 92       	push	r11
    2e66:	cf 92       	push	r12
    2e68:	df 92       	push	r13
    2e6a:	ef 92       	push	r14
    2e6c:	0f 93       	push	r16
    2e6e:	1f 93       	push	r17
    2e70:	df 93       	push	r29
    2e72:	cf 93       	push	r28
    2e74:	cd b7       	in	r28, 0x3d	; 61
    2e76:	de b7       	in	r29, 0x3e	; 62
    2e78:	64 97       	sbiw	r28, 0x14	; 20
    2e7a:	0f b6       	in	r0, 0x3f	; 63
    2e7c:	f8 94       	cli
    2e7e:	de bf       	out	0x3e, r29	; 62
    2e80:	0f be       	out	0x3f, r0	; 63
    2e82:	cd bf       	out	0x3d, r28	; 61
    2e84:	9d 83       	std	Y+5, r25	; 0x05
    2e86:	8c 83       	std	Y+4, r24	; 0x04
    2e88:	7f 83       	std	Y+7, r23	; 0x07
    2e8a:	6e 83       	std	Y+6, r22	; 0x06
    2e8c:	28 87       	std	Y+8, r18	; 0x08
    2e8e:	39 87       	std	Y+9, r19	; 0x09
    2e90:	4a 87       	std	Y+10, r20	; 0x0a
    2e92:	5b 87       	std	Y+11, r21	; 0x0b
    2e94:	1d 87       	std	Y+13, r17	; 0x0d
    2e96:	0c 87       	std	Y+12, r16	; 0x0c
    2e98:	ee 86       	std	Y+14, r14	; 0x0e
    2e9a:	d8 8a       	std	Y+16, r13	; 0x10
    2e9c:	cf 86       	std	Y+15, r12	; 0x0f
    2e9e:	ba 8a       	std	Y+18, r11	; 0x12
    2ea0:	a9 8a       	std	Y+17, r10	; 0x11
    2ea2:	9c 8a       	std	Y+20, r9	; 0x14
    2ea4:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    2ea6:	e9 89       	ldd	r30, Y+17	; 0x11
    2ea8:	fa 89       	ldd	r31, Y+18	; 0x12
    2eaa:	27 89       	ldd	r18, Z+23	; 0x17
    2eac:	30 8d       	ldd	r19, Z+24	; 0x18
    2eae:	88 85       	ldd	r24, Y+8	; 0x08
    2eb0:	99 85       	ldd	r25, Y+9	; 0x09
    2eb2:	01 97       	sbiw	r24, 0x01	; 1
    2eb4:	82 0f       	add	r24, r18
    2eb6:	93 1f       	adc	r25, r19
    2eb8:	9b 83       	std	Y+3, r25	; 0x03
    2eba:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    2ebc:	8e 81       	ldd	r24, Y+6	; 0x06
    2ebe:	9f 81       	ldd	r25, Y+7	; 0x07
    2ec0:	00 97       	sbiw	r24, 0x00	; 0
    2ec2:	51 f1       	breq	.+84     	; 0x2f18 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2ec4:	19 82       	std	Y+1, r1	; 0x01
    2ec6:	21 c0       	rjmp	.+66     	; 0x2f0a <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    2ec8:	89 81       	ldd	r24, Y+1	; 0x01
    2eca:	48 2f       	mov	r20, r24
    2ecc:	50 e0       	ldi	r21, 0x00	; 0
    2ece:	89 81       	ldd	r24, Y+1	; 0x01
    2ed0:	28 2f       	mov	r18, r24
    2ed2:	30 e0       	ldi	r19, 0x00	; 0
    2ed4:	8e 81       	ldd	r24, Y+6	; 0x06
    2ed6:	9f 81       	ldd	r25, Y+7	; 0x07
    2ed8:	fc 01       	movw	r30, r24
    2eda:	e2 0f       	add	r30, r18
    2edc:	f3 1f       	adc	r31, r19
    2ede:	20 81       	ld	r18, Z
    2ee0:	89 89       	ldd	r24, Y+17	; 0x11
    2ee2:	9a 89       	ldd	r25, Y+18	; 0x12
    2ee4:	84 0f       	add	r24, r20
    2ee6:	95 1f       	adc	r25, r21
    2ee8:	fc 01       	movw	r30, r24
    2eea:	79 96       	adiw	r30, 0x19	; 25
    2eec:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    2eee:	89 81       	ldd	r24, Y+1	; 0x01
    2ef0:	28 2f       	mov	r18, r24
    2ef2:	30 e0       	ldi	r19, 0x00	; 0
    2ef4:	8e 81       	ldd	r24, Y+6	; 0x06
    2ef6:	9f 81       	ldd	r25, Y+7	; 0x07
    2ef8:	fc 01       	movw	r30, r24
    2efa:	e2 0f       	add	r30, r18
    2efc:	f3 1f       	adc	r31, r19
    2efe:	80 81       	ld	r24, Z
    2f00:	88 23       	and	r24, r24
    2f02:	31 f0       	breq	.+12     	; 0x2f10 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2f04:	89 81       	ldd	r24, Y+1	; 0x01
    2f06:	8f 5f       	subi	r24, 0xFF	; 255
    2f08:	89 83       	std	Y+1, r24	; 0x01
    2f0a:	89 81       	ldd	r24, Y+1	; 0x01
    2f0c:	88 30       	cpi	r24, 0x08	; 8
    2f0e:	e0 f2       	brcs	.-72     	; 0x2ec8 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2f10:	e9 89       	ldd	r30, Y+17	; 0x11
    2f12:	fa 89       	ldd	r31, Y+18	; 0x12
    2f14:	10 a2       	std	Z+32, r1	; 0x20
    2f16:	03 c0       	rjmp	.+6      	; 0x2f1e <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    2f18:	e9 89       	ldd	r30, Y+17	; 0x11
    2f1a:	fa 89       	ldd	r31, Y+18	; 0x12
    2f1c:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2f1e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f20:	84 30       	cpi	r24, 0x04	; 4
    2f22:	10 f0       	brcs	.+4      	; 0x2f28 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2f24:	83 e0       	ldi	r24, 0x03	; 3
    2f26:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    2f28:	e9 89       	ldd	r30, Y+17	; 0x11
    2f2a:	fa 89       	ldd	r31, Y+18	; 0x12
    2f2c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f2e:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2f30:	89 89       	ldd	r24, Y+17	; 0x11
    2f32:	9a 89       	ldd	r25, Y+18	; 0x12
    2f34:	02 96       	adiw	r24, 0x02	; 2
    2f36:	0e 94 b5 0b 	call	0x176a	; 0x176a <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    2f3a:	89 89       	ldd	r24, Y+17	; 0x11
    2f3c:	9a 89       	ldd	r25, Y+18	; 0x12
    2f3e:	0c 96       	adiw	r24, 0x0c	; 12
    2f40:	0e 94 b5 0b 	call	0x176a	; 0x176a <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2f44:	e9 89       	ldd	r30, Y+17	; 0x11
    2f46:	fa 89       	ldd	r31, Y+18	; 0x12
    2f48:	89 89       	ldd	r24, Y+17	; 0x11
    2f4a:	9a 89       	ldd	r25, Y+18	; 0x12
    2f4c:	91 87       	std	Z+9, r25	; 0x09
    2f4e:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2f50:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f52:	28 2f       	mov	r18, r24
    2f54:	30 e0       	ldi	r19, 0x00	; 0
    2f56:	84 e0       	ldi	r24, 0x04	; 4
    2f58:	90 e0       	ldi	r25, 0x00	; 0
    2f5a:	82 1b       	sub	r24, r18
    2f5c:	93 0b       	sbc	r25, r19
    2f5e:	e9 89       	ldd	r30, Y+17	; 0x11
    2f60:	fa 89       	ldd	r31, Y+18	; 0x12
    2f62:	95 87       	std	Z+13, r25	; 0x0d
    2f64:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2f66:	e9 89       	ldd	r30, Y+17	; 0x11
    2f68:	fa 89       	ldd	r31, Y+18	; 0x12
    2f6a:	89 89       	ldd	r24, Y+17	; 0x11
    2f6c:	9a 89       	ldd	r25, Y+18	; 0x12
    2f6e:	93 8b       	std	Z+19, r25	; 0x13
    2f70:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    2f72:	e9 89       	ldd	r30, Y+17	; 0x11
    2f74:	fa 89       	ldd	r31, Y+18	; 0x12
    2f76:	11 a2       	std	Z+33, r1	; 0x21
    2f78:	12 a2       	std	Z+34, r1	; 0x22
    2f7a:	13 a2       	std	Z+35, r1	; 0x23
    2f7c:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2f7e:	e9 89       	ldd	r30, Y+17	; 0x11
    2f80:	fa 89       	ldd	r31, Y+18	; 0x12
    2f82:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2f84:	8a 81       	ldd	r24, Y+2	; 0x02
    2f86:	9b 81       	ldd	r25, Y+3	; 0x03
    2f88:	2c 81       	ldd	r18, Y+4	; 0x04
    2f8a:	3d 81       	ldd	r19, Y+5	; 0x05
    2f8c:	4c 85       	ldd	r20, Y+12	; 0x0c
    2f8e:	5d 85       	ldd	r21, Y+13	; 0x0d
    2f90:	b9 01       	movw	r22, r18
    2f92:	0e 94 c1 0c 	call	0x1982	; 0x1982 <pxPortInitialiseStack>
    2f96:	e9 89       	ldd	r30, Y+17	; 0x11
    2f98:	fa 89       	ldd	r31, Y+18	; 0x12
    2f9a:	91 83       	std	Z+1, r25	; 0x01
    2f9c:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    2f9e:	8f 85       	ldd	r24, Y+15	; 0x0f
    2fa0:	98 89       	ldd	r25, Y+16	; 0x10
    2fa2:	00 97       	sbiw	r24, 0x00	; 0
    2fa4:	31 f0       	breq	.+12     	; 0x2fb2 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2fa6:	ef 85       	ldd	r30, Y+15	; 0x0f
    2fa8:	f8 89       	ldd	r31, Y+16	; 0x10
    2faa:	89 89       	ldd	r24, Y+17	; 0x11
    2fac:	9a 89       	ldd	r25, Y+18	; 0x12
    2fae:	91 83       	std	Z+1, r25	; 0x01
    2fb0:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2fb2:	64 96       	adiw	r28, 0x14	; 20
    2fb4:	0f b6       	in	r0, 0x3f	; 63
    2fb6:	f8 94       	cli
    2fb8:	de bf       	out	0x3e, r29	; 62
    2fba:	0f be       	out	0x3f, r0	; 63
    2fbc:	cd bf       	out	0x3d, r28	; 61
    2fbe:	cf 91       	pop	r28
    2fc0:	df 91       	pop	r29
    2fc2:	1f 91       	pop	r17
    2fc4:	0f 91       	pop	r16
    2fc6:	ef 90       	pop	r14
    2fc8:	df 90       	pop	r13
    2fca:	cf 90       	pop	r12
    2fcc:	bf 90       	pop	r11
    2fce:	af 90       	pop	r10
    2fd0:	9f 90       	pop	r9
    2fd2:	8f 90       	pop	r8
    2fd4:	08 95       	ret

00002fd6 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    2fd6:	df 93       	push	r29
    2fd8:	cf 93       	push	r28
    2fda:	00 d0       	rcall	.+0      	; 0x2fdc <prvAddNewTaskToReadyList+0x6>
    2fdc:	cd b7       	in	r28, 0x3d	; 61
    2fde:	de b7       	in	r29, 0x3e	; 62
    2fe0:	9a 83       	std	Y+2, r25	; 0x02
    2fe2:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    2fe4:	0f b6       	in	r0, 0x3f	; 63
    2fe6:	f8 94       	cli
    2fe8:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    2fea:	80 91 f6 02 	lds	r24, 0x02F6
    2fee:	8f 5f       	subi	r24, 0xFF	; 255
    2ff0:	80 93 f6 02 	sts	0x02F6, r24
		if( pxCurrentTCB == NULL )
    2ff4:	80 91 f4 02 	lds	r24, 0x02F4
    2ff8:	90 91 f5 02 	lds	r25, 0x02F5
    2ffc:	00 97       	sbiw	r24, 0x00	; 0
    2ffe:	69 f4       	brne	.+26     	; 0x301a <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3000:	89 81       	ldd	r24, Y+1	; 0x01
    3002:	9a 81       	ldd	r25, Y+2	; 0x02
    3004:	90 93 f5 02 	sts	0x02F5, r25
    3008:	80 93 f4 02 	sts	0x02F4, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    300c:	80 91 f6 02 	lds	r24, 0x02F6
    3010:	81 30       	cpi	r24, 0x01	; 1
    3012:	b9 f4       	brne	.+46     	; 0x3042 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3014:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <prvInitialiseTaskLists>
    3018:	14 c0       	rjmp	.+40     	; 0x3042 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    301a:	80 91 fa 02 	lds	r24, 0x02FA
    301e:	88 23       	and	r24, r24
    3020:	81 f4       	brne	.+32     	; 0x3042 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3022:	e0 91 f4 02 	lds	r30, 0x02F4
    3026:	f0 91 f5 02 	lds	r31, 0x02F5
    302a:	96 89       	ldd	r25, Z+22	; 0x16
    302c:	e9 81       	ldd	r30, Y+1	; 0x01
    302e:	fa 81       	ldd	r31, Y+2	; 0x02
    3030:	86 89       	ldd	r24, Z+22	; 0x16
    3032:	89 17       	cp	r24, r25
    3034:	30 f0       	brcs	.+12     	; 0x3042 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    3036:	89 81       	ldd	r24, Y+1	; 0x01
    3038:	9a 81       	ldd	r25, Y+2	; 0x02
    303a:	90 93 f5 02 	sts	0x02F5, r25
    303e:	80 93 f4 02 	sts	0x02F4, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3042:	80 91 fe 02 	lds	r24, 0x02FE
    3046:	8f 5f       	subi	r24, 0xFF	; 255
    3048:	80 93 fe 02 	sts	0x02FE, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    304c:	e9 81       	ldd	r30, Y+1	; 0x01
    304e:	fa 81       	ldd	r31, Y+2	; 0x02
    3050:	96 89       	ldd	r25, Z+22	; 0x16
    3052:	80 91 f9 02 	lds	r24, 0x02F9
    3056:	89 17       	cp	r24, r25
    3058:	28 f4       	brcc	.+10     	; 0x3064 <prvAddNewTaskToReadyList+0x8e>
    305a:	e9 81       	ldd	r30, Y+1	; 0x01
    305c:	fa 81       	ldd	r31, Y+2	; 0x02
    305e:	86 89       	ldd	r24, Z+22	; 0x16
    3060:	80 93 f9 02 	sts	0x02F9, r24
    3064:	e9 81       	ldd	r30, Y+1	; 0x01
    3066:	fa 81       	ldd	r31, Y+2	; 0x02
    3068:	86 89       	ldd	r24, Z+22	; 0x16
    306a:	28 2f       	mov	r18, r24
    306c:	30 e0       	ldi	r19, 0x00	; 0
    306e:	c9 01       	movw	r24, r18
    3070:	88 0f       	add	r24, r24
    3072:	99 1f       	adc	r25, r25
    3074:	88 0f       	add	r24, r24
    3076:	99 1f       	adc	r25, r25
    3078:	88 0f       	add	r24, r24
    307a:	99 1f       	adc	r25, r25
    307c:	82 0f       	add	r24, r18
    307e:	93 1f       	adc	r25, r19
    3080:	ac 01       	movw	r20, r24
    3082:	4c 5f       	subi	r20, 0xFC	; 252
    3084:	5c 4f       	sbci	r21, 0xFC	; 252
    3086:	89 81       	ldd	r24, Y+1	; 0x01
    3088:	9a 81       	ldd	r25, Y+2	; 0x02
    308a:	9c 01       	movw	r18, r24
    308c:	2e 5f       	subi	r18, 0xFE	; 254
    308e:	3f 4f       	sbci	r19, 0xFF	; 255
    3090:	ca 01       	movw	r24, r20
    3092:	b9 01       	movw	r22, r18
    3094:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3098:	0f 90       	pop	r0
    309a:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    309c:	80 91 fa 02 	lds	r24, 0x02FA
    30a0:	88 23       	and	r24, r24
    30a2:	61 f0       	breq	.+24     	; 0x30bc <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    30a4:	e0 91 f4 02 	lds	r30, 0x02F4
    30a8:	f0 91 f5 02 	lds	r31, 0x02F5
    30ac:	96 89       	ldd	r25, Z+22	; 0x16
    30ae:	e9 81       	ldd	r30, Y+1	; 0x01
    30b0:	fa 81       	ldd	r31, Y+2	; 0x02
    30b2:	86 89       	ldd	r24, Z+22	; 0x16
    30b4:	98 17       	cp	r25, r24
    30b6:	10 f4       	brcc	.+4      	; 0x30bc <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    30b8:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    30bc:	0f 90       	pop	r0
    30be:	0f 90       	pop	r0
    30c0:	cf 91       	pop	r28
    30c2:	df 91       	pop	r29
    30c4:	08 95       	ret

000030c6 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    30c6:	df 93       	push	r29
    30c8:	cf 93       	push	r28
    30ca:	cd b7       	in	r28, 0x3d	; 61
    30cc:	de b7       	in	r29, 0x3e	; 62
    30ce:	2a 97       	sbiw	r28, 0x0a	; 10
    30d0:	0f b6       	in	r0, 0x3f	; 63
    30d2:	f8 94       	cli
    30d4:	de bf       	out	0x3e, r29	; 62
    30d6:	0f be       	out	0x3f, r0	; 63
    30d8:	cd bf       	out	0x3d, r28	; 61
    30da:	98 87       	std	Y+8, r25	; 0x08
    30dc:	8f 83       	std	Y+7, r24	; 0x07
    30de:	7a 87       	std	Y+10, r23	; 0x0a
    30e0:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    30e2:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    30e4:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    30e8:	80 91 f7 02 	lds	r24, 0x02F7
    30ec:	90 91 f8 02 	lds	r25, 0x02F8
    30f0:	9a 83       	std	Y+2, r25	; 0x02
    30f2:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    30f4:	ef 81       	ldd	r30, Y+7	; 0x07
    30f6:	f8 85       	ldd	r31, Y+8	; 0x08
    30f8:	20 81       	ld	r18, Z
    30fa:	31 81       	ldd	r19, Z+1	; 0x01
    30fc:	89 85       	ldd	r24, Y+9	; 0x09
    30fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    3100:	82 0f       	add	r24, r18
    3102:	93 1f       	adc	r25, r19
    3104:	9e 83       	std	Y+6, r25	; 0x06
    3106:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    3108:	ef 81       	ldd	r30, Y+7	; 0x07
    310a:	f8 85       	ldd	r31, Y+8	; 0x08
    310c:	20 81       	ld	r18, Z
    310e:	31 81       	ldd	r19, Z+1	; 0x01
    3110:	89 81       	ldd	r24, Y+1	; 0x01
    3112:	9a 81       	ldd	r25, Y+2	; 0x02
    3114:	82 17       	cp	r24, r18
    3116:	93 07       	cpc	r25, r19
    3118:	98 f4       	brcc	.+38     	; 0x3140 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    311a:	ef 81       	ldd	r30, Y+7	; 0x07
    311c:	f8 85       	ldd	r31, Y+8	; 0x08
    311e:	20 81       	ld	r18, Z
    3120:	31 81       	ldd	r19, Z+1	; 0x01
    3122:	8d 81       	ldd	r24, Y+5	; 0x05
    3124:	9e 81       	ldd	r25, Y+6	; 0x06
    3126:	82 17       	cp	r24, r18
    3128:	93 07       	cpc	r25, r19
    312a:	e0 f4       	brcc	.+56     	; 0x3164 <vTaskDelayUntil+0x9e>
    312c:	2d 81       	ldd	r18, Y+5	; 0x05
    312e:	3e 81       	ldd	r19, Y+6	; 0x06
    3130:	89 81       	ldd	r24, Y+1	; 0x01
    3132:	9a 81       	ldd	r25, Y+2	; 0x02
    3134:	82 17       	cp	r24, r18
    3136:	93 07       	cpc	r25, r19
    3138:	a8 f4       	brcc	.+42     	; 0x3164 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    313a:	81 e0       	ldi	r24, 0x01	; 1
    313c:	8b 83       	std	Y+3, r24	; 0x03
    313e:	12 c0       	rjmp	.+36     	; 0x3164 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3140:	ef 81       	ldd	r30, Y+7	; 0x07
    3142:	f8 85       	ldd	r31, Y+8	; 0x08
    3144:	20 81       	ld	r18, Z
    3146:	31 81       	ldd	r19, Z+1	; 0x01
    3148:	8d 81       	ldd	r24, Y+5	; 0x05
    314a:	9e 81       	ldd	r25, Y+6	; 0x06
    314c:	82 17       	cp	r24, r18
    314e:	93 07       	cpc	r25, r19
    3150:	38 f0       	brcs	.+14     	; 0x3160 <vTaskDelayUntil+0x9a>
    3152:	2d 81       	ldd	r18, Y+5	; 0x05
    3154:	3e 81       	ldd	r19, Y+6	; 0x06
    3156:	89 81       	ldd	r24, Y+1	; 0x01
    3158:	9a 81       	ldd	r25, Y+2	; 0x02
    315a:	82 17       	cp	r24, r18
    315c:	93 07       	cpc	r25, r19
    315e:	10 f4       	brcc	.+4      	; 0x3164 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3160:	81 e0       	ldi	r24, 0x01	; 1
    3162:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3164:	ef 81       	ldd	r30, Y+7	; 0x07
    3166:	f8 85       	ldd	r31, Y+8	; 0x08
    3168:	8d 81       	ldd	r24, Y+5	; 0x05
    316a:	9e 81       	ldd	r25, Y+6	; 0x06
    316c:	91 83       	std	Z+1, r25	; 0x01
    316e:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    3170:	8b 81       	ldd	r24, Y+3	; 0x03
    3172:	88 23       	and	r24, r24
    3174:	49 f0       	breq	.+18     	; 0x3188 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3176:	8d 81       	ldd	r24, Y+5	; 0x05
    3178:	9e 81       	ldd	r25, Y+6	; 0x06
    317a:	29 81       	ldd	r18, Y+1	; 0x01
    317c:	3a 81       	ldd	r19, Y+2	; 0x02
    317e:	82 1b       	sub	r24, r18
    3180:	93 0b       	sbc	r25, r19
    3182:	60 e0       	ldi	r22, 0x00	; 0
    3184:	0e 94 85 21 	call	0x430a	; 0x430a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3188:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    318c:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    318e:	8c 81       	ldd	r24, Y+4	; 0x04
    3190:	88 23       	and	r24, r24
    3192:	11 f4       	brne	.+4      	; 0x3198 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    3194:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3198:	2a 96       	adiw	r28, 0x0a	; 10
    319a:	0f b6       	in	r0, 0x3f	; 63
    319c:	f8 94       	cli
    319e:	de bf       	out	0x3e, r29	; 62
    31a0:	0f be       	out	0x3f, r0	; 63
    31a2:	cd bf       	out	0x3d, r28	; 61
    31a4:	cf 91       	pop	r28
    31a6:	df 91       	pop	r29
    31a8:	08 95       	ret

000031aa <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    31aa:	df 93       	push	r29
    31ac:	cf 93       	push	r28
    31ae:	00 d0       	rcall	.+0      	; 0x31b0 <vTaskDelay+0x6>
    31b0:	0f 92       	push	r0
    31b2:	cd b7       	in	r28, 0x3d	; 61
    31b4:	de b7       	in	r29, 0x3e	; 62
    31b6:	9b 83       	std	Y+3, r25	; 0x03
    31b8:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    31ba:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    31bc:	8a 81       	ldd	r24, Y+2	; 0x02
    31be:	9b 81       	ldd	r25, Y+3	; 0x03
    31c0:	00 97       	sbiw	r24, 0x00	; 0
    31c2:	51 f0       	breq	.+20     	; 0x31d8 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    31c4:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    31c8:	8a 81       	ldd	r24, Y+2	; 0x02
    31ca:	9b 81       	ldd	r25, Y+3	; 0x03
    31cc:	60 e0       	ldi	r22, 0x00	; 0
    31ce:	0e 94 85 21 	call	0x430a	; 0x430a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    31d2:	0e 94 41 19 	call	0x3282	; 0x3282 <xTaskResumeAll>
    31d6:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    31d8:	89 81       	ldd	r24, Y+1	; 0x01
    31da:	88 23       	and	r24, r24
    31dc:	11 f4       	brne	.+4      	; 0x31e2 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    31de:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    31e2:	0f 90       	pop	r0
    31e4:	0f 90       	pop	r0
    31e6:	0f 90       	pop	r0
    31e8:	cf 91       	pop	r28
    31ea:	df 91       	pop	r29
    31ec:	08 95       	ret

000031ee <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    31ee:	ef 92       	push	r14
    31f0:	ff 92       	push	r15
    31f2:	0f 93       	push	r16
    31f4:	df 93       	push	r29
    31f6:	cf 93       	push	r28
    31f8:	0f 92       	push	r0
    31fa:	cd b7       	in	r28, 0x3d	; 61
    31fc:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    31fe:	81 e4       	ldi	r24, 0x41	; 65
    3200:	9d e1       	ldi	r25, 0x1D	; 29
    3202:	22 e7       	ldi	r18, 0x72	; 114
    3204:	30 e0       	ldi	r19, 0x00	; 0
    3206:	e1 e0       	ldi	r30, 0x01	; 1
    3208:	f3 e0       	ldi	r31, 0x03	; 3
    320a:	b9 01       	movw	r22, r18
    320c:	45 e5       	ldi	r20, 0x55	; 85
    320e:	50 e0       	ldi	r21, 0x00	; 0
    3210:	20 e0       	ldi	r18, 0x00	; 0
    3212:	30 e0       	ldi	r19, 0x00	; 0
    3214:	00 e0       	ldi	r16, 0x00	; 0
    3216:	7f 01       	movw	r14, r30
    3218:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <xTaskCreate>
    321c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    321e:	89 81       	ldd	r24, Y+1	; 0x01
    3220:	81 30       	cpi	r24, 0x01	; 1
    3222:	81 f4       	brne	.+32     	; 0x3244 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3224:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    3226:	8f ef       	ldi	r24, 0xFF	; 255
    3228:	9f ef       	ldi	r25, 0xFF	; 255
    322a:	90 93 00 03 	sts	0x0300, r25
    322e:	80 93 ff 02 	sts	0x02FF, r24
		xSchedulerRunning = pdTRUE;
    3232:	81 e0       	ldi	r24, 0x01	; 1
    3234:	80 93 fa 02 	sts	0x02FA, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3238:	10 92 f8 02 	sts	0x02F8, r1
    323c:	10 92 f7 02 	sts	0x02F7, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3240:	0e 94 44 0e 	call	0x1c88	; 0x1c88 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    3244:	0f 90       	pop	r0
    3246:	cf 91       	pop	r28
    3248:	df 91       	pop	r29
    324a:	0f 91       	pop	r16
    324c:	ff 90       	pop	r15
    324e:	ef 90       	pop	r14
    3250:	08 95       	ret

00003252 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3252:	df 93       	push	r29
    3254:	cf 93       	push	r28
    3256:	cd b7       	in	r28, 0x3d	; 61
    3258:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    325a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    325c:	10 92 fa 02 	sts	0x02FA, r1
	vPortEndScheduler();
    3260:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vPortEndScheduler>
}
    3264:	cf 91       	pop	r28
    3266:	df 91       	pop	r29
    3268:	08 95       	ret

0000326a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    326a:	df 93       	push	r29
    326c:	cf 93       	push	r28
    326e:	cd b7       	in	r28, 0x3d	; 61
    3270:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3272:	80 91 03 03 	lds	r24, 0x0303
    3276:	8f 5f       	subi	r24, 0xFF	; 255
    3278:	80 93 03 03 	sts	0x0303, r24
	portMEMORY_BARRIER();
}
    327c:	cf 91       	pop	r28
    327e:	df 91       	pop	r29
    3280:	08 95       	ret

00003282 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3282:	df 93       	push	r29
    3284:	cf 93       	push	r28
    3286:	00 d0       	rcall	.+0      	; 0x3288 <xTaskResumeAll+0x6>
    3288:	00 d0       	rcall	.+0      	; 0x328a <xTaskResumeAll+0x8>
    328a:	cd b7       	in	r28, 0x3d	; 61
    328c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    328e:	1c 82       	std	Y+4, r1	; 0x04
    3290:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    3292:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3294:	0f b6       	in	r0, 0x3f	; 63
    3296:	f8 94       	cli
    3298:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    329a:	80 91 03 03 	lds	r24, 0x0303
    329e:	81 50       	subi	r24, 0x01	; 1
    32a0:	80 93 03 03 	sts	0x0303, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    32a4:	80 91 03 03 	lds	r24, 0x0303
    32a8:	88 23       	and	r24, r24
    32aa:	09 f0       	breq	.+2      	; 0x32ae <xTaskResumeAll+0x2c>
    32ac:	73 c0       	rjmp	.+230    	; 0x3394 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    32ae:	80 91 f6 02 	lds	r24, 0x02F6
    32b2:	88 23       	and	r24, r24
    32b4:	09 f4       	brne	.+2      	; 0x32b8 <xTaskResumeAll+0x36>
    32b6:	6e c0       	rjmp	.+220    	; 0x3394 <xTaskResumeAll+0x112>
    32b8:	45 c0       	rjmp	.+138    	; 0x3344 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    32ba:	e0 91 43 03 	lds	r30, 0x0343
    32be:	f0 91 44 03 	lds	r31, 0x0344
    32c2:	86 81       	ldd	r24, Z+6	; 0x06
    32c4:	97 81       	ldd	r25, Z+7	; 0x07
    32c6:	9c 83       	std	Y+4, r25	; 0x04
    32c8:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    32ca:	8b 81       	ldd	r24, Y+3	; 0x03
    32cc:	9c 81       	ldd	r25, Y+4	; 0x04
    32ce:	0c 96       	adiw	r24, 0x0c	; 12
    32d0:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    32d4:	8b 81       	ldd	r24, Y+3	; 0x03
    32d6:	9c 81       	ldd	r25, Y+4	; 0x04
    32d8:	02 96       	adiw	r24, 0x02	; 2
    32da:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    32de:	eb 81       	ldd	r30, Y+3	; 0x03
    32e0:	fc 81       	ldd	r31, Y+4	; 0x04
    32e2:	96 89       	ldd	r25, Z+22	; 0x16
    32e4:	80 91 f9 02 	lds	r24, 0x02F9
    32e8:	89 17       	cp	r24, r25
    32ea:	28 f4       	brcc	.+10     	; 0x32f6 <xTaskResumeAll+0x74>
    32ec:	eb 81       	ldd	r30, Y+3	; 0x03
    32ee:	fc 81       	ldd	r31, Y+4	; 0x04
    32f0:	86 89       	ldd	r24, Z+22	; 0x16
    32f2:	80 93 f9 02 	sts	0x02F9, r24
    32f6:	eb 81       	ldd	r30, Y+3	; 0x03
    32f8:	fc 81       	ldd	r31, Y+4	; 0x04
    32fa:	86 89       	ldd	r24, Z+22	; 0x16
    32fc:	28 2f       	mov	r18, r24
    32fe:	30 e0       	ldi	r19, 0x00	; 0
    3300:	c9 01       	movw	r24, r18
    3302:	88 0f       	add	r24, r24
    3304:	99 1f       	adc	r25, r25
    3306:	88 0f       	add	r24, r24
    3308:	99 1f       	adc	r25, r25
    330a:	88 0f       	add	r24, r24
    330c:	99 1f       	adc	r25, r25
    330e:	82 0f       	add	r24, r18
    3310:	93 1f       	adc	r25, r19
    3312:	ac 01       	movw	r20, r24
    3314:	4c 5f       	subi	r20, 0xFC	; 252
    3316:	5c 4f       	sbci	r21, 0xFC	; 252
    3318:	8b 81       	ldd	r24, Y+3	; 0x03
    331a:	9c 81       	ldd	r25, Y+4	; 0x04
    331c:	9c 01       	movw	r18, r24
    331e:	2e 5f       	subi	r18, 0xFE	; 254
    3320:	3f 4f       	sbci	r19, 0xFF	; 255
    3322:	ca 01       	movw	r24, r20
    3324:	b9 01       	movw	r22, r18
    3326:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    332a:	eb 81       	ldd	r30, Y+3	; 0x03
    332c:	fc 81       	ldd	r31, Y+4	; 0x04
    332e:	96 89       	ldd	r25, Z+22	; 0x16
    3330:	e0 91 f4 02 	lds	r30, 0x02F4
    3334:	f0 91 f5 02 	lds	r31, 0x02F5
    3338:	86 89       	ldd	r24, Z+22	; 0x16
    333a:	98 17       	cp	r25, r24
    333c:	18 f0       	brcs	.+6      	; 0x3344 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    333e:	81 e0       	ldi	r24, 0x01	; 1
    3340:	80 93 fc 02 	sts	0x02FC, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3344:	80 91 3e 03 	lds	r24, 0x033E
    3348:	88 23       	and	r24, r24
    334a:	09 f0       	breq	.+2      	; 0x334e <xTaskResumeAll+0xcc>
    334c:	b6 cf       	rjmp	.-148    	; 0x32ba <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    334e:	8b 81       	ldd	r24, Y+3	; 0x03
    3350:	9c 81       	ldd	r25, Y+4	; 0x04
    3352:	00 97       	sbiw	r24, 0x00	; 0
    3354:	11 f0       	breq	.+4      	; 0x335a <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    3356:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    335a:	80 91 fb 02 	lds	r24, 0x02FB
    335e:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    3360:	89 81       	ldd	r24, Y+1	; 0x01
    3362:	88 23       	and	r24, r24
    3364:	79 f0       	breq	.+30     	; 0x3384 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    3366:	0e 94 31 1a 	call	0x3462	; 0x3462 <xTaskIncrementTick>
    336a:	88 23       	and	r24, r24
    336c:	19 f0       	breq	.+6      	; 0x3374 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    336e:	81 e0       	ldi	r24, 0x01	; 1
    3370:	80 93 fc 02 	sts	0x02FC, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    3374:	89 81       	ldd	r24, Y+1	; 0x01
    3376:	81 50       	subi	r24, 0x01	; 1
    3378:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    337a:	89 81       	ldd	r24, Y+1	; 0x01
    337c:	88 23       	and	r24, r24
    337e:	99 f7       	brne	.-26     	; 0x3366 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    3380:	10 92 fb 02 	sts	0x02FB, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    3384:	80 91 fc 02 	lds	r24, 0x02FC
    3388:	88 23       	and	r24, r24
    338a:	21 f0       	breq	.+8      	; 0x3394 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    338c:	81 e0       	ldi	r24, 0x01	; 1
    338e:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3390:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3394:	0f 90       	pop	r0
    3396:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3398:	8a 81       	ldd	r24, Y+2	; 0x02
}
    339a:	0f 90       	pop	r0
    339c:	0f 90       	pop	r0
    339e:	0f 90       	pop	r0
    33a0:	0f 90       	pop	r0
    33a2:	cf 91       	pop	r28
    33a4:	df 91       	pop	r29
    33a6:	08 95       	ret

000033a8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    33a8:	df 93       	push	r29
    33aa:	cf 93       	push	r28
    33ac:	00 d0       	rcall	.+0      	; 0x33ae <xTaskGetTickCount+0x6>
    33ae:	cd b7       	in	r28, 0x3d	; 61
    33b0:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    33b2:	0f b6       	in	r0, 0x3f	; 63
    33b4:	f8 94       	cli
    33b6:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    33b8:	80 91 f7 02 	lds	r24, 0x02F7
    33bc:	90 91 f8 02 	lds	r25, 0x02F8
    33c0:	9a 83       	std	Y+2, r25	; 0x02
    33c2:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    33c4:	0f 90       	pop	r0
    33c6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    33c8:	89 81       	ldd	r24, Y+1	; 0x01
    33ca:	9a 81       	ldd	r25, Y+2	; 0x02
}
    33cc:	0f 90       	pop	r0
    33ce:	0f 90       	pop	r0
    33d0:	cf 91       	pop	r28
    33d2:	df 91       	pop	r29
    33d4:	08 95       	ret

000033d6 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    33d6:	df 93       	push	r29
    33d8:	cf 93       	push	r28
    33da:	00 d0       	rcall	.+0      	; 0x33dc <xTaskGetTickCountFromISR+0x6>
    33dc:	0f 92       	push	r0
    33de:	cd b7       	in	r28, 0x3d	; 61
    33e0:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    33e2:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    33e4:	80 91 f7 02 	lds	r24, 0x02F7
    33e8:	90 91 f8 02 	lds	r25, 0x02F8
    33ec:	9b 83       	std	Y+3, r25	; 0x03
    33ee:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    33f0:	8a 81       	ldd	r24, Y+2	; 0x02
    33f2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    33f4:	0f 90       	pop	r0
    33f6:	0f 90       	pop	r0
    33f8:	0f 90       	pop	r0
    33fa:	cf 91       	pop	r28
    33fc:	df 91       	pop	r29
    33fe:	08 95       	ret

00003400 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3400:	df 93       	push	r29
    3402:	cf 93       	push	r28
    3404:	cd b7       	in	r28, 0x3d	; 61
    3406:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3408:	80 91 f6 02 	lds	r24, 0x02F6
}
    340c:	cf 91       	pop	r28
    340e:	df 91       	pop	r29
    3410:	08 95       	ret

00003412 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3412:	df 93       	push	r29
    3414:	cf 93       	push	r28
    3416:	00 d0       	rcall	.+0      	; 0x3418 <pcTaskGetName+0x6>
    3418:	00 d0       	rcall	.+0      	; 0x341a <pcTaskGetName+0x8>
    341a:	00 d0       	rcall	.+0      	; 0x341c <pcTaskGetName+0xa>
    341c:	cd b7       	in	r28, 0x3d	; 61
    341e:	de b7       	in	r29, 0x3e	; 62
    3420:	9c 83       	std	Y+4, r25	; 0x04
    3422:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3424:	8b 81       	ldd	r24, Y+3	; 0x03
    3426:	9c 81       	ldd	r25, Y+4	; 0x04
    3428:	00 97       	sbiw	r24, 0x00	; 0
    342a:	39 f4       	brne	.+14     	; 0x343a <pcTaskGetName+0x28>
    342c:	80 91 f4 02 	lds	r24, 0x02F4
    3430:	90 91 f5 02 	lds	r25, 0x02F5
    3434:	9e 83       	std	Y+6, r25	; 0x06
    3436:	8d 83       	std	Y+5, r24	; 0x05
    3438:	04 c0       	rjmp	.+8      	; 0x3442 <pcTaskGetName+0x30>
    343a:	8b 81       	ldd	r24, Y+3	; 0x03
    343c:	9c 81       	ldd	r25, Y+4	; 0x04
    343e:	9e 83       	std	Y+6, r25	; 0x06
    3440:	8d 83       	std	Y+5, r24	; 0x05
    3442:	8d 81       	ldd	r24, Y+5	; 0x05
    3444:	9e 81       	ldd	r25, Y+6	; 0x06
    3446:	9a 83       	std	Y+2, r25	; 0x02
    3448:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    344a:	89 81       	ldd	r24, Y+1	; 0x01
    344c:	9a 81       	ldd	r25, Y+2	; 0x02
    344e:	49 96       	adiw	r24, 0x19	; 25
}
    3450:	26 96       	adiw	r28, 0x06	; 6
    3452:	0f b6       	in	r0, 0x3f	; 63
    3454:	f8 94       	cli
    3456:	de bf       	out	0x3e, r29	; 62
    3458:	0f be       	out	0x3f, r0	; 63
    345a:	cd bf       	out	0x3d, r28	; 61
    345c:	cf 91       	pop	r28
    345e:	df 91       	pop	r29
    3460:	08 95       	ret

00003462 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3462:	df 93       	push	r29
    3464:	cf 93       	push	r28
    3466:	cd b7       	in	r28, 0x3d	; 61
    3468:	de b7       	in	r29, 0x3e	; 62
    346a:	29 97       	sbiw	r28, 0x09	; 9
    346c:	0f b6       	in	r0, 0x3f	; 63
    346e:	f8 94       	cli
    3470:	de bf       	out	0x3e, r29	; 62
    3472:	0f be       	out	0x3f, r0	; 63
    3474:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3476:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3478:	80 91 03 03 	lds	r24, 0x0303
    347c:	88 23       	and	r24, r24
    347e:	09 f0       	breq	.+2      	; 0x3482 <xTaskIncrementTick+0x20>
    3480:	c0 c0       	rjmp	.+384    	; 0x3602 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3482:	80 91 f7 02 	lds	r24, 0x02F7
    3486:	90 91 f8 02 	lds	r25, 0x02F8
    348a:	01 96       	adiw	r24, 0x01	; 1
    348c:	9c 83       	std	Y+4, r25	; 0x04
    348e:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    3490:	8b 81       	ldd	r24, Y+3	; 0x03
    3492:	9c 81       	ldd	r25, Y+4	; 0x04
    3494:	90 93 f8 02 	sts	0x02F8, r25
    3498:	80 93 f7 02 	sts	0x02F7, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    349c:	8b 81       	ldd	r24, Y+3	; 0x03
    349e:	9c 81       	ldd	r25, Y+4	; 0x04
    34a0:	00 97       	sbiw	r24, 0x00	; 0
    34a2:	d9 f4       	brne	.+54     	; 0x34da <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    34a4:	80 91 3a 03 	lds	r24, 0x033A
    34a8:	90 91 3b 03 	lds	r25, 0x033B
    34ac:	9a 83       	std	Y+2, r25	; 0x02
    34ae:	89 83       	std	Y+1, r24	; 0x01
    34b0:	80 91 3c 03 	lds	r24, 0x033C
    34b4:	90 91 3d 03 	lds	r25, 0x033D
    34b8:	90 93 3b 03 	sts	0x033B, r25
    34bc:	80 93 3a 03 	sts	0x033A, r24
    34c0:	89 81       	ldd	r24, Y+1	; 0x01
    34c2:	9a 81       	ldd	r25, Y+2	; 0x02
    34c4:	90 93 3d 03 	sts	0x033D, r25
    34c8:	80 93 3c 03 	sts	0x033C, r24
    34cc:	80 91 fd 02 	lds	r24, 0x02FD
    34d0:	8f 5f       	subi	r24, 0xFF	; 255
    34d2:	80 93 fd 02 	sts	0x02FD, r24
    34d6:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    34da:	20 91 ff 02 	lds	r18, 0x02FF
    34de:	30 91 00 03 	lds	r19, 0x0300
    34e2:	8b 81       	ldd	r24, Y+3	; 0x03
    34e4:	9c 81       	ldd	r25, Y+4	; 0x04
    34e6:	82 17       	cp	r24, r18
    34e8:	93 07       	cpc	r25, r19
    34ea:	08 f4       	brcc	.+2      	; 0x34ee <xTaskIncrementTick+0x8c>
    34ec:	71 c0       	rjmp	.+226    	; 0x35d0 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    34ee:	e0 91 3a 03 	lds	r30, 0x033A
    34f2:	f0 91 3b 03 	lds	r31, 0x033B
    34f6:	80 81       	ld	r24, Z
    34f8:	88 23       	and	r24, r24
    34fa:	39 f4       	brne	.+14     	; 0x350a <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    34fc:	8f ef       	ldi	r24, 0xFF	; 255
    34fe:	9f ef       	ldi	r25, 0xFF	; 255
    3500:	90 93 00 03 	sts	0x0300, r25
    3504:	80 93 ff 02 	sts	0x02FF, r24
    3508:	63 c0       	rjmp	.+198    	; 0x35d0 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    350a:	e0 91 3a 03 	lds	r30, 0x033A
    350e:	f0 91 3b 03 	lds	r31, 0x033B
    3512:	05 80       	ldd	r0, Z+5	; 0x05
    3514:	f6 81       	ldd	r31, Z+6	; 0x06
    3516:	e0 2d       	mov	r30, r0
    3518:	86 81       	ldd	r24, Z+6	; 0x06
    351a:	97 81       	ldd	r25, Z+7	; 0x07
    351c:	99 87       	std	Y+9, r25	; 0x09
    351e:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3520:	e8 85       	ldd	r30, Y+8	; 0x08
    3522:	f9 85       	ldd	r31, Y+9	; 0x09
    3524:	82 81       	ldd	r24, Z+2	; 0x02
    3526:	93 81       	ldd	r25, Z+3	; 0x03
    3528:	9f 83       	std	Y+7, r25	; 0x07
    352a:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    352c:	2b 81       	ldd	r18, Y+3	; 0x03
    352e:	3c 81       	ldd	r19, Y+4	; 0x04
    3530:	8e 81       	ldd	r24, Y+6	; 0x06
    3532:	9f 81       	ldd	r25, Y+7	; 0x07
    3534:	28 17       	cp	r18, r24
    3536:	39 07       	cpc	r19, r25
    3538:	38 f4       	brcc	.+14     	; 0x3548 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    353a:	8e 81       	ldd	r24, Y+6	; 0x06
    353c:	9f 81       	ldd	r25, Y+7	; 0x07
    353e:	90 93 00 03 	sts	0x0300, r25
    3542:	80 93 ff 02 	sts	0x02FF, r24
    3546:	44 c0       	rjmp	.+136    	; 0x35d0 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3548:	88 85       	ldd	r24, Y+8	; 0x08
    354a:	99 85       	ldd	r25, Y+9	; 0x09
    354c:	02 96       	adiw	r24, 0x02	; 2
    354e:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3552:	e8 85       	ldd	r30, Y+8	; 0x08
    3554:	f9 85       	ldd	r31, Y+9	; 0x09
    3556:	84 89       	ldd	r24, Z+20	; 0x14
    3558:	95 89       	ldd	r25, Z+21	; 0x15
    355a:	00 97       	sbiw	r24, 0x00	; 0
    355c:	29 f0       	breq	.+10     	; 0x3568 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    355e:	88 85       	ldd	r24, Y+8	; 0x08
    3560:	99 85       	ldd	r25, Y+9	; 0x09
    3562:	0c 96       	adiw	r24, 0x0c	; 12
    3564:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    3568:	e8 85       	ldd	r30, Y+8	; 0x08
    356a:	f9 85       	ldd	r31, Y+9	; 0x09
    356c:	96 89       	ldd	r25, Z+22	; 0x16
    356e:	80 91 f9 02 	lds	r24, 0x02F9
    3572:	89 17       	cp	r24, r25
    3574:	28 f4       	brcc	.+10     	; 0x3580 <xTaskIncrementTick+0x11e>
    3576:	e8 85       	ldd	r30, Y+8	; 0x08
    3578:	f9 85       	ldd	r31, Y+9	; 0x09
    357a:	86 89       	ldd	r24, Z+22	; 0x16
    357c:	80 93 f9 02 	sts	0x02F9, r24
    3580:	e8 85       	ldd	r30, Y+8	; 0x08
    3582:	f9 85       	ldd	r31, Y+9	; 0x09
    3584:	86 89       	ldd	r24, Z+22	; 0x16
    3586:	28 2f       	mov	r18, r24
    3588:	30 e0       	ldi	r19, 0x00	; 0
    358a:	c9 01       	movw	r24, r18
    358c:	88 0f       	add	r24, r24
    358e:	99 1f       	adc	r25, r25
    3590:	88 0f       	add	r24, r24
    3592:	99 1f       	adc	r25, r25
    3594:	88 0f       	add	r24, r24
    3596:	99 1f       	adc	r25, r25
    3598:	82 0f       	add	r24, r18
    359a:	93 1f       	adc	r25, r19
    359c:	ac 01       	movw	r20, r24
    359e:	4c 5f       	subi	r20, 0xFC	; 252
    35a0:	5c 4f       	sbci	r21, 0xFC	; 252
    35a2:	88 85       	ldd	r24, Y+8	; 0x08
    35a4:	99 85       	ldd	r25, Y+9	; 0x09
    35a6:	9c 01       	movw	r18, r24
    35a8:	2e 5f       	subi	r18, 0xFE	; 254
    35aa:	3f 4f       	sbci	r19, 0xFF	; 255
    35ac:	ca 01       	movw	r24, r20
    35ae:	b9 01       	movw	r22, r18
    35b0:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    35b4:	e8 85       	ldd	r30, Y+8	; 0x08
    35b6:	f9 85       	ldd	r31, Y+9	; 0x09
    35b8:	96 89       	ldd	r25, Z+22	; 0x16
    35ba:	e0 91 f4 02 	lds	r30, 0x02F4
    35be:	f0 91 f5 02 	lds	r31, 0x02F5
    35c2:	86 89       	ldd	r24, Z+22	; 0x16
    35c4:	98 17       	cp	r25, r24
    35c6:	08 f4       	brcc	.+2      	; 0x35ca <xTaskIncrementTick+0x168>
    35c8:	92 cf       	rjmp	.-220    	; 0x34ee <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    35ca:	81 e0       	ldi	r24, 0x01	; 1
    35cc:	8d 83       	std	Y+5, r24	; 0x05
    35ce:	8f cf       	rjmp	.-226    	; 0x34ee <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    35d0:	e0 91 f4 02 	lds	r30, 0x02F4
    35d4:	f0 91 f5 02 	lds	r31, 0x02F5
    35d8:	86 89       	ldd	r24, Z+22	; 0x16
    35da:	28 2f       	mov	r18, r24
    35dc:	30 e0       	ldi	r19, 0x00	; 0
    35de:	c9 01       	movw	r24, r18
    35e0:	88 0f       	add	r24, r24
    35e2:	99 1f       	adc	r25, r25
    35e4:	88 0f       	add	r24, r24
    35e6:	99 1f       	adc	r25, r25
    35e8:	88 0f       	add	r24, r24
    35ea:	99 1f       	adc	r25, r25
    35ec:	82 0f       	add	r24, r18
    35ee:	93 1f       	adc	r25, r19
    35f0:	fc 01       	movw	r30, r24
    35f2:	ec 5f       	subi	r30, 0xFC	; 252
    35f4:	fc 4f       	sbci	r31, 0xFC	; 252
    35f6:	80 81       	ld	r24, Z
    35f8:	82 30       	cpi	r24, 0x02	; 2
    35fa:	40 f0       	brcs	.+16     	; 0x360c <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    35fc:	81 e0       	ldi	r24, 0x01	; 1
    35fe:	8d 83       	std	Y+5, r24	; 0x05
    3600:	05 c0       	rjmp	.+10     	; 0x360c <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3602:	80 91 fb 02 	lds	r24, 0x02FB
    3606:	8f 5f       	subi	r24, 0xFF	; 255
    3608:	80 93 fb 02 	sts	0x02FB, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    360c:	80 91 fc 02 	lds	r24, 0x02FC
    3610:	88 23       	and	r24, r24
    3612:	11 f0       	breq	.+4      	; 0x3618 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    3614:	81 e0       	ldi	r24, 0x01	; 1
    3616:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3618:	8d 81       	ldd	r24, Y+5	; 0x05
}
    361a:	29 96       	adiw	r28, 0x09	; 9
    361c:	0f b6       	in	r0, 0x3f	; 63
    361e:	f8 94       	cli
    3620:	de bf       	out	0x3e, r29	; 62
    3622:	0f be       	out	0x3f, r0	; 63
    3624:	cd bf       	out	0x3d, r28	; 61
    3626:	cf 91       	pop	r28
    3628:	df 91       	pop	r29
    362a:	08 95       	ret

0000362c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    362c:	df 93       	push	r29
    362e:	cf 93       	push	r28
    3630:	00 d0       	rcall	.+0      	; 0x3632 <vTaskSwitchContext+0x6>
    3632:	0f 92       	push	r0
    3634:	cd b7       	in	r28, 0x3d	; 61
    3636:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3638:	80 91 03 03 	lds	r24, 0x0303
    363c:	88 23       	and	r24, r24
    363e:	21 f0       	breq	.+8      	; 0x3648 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3640:	81 e0       	ldi	r24, 0x01	; 1
    3642:	80 93 fc 02 	sts	0x02FC, r24
    3646:	59 c0       	rjmp	.+178    	; 0x36fa <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    3648:	10 92 fc 02 	sts	0x02FC, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    364c:	80 91 f9 02 	lds	r24, 0x02F9
    3650:	8b 83       	std	Y+3, r24	; 0x03
    3652:	03 c0       	rjmp	.+6      	; 0x365a <vTaskSwitchContext+0x2e>
    3654:	8b 81       	ldd	r24, Y+3	; 0x03
    3656:	81 50       	subi	r24, 0x01	; 1
    3658:	8b 83       	std	Y+3, r24	; 0x03
    365a:	8b 81       	ldd	r24, Y+3	; 0x03
    365c:	28 2f       	mov	r18, r24
    365e:	30 e0       	ldi	r19, 0x00	; 0
    3660:	c9 01       	movw	r24, r18
    3662:	88 0f       	add	r24, r24
    3664:	99 1f       	adc	r25, r25
    3666:	88 0f       	add	r24, r24
    3668:	99 1f       	adc	r25, r25
    366a:	88 0f       	add	r24, r24
    366c:	99 1f       	adc	r25, r25
    366e:	82 0f       	add	r24, r18
    3670:	93 1f       	adc	r25, r19
    3672:	fc 01       	movw	r30, r24
    3674:	ec 5f       	subi	r30, 0xFC	; 252
    3676:	fc 4f       	sbci	r31, 0xFC	; 252
    3678:	80 81       	ld	r24, Z
    367a:	88 23       	and	r24, r24
    367c:	59 f3       	breq	.-42     	; 0x3654 <vTaskSwitchContext+0x28>
    367e:	8b 81       	ldd	r24, Y+3	; 0x03
    3680:	28 2f       	mov	r18, r24
    3682:	30 e0       	ldi	r19, 0x00	; 0
    3684:	c9 01       	movw	r24, r18
    3686:	88 0f       	add	r24, r24
    3688:	99 1f       	adc	r25, r25
    368a:	88 0f       	add	r24, r24
    368c:	99 1f       	adc	r25, r25
    368e:	88 0f       	add	r24, r24
    3690:	99 1f       	adc	r25, r25
    3692:	82 0f       	add	r24, r18
    3694:	93 1f       	adc	r25, r19
    3696:	8c 5f       	subi	r24, 0xFC	; 252
    3698:	9c 4f       	sbci	r25, 0xFC	; 252
    369a:	9a 83       	std	Y+2, r25	; 0x02
    369c:	89 83       	std	Y+1, r24	; 0x01
    369e:	e9 81       	ldd	r30, Y+1	; 0x01
    36a0:	fa 81       	ldd	r31, Y+2	; 0x02
    36a2:	01 80       	ldd	r0, Z+1	; 0x01
    36a4:	f2 81       	ldd	r31, Z+2	; 0x02
    36a6:	e0 2d       	mov	r30, r0
    36a8:	82 81       	ldd	r24, Z+2	; 0x02
    36aa:	93 81       	ldd	r25, Z+3	; 0x03
    36ac:	e9 81       	ldd	r30, Y+1	; 0x01
    36ae:	fa 81       	ldd	r31, Y+2	; 0x02
    36b0:	92 83       	std	Z+2, r25	; 0x02
    36b2:	81 83       	std	Z+1, r24	; 0x01
    36b4:	e9 81       	ldd	r30, Y+1	; 0x01
    36b6:	fa 81       	ldd	r31, Y+2	; 0x02
    36b8:	21 81       	ldd	r18, Z+1	; 0x01
    36ba:	32 81       	ldd	r19, Z+2	; 0x02
    36bc:	89 81       	ldd	r24, Y+1	; 0x01
    36be:	9a 81       	ldd	r25, Y+2	; 0x02
    36c0:	03 96       	adiw	r24, 0x03	; 3
    36c2:	28 17       	cp	r18, r24
    36c4:	39 07       	cpc	r19, r25
    36c6:	59 f4       	brne	.+22     	; 0x36de <vTaskSwitchContext+0xb2>
    36c8:	e9 81       	ldd	r30, Y+1	; 0x01
    36ca:	fa 81       	ldd	r31, Y+2	; 0x02
    36cc:	01 80       	ldd	r0, Z+1	; 0x01
    36ce:	f2 81       	ldd	r31, Z+2	; 0x02
    36d0:	e0 2d       	mov	r30, r0
    36d2:	82 81       	ldd	r24, Z+2	; 0x02
    36d4:	93 81       	ldd	r25, Z+3	; 0x03
    36d6:	e9 81       	ldd	r30, Y+1	; 0x01
    36d8:	fa 81       	ldd	r31, Y+2	; 0x02
    36da:	92 83       	std	Z+2, r25	; 0x02
    36dc:	81 83       	std	Z+1, r24	; 0x01
    36de:	e9 81       	ldd	r30, Y+1	; 0x01
    36e0:	fa 81       	ldd	r31, Y+2	; 0x02
    36e2:	01 80       	ldd	r0, Z+1	; 0x01
    36e4:	f2 81       	ldd	r31, Z+2	; 0x02
    36e6:	e0 2d       	mov	r30, r0
    36e8:	86 81       	ldd	r24, Z+6	; 0x06
    36ea:	97 81       	ldd	r25, Z+7	; 0x07
    36ec:	90 93 f5 02 	sts	0x02F5, r25
    36f0:	80 93 f4 02 	sts	0x02F4, r24
    36f4:	8b 81       	ldd	r24, Y+3	; 0x03
    36f6:	80 93 f9 02 	sts	0x02F9, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    36fa:	0f 90       	pop	r0
    36fc:	0f 90       	pop	r0
    36fe:	0f 90       	pop	r0
    3700:	cf 91       	pop	r28
    3702:	df 91       	pop	r29
    3704:	08 95       	ret

00003706 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3706:	df 93       	push	r29
    3708:	cf 93       	push	r28
    370a:	00 d0       	rcall	.+0      	; 0x370c <vTaskPlaceOnEventList+0x6>
    370c:	00 d0       	rcall	.+0      	; 0x370e <vTaskPlaceOnEventList+0x8>
    370e:	cd b7       	in	r28, 0x3d	; 61
    3710:	de b7       	in	r29, 0x3e	; 62
    3712:	9a 83       	std	Y+2, r25	; 0x02
    3714:	89 83       	std	Y+1, r24	; 0x01
    3716:	7c 83       	std	Y+4, r23	; 0x04
    3718:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    371a:	80 91 f4 02 	lds	r24, 0x02F4
    371e:	90 91 f5 02 	lds	r25, 0x02F5
    3722:	9c 01       	movw	r18, r24
    3724:	24 5f       	subi	r18, 0xF4	; 244
    3726:	3f 4f       	sbci	r19, 0xFF	; 255
    3728:	89 81       	ldd	r24, Y+1	; 0x01
    372a:	9a 81       	ldd	r25, Y+2	; 0x02
    372c:	b9 01       	movw	r22, r18
    372e:	0e 94 09 0c 	call	0x1812	; 0x1812 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3732:	8b 81       	ldd	r24, Y+3	; 0x03
    3734:	9c 81       	ldd	r25, Y+4	; 0x04
    3736:	61 e0       	ldi	r22, 0x01	; 1
    3738:	0e 94 85 21 	call	0x430a	; 0x430a <prvAddCurrentTaskToDelayedList>
}
    373c:	0f 90       	pop	r0
    373e:	0f 90       	pop	r0
    3740:	0f 90       	pop	r0
    3742:	0f 90       	pop	r0
    3744:	cf 91       	pop	r28
    3746:	df 91       	pop	r29
    3748:	08 95       	ret

0000374a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    374a:	df 93       	push	r29
    374c:	cf 93       	push	r28
    374e:	00 d0       	rcall	.+0      	; 0x3750 <vTaskPlaceOnUnorderedEventList+0x6>
    3750:	00 d0       	rcall	.+0      	; 0x3752 <vTaskPlaceOnUnorderedEventList+0x8>
    3752:	00 d0       	rcall	.+0      	; 0x3754 <vTaskPlaceOnUnorderedEventList+0xa>
    3754:	cd b7       	in	r28, 0x3d	; 61
    3756:	de b7       	in	r29, 0x3e	; 62
    3758:	9a 83       	std	Y+2, r25	; 0x02
    375a:	89 83       	std	Y+1, r24	; 0x01
    375c:	7c 83       	std	Y+4, r23	; 0x04
    375e:	6b 83       	std	Y+3, r22	; 0x03
    3760:	5e 83       	std	Y+6, r21	; 0x06
    3762:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3764:	e0 91 f4 02 	lds	r30, 0x02F4
    3768:	f0 91 f5 02 	lds	r31, 0x02F5
    376c:	8b 81       	ldd	r24, Y+3	; 0x03
    376e:	9c 81       	ldd	r25, Y+4	; 0x04
    3770:	90 68       	ori	r25, 0x80	; 128
    3772:	95 87       	std	Z+13, r25	; 0x0d
    3774:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3776:	80 91 f4 02 	lds	r24, 0x02F4
    377a:	90 91 f5 02 	lds	r25, 0x02F5
    377e:	9c 01       	movw	r18, r24
    3780:	24 5f       	subi	r18, 0xF4	; 244
    3782:	3f 4f       	sbci	r19, 0xFF	; 255
    3784:	89 81       	ldd	r24, Y+1	; 0x01
    3786:	9a 81       	ldd	r25, Y+2	; 0x02
    3788:	b9 01       	movw	r22, r18
    378a:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    378e:	8d 81       	ldd	r24, Y+5	; 0x05
    3790:	9e 81       	ldd	r25, Y+6	; 0x06
    3792:	61 e0       	ldi	r22, 0x01	; 1
    3794:	0e 94 85 21 	call	0x430a	; 0x430a <prvAddCurrentTaskToDelayedList>
}
    3798:	26 96       	adiw	r28, 0x06	; 6
    379a:	0f b6       	in	r0, 0x3f	; 63
    379c:	f8 94       	cli
    379e:	de bf       	out	0x3e, r29	; 62
    37a0:	0f be       	out	0x3f, r0	; 63
    37a2:	cd bf       	out	0x3d, r28	; 61
    37a4:	cf 91       	pop	r28
    37a6:	df 91       	pop	r29
    37a8:	08 95       	ret

000037aa <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    37aa:	df 93       	push	r29
    37ac:	cf 93       	push	r28
    37ae:	00 d0       	rcall	.+0      	; 0x37b0 <xTaskRemoveFromEventList+0x6>
    37b0:	00 d0       	rcall	.+0      	; 0x37b2 <xTaskRemoveFromEventList+0x8>
    37b2:	0f 92       	push	r0
    37b4:	cd b7       	in	r28, 0x3d	; 61
    37b6:	de b7       	in	r29, 0x3e	; 62
    37b8:	9d 83       	std	Y+5, r25	; 0x05
    37ba:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    37bc:	ec 81       	ldd	r30, Y+4	; 0x04
    37be:	fd 81       	ldd	r31, Y+5	; 0x05
    37c0:	05 80       	ldd	r0, Z+5	; 0x05
    37c2:	f6 81       	ldd	r31, Z+6	; 0x06
    37c4:	e0 2d       	mov	r30, r0
    37c6:	86 81       	ldd	r24, Z+6	; 0x06
    37c8:	97 81       	ldd	r25, Z+7	; 0x07
    37ca:	9b 83       	std	Y+3, r25	; 0x03
    37cc:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    37ce:	8a 81       	ldd	r24, Y+2	; 0x02
    37d0:	9b 81       	ldd	r25, Y+3	; 0x03
    37d2:	0c 96       	adiw	r24, 0x0c	; 12
    37d4:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    37d8:	80 91 03 03 	lds	r24, 0x0303
    37dc:	88 23       	and	r24, r24
    37de:	61 f5       	brne	.+88     	; 0x3838 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    37e0:	8a 81       	ldd	r24, Y+2	; 0x02
    37e2:	9b 81       	ldd	r25, Y+3	; 0x03
    37e4:	02 96       	adiw	r24, 0x02	; 2
    37e6:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    37ea:	ea 81       	ldd	r30, Y+2	; 0x02
    37ec:	fb 81       	ldd	r31, Y+3	; 0x03
    37ee:	96 89       	ldd	r25, Z+22	; 0x16
    37f0:	80 91 f9 02 	lds	r24, 0x02F9
    37f4:	89 17       	cp	r24, r25
    37f6:	28 f4       	brcc	.+10     	; 0x3802 <xTaskRemoveFromEventList+0x58>
    37f8:	ea 81       	ldd	r30, Y+2	; 0x02
    37fa:	fb 81       	ldd	r31, Y+3	; 0x03
    37fc:	86 89       	ldd	r24, Z+22	; 0x16
    37fe:	80 93 f9 02 	sts	0x02F9, r24
    3802:	ea 81       	ldd	r30, Y+2	; 0x02
    3804:	fb 81       	ldd	r31, Y+3	; 0x03
    3806:	86 89       	ldd	r24, Z+22	; 0x16
    3808:	28 2f       	mov	r18, r24
    380a:	30 e0       	ldi	r19, 0x00	; 0
    380c:	c9 01       	movw	r24, r18
    380e:	88 0f       	add	r24, r24
    3810:	99 1f       	adc	r25, r25
    3812:	88 0f       	add	r24, r24
    3814:	99 1f       	adc	r25, r25
    3816:	88 0f       	add	r24, r24
    3818:	99 1f       	adc	r25, r25
    381a:	82 0f       	add	r24, r18
    381c:	93 1f       	adc	r25, r19
    381e:	ac 01       	movw	r20, r24
    3820:	4c 5f       	subi	r20, 0xFC	; 252
    3822:	5c 4f       	sbci	r21, 0xFC	; 252
    3824:	8a 81       	ldd	r24, Y+2	; 0x02
    3826:	9b 81       	ldd	r25, Y+3	; 0x03
    3828:	9c 01       	movw	r18, r24
    382a:	2e 5f       	subi	r18, 0xFE	; 254
    382c:	3f 4f       	sbci	r19, 0xFF	; 255
    382e:	ca 01       	movw	r24, r20
    3830:	b9 01       	movw	r22, r18
    3832:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>
    3836:	0a c0       	rjmp	.+20     	; 0x384c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3838:	8a 81       	ldd	r24, Y+2	; 0x02
    383a:	9b 81       	ldd	r25, Y+3	; 0x03
    383c:	9c 01       	movw	r18, r24
    383e:	24 5f       	subi	r18, 0xF4	; 244
    3840:	3f 4f       	sbci	r19, 0xFF	; 255
    3842:	8e e3       	ldi	r24, 0x3E	; 62
    3844:	93 e0       	ldi	r25, 0x03	; 3
    3846:	b9 01       	movw	r22, r18
    3848:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    384c:	ea 81       	ldd	r30, Y+2	; 0x02
    384e:	fb 81       	ldd	r31, Y+3	; 0x03
    3850:	96 89       	ldd	r25, Z+22	; 0x16
    3852:	e0 91 f4 02 	lds	r30, 0x02F4
    3856:	f0 91 f5 02 	lds	r31, 0x02F5
    385a:	86 89       	ldd	r24, Z+22	; 0x16
    385c:	89 17       	cp	r24, r25
    385e:	30 f4       	brcc	.+12     	; 0x386c <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3860:	81 e0       	ldi	r24, 0x01	; 1
    3862:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3864:	81 e0       	ldi	r24, 0x01	; 1
    3866:	80 93 fc 02 	sts	0x02FC, r24
    386a:	01 c0       	rjmp	.+2      	; 0x386e <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    386c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    386e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3870:	0f 90       	pop	r0
    3872:	0f 90       	pop	r0
    3874:	0f 90       	pop	r0
    3876:	0f 90       	pop	r0
    3878:	0f 90       	pop	r0
    387a:	cf 91       	pop	r28
    387c:	df 91       	pop	r29
    387e:	08 95       	ret

00003880 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3880:	df 93       	push	r29
    3882:	cf 93       	push	r28
    3884:	00 d0       	rcall	.+0      	; 0x3886 <vTaskRemoveFromUnorderedEventList+0x6>
    3886:	00 d0       	rcall	.+0      	; 0x3888 <vTaskRemoveFromUnorderedEventList+0x8>
    3888:	00 d0       	rcall	.+0      	; 0x388a <vTaskRemoveFromUnorderedEventList+0xa>
    388a:	cd b7       	in	r28, 0x3d	; 61
    388c:	de b7       	in	r29, 0x3e	; 62
    388e:	9c 83       	std	Y+4, r25	; 0x04
    3890:	8b 83       	std	Y+3, r24	; 0x03
    3892:	7e 83       	std	Y+6, r23	; 0x06
    3894:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3896:	8d 81       	ldd	r24, Y+5	; 0x05
    3898:	9e 81       	ldd	r25, Y+6	; 0x06
    389a:	90 68       	ori	r25, 0x80	; 128
    389c:	eb 81       	ldd	r30, Y+3	; 0x03
    389e:	fc 81       	ldd	r31, Y+4	; 0x04
    38a0:	91 83       	std	Z+1, r25	; 0x01
    38a2:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    38a4:	eb 81       	ldd	r30, Y+3	; 0x03
    38a6:	fc 81       	ldd	r31, Y+4	; 0x04
    38a8:	86 81       	ldd	r24, Z+6	; 0x06
    38aa:	97 81       	ldd	r25, Z+7	; 0x07
    38ac:	9a 83       	std	Y+2, r25	; 0x02
    38ae:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    38b0:	8b 81       	ldd	r24, Y+3	; 0x03
    38b2:	9c 81       	ldd	r25, Y+4	; 0x04
    38b4:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    38b8:	89 81       	ldd	r24, Y+1	; 0x01
    38ba:	9a 81       	ldd	r25, Y+2	; 0x02
    38bc:	02 96       	adiw	r24, 0x02	; 2
    38be:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    38c2:	e9 81       	ldd	r30, Y+1	; 0x01
    38c4:	fa 81       	ldd	r31, Y+2	; 0x02
    38c6:	96 89       	ldd	r25, Z+22	; 0x16
    38c8:	80 91 f9 02 	lds	r24, 0x02F9
    38cc:	89 17       	cp	r24, r25
    38ce:	28 f4       	brcc	.+10     	; 0x38da <vTaskRemoveFromUnorderedEventList+0x5a>
    38d0:	e9 81       	ldd	r30, Y+1	; 0x01
    38d2:	fa 81       	ldd	r31, Y+2	; 0x02
    38d4:	86 89       	ldd	r24, Z+22	; 0x16
    38d6:	80 93 f9 02 	sts	0x02F9, r24
    38da:	e9 81       	ldd	r30, Y+1	; 0x01
    38dc:	fa 81       	ldd	r31, Y+2	; 0x02
    38de:	86 89       	ldd	r24, Z+22	; 0x16
    38e0:	28 2f       	mov	r18, r24
    38e2:	30 e0       	ldi	r19, 0x00	; 0
    38e4:	c9 01       	movw	r24, r18
    38e6:	88 0f       	add	r24, r24
    38e8:	99 1f       	adc	r25, r25
    38ea:	88 0f       	add	r24, r24
    38ec:	99 1f       	adc	r25, r25
    38ee:	88 0f       	add	r24, r24
    38f0:	99 1f       	adc	r25, r25
    38f2:	82 0f       	add	r24, r18
    38f4:	93 1f       	adc	r25, r19
    38f6:	ac 01       	movw	r20, r24
    38f8:	4c 5f       	subi	r20, 0xFC	; 252
    38fa:	5c 4f       	sbci	r21, 0xFC	; 252
    38fc:	89 81       	ldd	r24, Y+1	; 0x01
    38fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3900:	9c 01       	movw	r18, r24
    3902:	2e 5f       	subi	r18, 0xFE	; 254
    3904:	3f 4f       	sbci	r19, 0xFF	; 255
    3906:	ca 01       	movw	r24, r20
    3908:	b9 01       	movw	r22, r18
    390a:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    390e:	e9 81       	ldd	r30, Y+1	; 0x01
    3910:	fa 81       	ldd	r31, Y+2	; 0x02
    3912:	96 89       	ldd	r25, Z+22	; 0x16
    3914:	e0 91 f4 02 	lds	r30, 0x02F4
    3918:	f0 91 f5 02 	lds	r31, 0x02F5
    391c:	86 89       	ldd	r24, Z+22	; 0x16
    391e:	89 17       	cp	r24, r25
    3920:	18 f4       	brcc	.+6      	; 0x3928 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3922:	81 e0       	ldi	r24, 0x01	; 1
    3924:	80 93 fc 02 	sts	0x02FC, r24
	}
}
    3928:	26 96       	adiw	r28, 0x06	; 6
    392a:	0f b6       	in	r0, 0x3f	; 63
    392c:	f8 94       	cli
    392e:	de bf       	out	0x3e, r29	; 62
    3930:	0f be       	out	0x3f, r0	; 63
    3932:	cd bf       	out	0x3d, r28	; 61
    3934:	cf 91       	pop	r28
    3936:	df 91       	pop	r29
    3938:	08 95       	ret

0000393a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    393a:	df 93       	push	r29
    393c:	cf 93       	push	r28
    393e:	00 d0       	rcall	.+0      	; 0x3940 <vTaskSetTimeOutState+0x6>
    3940:	cd b7       	in	r28, 0x3d	; 61
    3942:	de b7       	in	r29, 0x3e	; 62
    3944:	9a 83       	std	Y+2, r25	; 0x02
    3946:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3948:	0f b6       	in	r0, 0x3f	; 63
    394a:	f8 94       	cli
    394c:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    394e:	80 91 fd 02 	lds	r24, 0x02FD
    3952:	e9 81       	ldd	r30, Y+1	; 0x01
    3954:	fa 81       	ldd	r31, Y+2	; 0x02
    3956:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    3958:	80 91 f7 02 	lds	r24, 0x02F7
    395c:	90 91 f8 02 	lds	r25, 0x02F8
    3960:	e9 81       	ldd	r30, Y+1	; 0x01
    3962:	fa 81       	ldd	r31, Y+2	; 0x02
    3964:	92 83       	std	Z+2, r25	; 0x02
    3966:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3968:	0f 90       	pop	r0
    396a:	0f be       	out	0x3f, r0	; 63
}
    396c:	0f 90       	pop	r0
    396e:	0f 90       	pop	r0
    3970:	cf 91       	pop	r28
    3972:	df 91       	pop	r29
    3974:	08 95       	ret

00003976 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3976:	df 93       	push	r29
    3978:	cf 93       	push	r28
    397a:	00 d0       	rcall	.+0      	; 0x397c <vTaskInternalSetTimeOutState+0x6>
    397c:	cd b7       	in	r28, 0x3d	; 61
    397e:	de b7       	in	r29, 0x3e	; 62
    3980:	9a 83       	std	Y+2, r25	; 0x02
    3982:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3984:	80 91 fd 02 	lds	r24, 0x02FD
    3988:	e9 81       	ldd	r30, Y+1	; 0x01
    398a:	fa 81       	ldd	r31, Y+2	; 0x02
    398c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    398e:	80 91 f7 02 	lds	r24, 0x02F7
    3992:	90 91 f8 02 	lds	r25, 0x02F8
    3996:	e9 81       	ldd	r30, Y+1	; 0x01
    3998:	fa 81       	ldd	r31, Y+2	; 0x02
    399a:	92 83       	std	Z+2, r25	; 0x02
    399c:	81 83       	std	Z+1, r24	; 0x01
}
    399e:	0f 90       	pop	r0
    39a0:	0f 90       	pop	r0
    39a2:	cf 91       	pop	r28
    39a4:	df 91       	pop	r29
    39a6:	08 95       	ret

000039a8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    39a8:	df 93       	push	r29
    39aa:	cf 93       	push	r28
    39ac:	cd b7       	in	r28, 0x3d	; 61
    39ae:	de b7       	in	r29, 0x3e	; 62
    39b0:	29 97       	sbiw	r28, 0x09	; 9
    39b2:	0f b6       	in	r0, 0x3f	; 63
    39b4:	f8 94       	cli
    39b6:	de bf       	out	0x3e, r29	; 62
    39b8:	0f be       	out	0x3f, r0	; 63
    39ba:	cd bf       	out	0x3d, r28	; 61
    39bc:	9f 83       	std	Y+7, r25	; 0x07
    39be:	8e 83       	std	Y+6, r24	; 0x06
    39c0:	79 87       	std	Y+9, r23	; 0x09
    39c2:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    39c4:	0f b6       	in	r0, 0x3f	; 63
    39c6:	f8 94       	cli
    39c8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    39ca:	80 91 f7 02 	lds	r24, 0x02F7
    39ce:	90 91 f8 02 	lds	r25, 0x02F8
    39d2:	9c 83       	std	Y+4, r25	; 0x04
    39d4:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    39d6:	ee 81       	ldd	r30, Y+6	; 0x06
    39d8:	ff 81       	ldd	r31, Y+7	; 0x07
    39da:	21 81       	ldd	r18, Z+1	; 0x01
    39dc:	32 81       	ldd	r19, Z+2	; 0x02
    39de:	8b 81       	ldd	r24, Y+3	; 0x03
    39e0:	9c 81       	ldd	r25, Y+4	; 0x04
    39e2:	82 1b       	sub	r24, r18
    39e4:	93 0b       	sbc	r25, r19
    39e6:	9a 83       	std	Y+2, r25	; 0x02
    39e8:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    39ea:	ee 81       	ldd	r30, Y+6	; 0x06
    39ec:	ff 81       	ldd	r31, Y+7	; 0x07
    39ee:	90 81       	ld	r25, Z
    39f0:	80 91 fd 02 	lds	r24, 0x02FD
    39f4:	98 17       	cp	r25, r24
    39f6:	61 f0       	breq	.+24     	; 0x3a10 <xTaskCheckForTimeOut+0x68>
    39f8:	ee 81       	ldd	r30, Y+6	; 0x06
    39fa:	ff 81       	ldd	r31, Y+7	; 0x07
    39fc:	21 81       	ldd	r18, Z+1	; 0x01
    39fe:	32 81       	ldd	r19, Z+2	; 0x02
    3a00:	8b 81       	ldd	r24, Y+3	; 0x03
    3a02:	9c 81       	ldd	r25, Y+4	; 0x04
    3a04:	82 17       	cp	r24, r18
    3a06:	93 07       	cpc	r25, r19
    3a08:	18 f0       	brcs	.+6      	; 0x3a10 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3a0a:	81 e0       	ldi	r24, 0x01	; 1
    3a0c:	8d 83       	std	Y+5, r24	; 0x05
    3a0e:	23 c0       	rjmp	.+70     	; 0x3a56 <xTaskCheckForTimeOut+0xae>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3a10:	e8 85       	ldd	r30, Y+8	; 0x08
    3a12:	f9 85       	ldd	r31, Y+9	; 0x09
    3a14:	20 81       	ld	r18, Z
    3a16:	31 81       	ldd	r19, Z+1	; 0x01
    3a18:	89 81       	ldd	r24, Y+1	; 0x01
    3a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a1c:	82 17       	cp	r24, r18
    3a1e:	93 07       	cpc	r25, r19
    3a20:	a0 f4       	brcc	.+40     	; 0x3a4a <xTaskCheckForTimeOut+0xa2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3a22:	e8 85       	ldd	r30, Y+8	; 0x08
    3a24:	f9 85       	ldd	r31, Y+9	; 0x09
    3a26:	20 81       	ld	r18, Z
    3a28:	31 81       	ldd	r19, Z+1	; 0x01
    3a2a:	89 81       	ldd	r24, Y+1	; 0x01
    3a2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a2e:	a9 01       	movw	r20, r18
    3a30:	48 1b       	sub	r20, r24
    3a32:	59 0b       	sbc	r21, r25
    3a34:	ca 01       	movw	r24, r20
    3a36:	e8 85       	ldd	r30, Y+8	; 0x08
    3a38:	f9 85       	ldd	r31, Y+9	; 0x09
    3a3a:	91 83       	std	Z+1, r25	; 0x01
    3a3c:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3a3e:	8e 81       	ldd	r24, Y+6	; 0x06
    3a40:	9f 81       	ldd	r25, Y+7	; 0x07
    3a42:	0e 94 bb 1c 	call	0x3976	; 0x3976 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3a46:	1d 82       	std	Y+5, r1	; 0x05
    3a48:	06 c0       	rjmp	.+12     	; 0x3a56 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			*pxTicksToWait = 0;
    3a4a:	e8 85       	ldd	r30, Y+8	; 0x08
    3a4c:	f9 85       	ldd	r31, Y+9	; 0x09
    3a4e:	11 82       	std	Z+1, r1	; 0x01
    3a50:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    3a52:	81 e0       	ldi	r24, 0x01	; 1
    3a54:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    3a56:	0f 90       	pop	r0
    3a58:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3a5a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3a5c:	29 96       	adiw	r28, 0x09	; 9
    3a5e:	0f b6       	in	r0, 0x3f	; 63
    3a60:	f8 94       	cli
    3a62:	de bf       	out	0x3e, r29	; 62
    3a64:	0f be       	out	0x3f, r0	; 63
    3a66:	cd bf       	out	0x3d, r28	; 61
    3a68:	cf 91       	pop	r28
    3a6a:	df 91       	pop	r29
    3a6c:	08 95       	ret

00003a6e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3a6e:	df 93       	push	r29
    3a70:	cf 93       	push	r28
    3a72:	cd b7       	in	r28, 0x3d	; 61
    3a74:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3a76:	81 e0       	ldi	r24, 0x01	; 1
    3a78:	80 93 fc 02 	sts	0x02FC, r24
}
    3a7c:	cf 91       	pop	r28
    3a7e:	df 91       	pop	r29
    3a80:	08 95       	ret

00003a82 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3a82:	df 93       	push	r29
    3a84:	cf 93       	push	r28
    3a86:	00 d0       	rcall	.+0      	; 0x3a88 <prvIdleTask+0x6>
    3a88:	cd b7       	in	r28, 0x3d	; 61
    3a8a:	de b7       	in	r29, 0x3e	; 62
    3a8c:	9a 83       	std	Y+2, r25	; 0x02
    3a8e:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    3a90:	0e 94 84 1d 	call	0x3b08	; 0x3b08 <prvCheckTasksWaitingTermination>
    3a94:	fd cf       	rjmp	.-6      	; 0x3a90 <prvIdleTask+0xe>

00003a96 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3a96:	df 93       	push	r29
    3a98:	cf 93       	push	r28
    3a9a:	0f 92       	push	r0
    3a9c:	cd b7       	in	r28, 0x3d	; 61
    3a9e:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3aa0:	19 82       	std	Y+1, r1	; 0x01
    3aa2:	13 c0       	rjmp	.+38     	; 0x3aca <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3aa4:	89 81       	ldd	r24, Y+1	; 0x01
    3aa6:	28 2f       	mov	r18, r24
    3aa8:	30 e0       	ldi	r19, 0x00	; 0
    3aaa:	c9 01       	movw	r24, r18
    3aac:	88 0f       	add	r24, r24
    3aae:	99 1f       	adc	r25, r25
    3ab0:	88 0f       	add	r24, r24
    3ab2:	99 1f       	adc	r25, r25
    3ab4:	88 0f       	add	r24, r24
    3ab6:	99 1f       	adc	r25, r25
    3ab8:	82 0f       	add	r24, r18
    3aba:	93 1f       	adc	r25, r19
    3abc:	8c 5f       	subi	r24, 0xFC	; 252
    3abe:	9c 4f       	sbci	r25, 0xFC	; 252
    3ac0:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3ac4:	89 81       	ldd	r24, Y+1	; 0x01
    3ac6:	8f 5f       	subi	r24, 0xFF	; 255
    3ac8:	89 83       	std	Y+1, r24	; 0x01
    3aca:	89 81       	ldd	r24, Y+1	; 0x01
    3acc:	84 30       	cpi	r24, 0x04	; 4
    3ace:	50 f3       	brcs	.-44     	; 0x3aa4 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3ad0:	88 e2       	ldi	r24, 0x28	; 40
    3ad2:	93 e0       	ldi	r25, 0x03	; 3
    3ad4:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3ad8:	81 e3       	ldi	r24, 0x31	; 49
    3ada:	93 e0       	ldi	r25, 0x03	; 3
    3adc:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3ae0:	8e e3       	ldi	r24, 0x3E	; 62
    3ae2:	93 e0       	ldi	r25, 0x03	; 3
    3ae4:	0e 94 8b 0b 	call	0x1716	; 0x1716 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3ae8:	88 e2       	ldi	r24, 0x28	; 40
    3aea:	93 e0       	ldi	r25, 0x03	; 3
    3aec:	90 93 3b 03 	sts	0x033B, r25
    3af0:	80 93 3a 03 	sts	0x033A, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3af4:	81 e3       	ldi	r24, 0x31	; 49
    3af6:	93 e0       	ldi	r25, 0x03	; 3
    3af8:	90 93 3d 03 	sts	0x033D, r25
    3afc:	80 93 3c 03 	sts	0x033C, r24
}
    3b00:	0f 90       	pop	r0
    3b02:	cf 91       	pop	r28
    3b04:	df 91       	pop	r29
    3b06:	08 95       	ret

00003b08 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3b08:	df 93       	push	r29
    3b0a:	cf 93       	push	r28
    3b0c:	cd b7       	in	r28, 0x3d	; 61
    3b0e:	de b7       	in	r29, 0x3e	; 62

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    3b10:	cf 91       	pop	r28
    3b12:	df 91       	pop	r29
    3b14:	08 95       	ret

00003b16 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3b16:	df 93       	push	r29
    3b18:	cf 93       	push	r28
    3b1a:	00 d0       	rcall	.+0      	; 0x3b1c <prvResetNextTaskUnblockTime+0x6>
    3b1c:	cd b7       	in	r28, 0x3d	; 61
    3b1e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3b20:	e0 91 3a 03 	lds	r30, 0x033A
    3b24:	f0 91 3b 03 	lds	r31, 0x033B
    3b28:	80 81       	ld	r24, Z
    3b2a:	88 23       	and	r24, r24
    3b2c:	39 f4       	brne	.+14     	; 0x3b3c <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3b2e:	8f ef       	ldi	r24, 0xFF	; 255
    3b30:	9f ef       	ldi	r25, 0xFF	; 255
    3b32:	90 93 00 03 	sts	0x0300, r25
    3b36:	80 93 ff 02 	sts	0x02FF, r24
    3b3a:	13 c0       	rjmp	.+38     	; 0x3b62 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3b3c:	e0 91 3a 03 	lds	r30, 0x033A
    3b40:	f0 91 3b 03 	lds	r31, 0x033B
    3b44:	05 80       	ldd	r0, Z+5	; 0x05
    3b46:	f6 81       	ldd	r31, Z+6	; 0x06
    3b48:	e0 2d       	mov	r30, r0
    3b4a:	86 81       	ldd	r24, Z+6	; 0x06
    3b4c:	97 81       	ldd	r25, Z+7	; 0x07
    3b4e:	9a 83       	std	Y+2, r25	; 0x02
    3b50:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    3b52:	e9 81       	ldd	r30, Y+1	; 0x01
    3b54:	fa 81       	ldd	r31, Y+2	; 0x02
    3b56:	82 81       	ldd	r24, Z+2	; 0x02
    3b58:	93 81       	ldd	r25, Z+3	; 0x03
    3b5a:	90 93 00 03 	sts	0x0300, r25
    3b5e:	80 93 ff 02 	sts	0x02FF, r24
	}
}
    3b62:	0f 90       	pop	r0
    3b64:	0f 90       	pop	r0
    3b66:	cf 91       	pop	r28
    3b68:	df 91       	pop	r29
    3b6a:	08 95       	ret

00003b6c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3b6c:	df 93       	push	r29
    3b6e:	cf 93       	push	r28
    3b70:	00 d0       	rcall	.+0      	; 0x3b72 <uxTaskResetEventItemValue+0x6>
    3b72:	cd b7       	in	r28, 0x3d	; 61
    3b74:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    3b76:	e0 91 f4 02 	lds	r30, 0x02F4
    3b7a:	f0 91 f5 02 	lds	r31, 0x02F5
    3b7e:	84 85       	ldd	r24, Z+12	; 0x0c
    3b80:	95 85       	ldd	r25, Z+13	; 0x0d
    3b82:	9a 83       	std	Y+2, r25	; 0x02
    3b84:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3b86:	a0 91 f4 02 	lds	r26, 0x02F4
    3b8a:	b0 91 f5 02 	lds	r27, 0x02F5
    3b8e:	e0 91 f4 02 	lds	r30, 0x02F4
    3b92:	f0 91 f5 02 	lds	r31, 0x02F5
    3b96:	86 89       	ldd	r24, Z+22	; 0x16
    3b98:	28 2f       	mov	r18, r24
    3b9a:	30 e0       	ldi	r19, 0x00	; 0
    3b9c:	84 e0       	ldi	r24, 0x04	; 4
    3b9e:	90 e0       	ldi	r25, 0x00	; 0
    3ba0:	82 1b       	sub	r24, r18
    3ba2:	93 0b       	sbc	r25, r19
    3ba4:	1d 96       	adiw	r26, 0x0d	; 13
    3ba6:	9c 93       	st	X, r25
    3ba8:	8e 93       	st	-X, r24
    3baa:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    3bac:	89 81       	ldd	r24, Y+1	; 0x01
    3bae:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3bb0:	0f 90       	pop	r0
    3bb2:	0f 90       	pop	r0
    3bb4:	cf 91       	pop	r28
    3bb6:	df 91       	pop	r29
    3bb8:	08 95       	ret

00003bba <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    3bba:	df 93       	push	r29
    3bbc:	cf 93       	push	r28
    3bbe:	cd b7       	in	r28, 0x3d	; 61
    3bc0:	de b7       	in	r29, 0x3e	; 62
    3bc2:	27 97       	sbiw	r28, 0x07	; 7
    3bc4:	0f b6       	in	r0, 0x3f	; 63
    3bc6:	f8 94       	cli
    3bc8:	de bf       	out	0x3e, r29	; 62
    3bca:	0f be       	out	0x3f, r0	; 63
    3bcc:	cd bf       	out	0x3d, r28	; 61
    3bce:	8d 83       	std	Y+5, r24	; 0x05
    3bd0:	7f 83       	std	Y+7, r23	; 0x07
    3bd2:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    3bd4:	0f b6       	in	r0, 0x3f	; 63
    3bd6:	f8 94       	cli
    3bd8:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    3bda:	e0 91 f4 02 	lds	r30, 0x02F4
    3bde:	f0 91 f5 02 	lds	r31, 0x02F5
    3be2:	81 a1       	ldd	r24, Z+33	; 0x21
    3be4:	92 a1       	ldd	r25, Z+34	; 0x22
    3be6:	a3 a1       	ldd	r26, Z+35	; 0x23
    3be8:	b4 a1       	ldd	r27, Z+36	; 0x24
    3bea:	00 97       	sbiw	r24, 0x00	; 0
    3bec:	a1 05       	cpc	r26, r1
    3bee:	b1 05       	cpc	r27, r1
    3bf0:	89 f4       	brne	.+34     	; 0x3c14 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3bf2:	e0 91 f4 02 	lds	r30, 0x02F4
    3bf6:	f0 91 f5 02 	lds	r31, 0x02F5
    3bfa:	81 e0       	ldi	r24, 0x01	; 1
    3bfc:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    3bfe:	8e 81       	ldd	r24, Y+6	; 0x06
    3c00:	9f 81       	ldd	r25, Y+7	; 0x07
    3c02:	00 97       	sbiw	r24, 0x00	; 0
    3c04:	39 f0       	breq	.+14     	; 0x3c14 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3c06:	8e 81       	ldd	r24, Y+6	; 0x06
    3c08:	9f 81       	ldd	r25, Y+7	; 0x07
    3c0a:	61 e0       	ldi	r22, 0x01	; 1
    3c0c:	0e 94 85 21 	call	0x430a	; 0x430a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3c10:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3c14:	0f 90       	pop	r0
    3c16:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3c18:	0f b6       	in	r0, 0x3f	; 63
    3c1a:	f8 94       	cli
    3c1c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    3c1e:	e0 91 f4 02 	lds	r30, 0x02F4
    3c22:	f0 91 f5 02 	lds	r31, 0x02F5
    3c26:	81 a1       	ldd	r24, Z+33	; 0x21
    3c28:	92 a1       	ldd	r25, Z+34	; 0x22
    3c2a:	a3 a1       	ldd	r26, Z+35	; 0x23
    3c2c:	b4 a1       	ldd	r27, Z+36	; 0x24
    3c2e:	89 83       	std	Y+1, r24	; 0x01
    3c30:	9a 83       	std	Y+2, r25	; 0x02
    3c32:	ab 83       	std	Y+3, r26	; 0x03
    3c34:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    3c36:	89 81       	ldd	r24, Y+1	; 0x01
    3c38:	9a 81       	ldd	r25, Y+2	; 0x02
    3c3a:	ab 81       	ldd	r26, Y+3	; 0x03
    3c3c:	bc 81       	ldd	r27, Y+4	; 0x04
    3c3e:	00 97       	sbiw	r24, 0x00	; 0
    3c40:	a1 05       	cpc	r26, r1
    3c42:	b1 05       	cpc	r27, r1
    3c44:	d9 f0       	breq	.+54     	; 0x3c7c <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    3c46:	8d 81       	ldd	r24, Y+5	; 0x05
    3c48:	88 23       	and	r24, r24
    3c4a:	49 f0       	breq	.+18     	; 0x3c5e <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    3c4c:	e0 91 f4 02 	lds	r30, 0x02F4
    3c50:	f0 91 f5 02 	lds	r31, 0x02F5
    3c54:	11 a2       	std	Z+33, r1	; 0x21
    3c56:	12 a2       	std	Z+34, r1	; 0x22
    3c58:	13 a2       	std	Z+35, r1	; 0x23
    3c5a:	14 a2       	std	Z+36, r1	; 0x24
    3c5c:	0f c0       	rjmp	.+30     	; 0x3c7c <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    3c5e:	e0 91 f4 02 	lds	r30, 0x02F4
    3c62:	f0 91 f5 02 	lds	r31, 0x02F5
    3c66:	89 81       	ldd	r24, Y+1	; 0x01
    3c68:	9a 81       	ldd	r25, Y+2	; 0x02
    3c6a:	ab 81       	ldd	r26, Y+3	; 0x03
    3c6c:	bc 81       	ldd	r27, Y+4	; 0x04
    3c6e:	01 97       	sbiw	r24, 0x01	; 1
    3c70:	a1 09       	sbc	r26, r1
    3c72:	b1 09       	sbc	r27, r1
    3c74:	81 a3       	std	Z+33, r24	; 0x21
    3c76:	92 a3       	std	Z+34, r25	; 0x22
    3c78:	a3 a3       	std	Z+35, r26	; 0x23
    3c7a:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3c7c:	e0 91 f4 02 	lds	r30, 0x02F4
    3c80:	f0 91 f5 02 	lds	r31, 0x02F5
    3c84:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3c86:	0f 90       	pop	r0
    3c88:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    3c8a:	89 81       	ldd	r24, Y+1	; 0x01
    3c8c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c8e:	ab 81       	ldd	r26, Y+3	; 0x03
    3c90:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    3c92:	bc 01       	movw	r22, r24
    3c94:	cd 01       	movw	r24, r26
    3c96:	27 96       	adiw	r28, 0x07	; 7
    3c98:	0f b6       	in	r0, 0x3f	; 63
    3c9a:	f8 94       	cli
    3c9c:	de bf       	out	0x3e, r29	; 62
    3c9e:	0f be       	out	0x3f, r0	; 63
    3ca0:	cd bf       	out	0x3d, r28	; 61
    3ca2:	cf 91       	pop	r28
    3ca4:	df 91       	pop	r29
    3ca6:	08 95       	ret

00003ca8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    3ca8:	ef 92       	push	r14
    3caa:	ff 92       	push	r15
    3cac:	0f 93       	push	r16
    3cae:	1f 93       	push	r17
    3cb0:	df 93       	push	r29
    3cb2:	cf 93       	push	r28
    3cb4:	cd b7       	in	r28, 0x3d	; 61
    3cb6:	de b7       	in	r29, 0x3e	; 62
    3cb8:	2d 97       	sbiw	r28, 0x0d	; 13
    3cba:	0f b6       	in	r0, 0x3f	; 63
    3cbc:	f8 94       	cli
    3cbe:	de bf       	out	0x3e, r29	; 62
    3cc0:	0f be       	out	0x3f, r0	; 63
    3cc2:	cd bf       	out	0x3d, r28	; 61
    3cc4:	6a 83       	std	Y+2, r22	; 0x02
    3cc6:	7b 83       	std	Y+3, r23	; 0x03
    3cc8:	8c 83       	std	Y+4, r24	; 0x04
    3cca:	9d 83       	std	Y+5, r25	; 0x05
    3ccc:	2e 83       	std	Y+6, r18	; 0x06
    3cce:	3f 83       	std	Y+7, r19	; 0x07
    3cd0:	48 87       	std	Y+8, r20	; 0x08
    3cd2:	59 87       	std	Y+9, r21	; 0x09
    3cd4:	1b 87       	std	Y+11, r17	; 0x0b
    3cd6:	0a 87       	std	Y+10, r16	; 0x0a
    3cd8:	fd 86       	std	Y+13, r15	; 0x0d
    3cda:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    3cdc:	0f b6       	in	r0, 0x3f	; 63
    3cde:	f8 94       	cli
    3ce0:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    3ce2:	e0 91 f4 02 	lds	r30, 0x02F4
    3ce6:	f0 91 f5 02 	lds	r31, 0x02F5
    3cea:	85 a1       	ldd	r24, Z+37	; 0x25
    3cec:	82 30       	cpi	r24, 0x02	; 2
    3cee:	49 f1       	breq	.+82     	; 0x3d42 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    3cf0:	e0 91 f4 02 	lds	r30, 0x02F4
    3cf4:	f0 91 f5 02 	lds	r31, 0x02F5
    3cf8:	21 a1       	ldd	r18, Z+33	; 0x21
    3cfa:	32 a1       	ldd	r19, Z+34	; 0x22
    3cfc:	43 a1       	ldd	r20, Z+35	; 0x23
    3cfe:	54 a1       	ldd	r21, Z+36	; 0x24
    3d00:	8a 81       	ldd	r24, Y+2	; 0x02
    3d02:	9b 81       	ldd	r25, Y+3	; 0x03
    3d04:	ac 81       	ldd	r26, Y+4	; 0x04
    3d06:	bd 81       	ldd	r27, Y+5	; 0x05
    3d08:	80 95       	com	r24
    3d0a:	90 95       	com	r25
    3d0c:	a0 95       	com	r26
    3d0e:	b0 95       	com	r27
    3d10:	82 23       	and	r24, r18
    3d12:	93 23       	and	r25, r19
    3d14:	a4 23       	and	r26, r20
    3d16:	b5 23       	and	r27, r21
    3d18:	81 a3       	std	Z+33, r24	; 0x21
    3d1a:	92 a3       	std	Z+34, r25	; 0x22
    3d1c:	a3 a3       	std	Z+35, r26	; 0x23
    3d1e:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3d20:	e0 91 f4 02 	lds	r30, 0x02F4
    3d24:	f0 91 f5 02 	lds	r31, 0x02F5
    3d28:	81 e0       	ldi	r24, 0x01	; 1
    3d2a:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    3d2c:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d2e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d30:	00 97       	sbiw	r24, 0x00	; 0
    3d32:	39 f0       	breq	.+14     	; 0x3d42 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3d34:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d36:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d38:	61 e0       	ldi	r22, 0x01	; 1
    3d3a:	0e 94 85 21 	call	0x430a	; 0x430a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3d3e:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3d42:	0f 90       	pop	r0
    3d44:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3d46:	0f b6       	in	r0, 0x3f	; 63
    3d48:	f8 94       	cli
    3d4a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    3d4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d4e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d50:	00 97       	sbiw	r24, 0x00	; 0
    3d52:	71 f0       	breq	.+28     	; 0x3d70 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    3d54:	e0 91 f4 02 	lds	r30, 0x02F4
    3d58:	f0 91 f5 02 	lds	r31, 0x02F5
    3d5c:	81 a1       	ldd	r24, Z+33	; 0x21
    3d5e:	92 a1       	ldd	r25, Z+34	; 0x22
    3d60:	a3 a1       	ldd	r26, Z+35	; 0x23
    3d62:	b4 a1       	ldd	r27, Z+36	; 0x24
    3d64:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d66:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d68:	80 83       	st	Z, r24
    3d6a:	91 83       	std	Z+1, r25	; 0x01
    3d6c:	a2 83       	std	Z+2, r26	; 0x02
    3d6e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    3d70:	e0 91 f4 02 	lds	r30, 0x02F4
    3d74:	f0 91 f5 02 	lds	r31, 0x02F5
    3d78:	85 a1       	ldd	r24, Z+37	; 0x25
    3d7a:	82 30       	cpi	r24, 0x02	; 2
    3d7c:	11 f0       	breq	.+4      	; 0x3d82 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    3d7e:	19 82       	std	Y+1, r1	; 0x01
    3d80:	1a c0       	rjmp	.+52     	; 0x3db6 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    3d82:	e0 91 f4 02 	lds	r30, 0x02F4
    3d86:	f0 91 f5 02 	lds	r31, 0x02F5
    3d8a:	21 a1       	ldd	r18, Z+33	; 0x21
    3d8c:	32 a1       	ldd	r19, Z+34	; 0x22
    3d8e:	43 a1       	ldd	r20, Z+35	; 0x23
    3d90:	54 a1       	ldd	r21, Z+36	; 0x24
    3d92:	8e 81       	ldd	r24, Y+6	; 0x06
    3d94:	9f 81       	ldd	r25, Y+7	; 0x07
    3d96:	a8 85       	ldd	r26, Y+8	; 0x08
    3d98:	b9 85       	ldd	r27, Y+9	; 0x09
    3d9a:	80 95       	com	r24
    3d9c:	90 95       	com	r25
    3d9e:	a0 95       	com	r26
    3da0:	b0 95       	com	r27
    3da2:	82 23       	and	r24, r18
    3da4:	93 23       	and	r25, r19
    3da6:	a4 23       	and	r26, r20
    3da8:	b5 23       	and	r27, r21
    3daa:	81 a3       	std	Z+33, r24	; 0x21
    3dac:	92 a3       	std	Z+34, r25	; 0x22
    3dae:	a3 a3       	std	Z+35, r26	; 0x23
    3db0:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    3db2:	81 e0       	ldi	r24, 0x01	; 1
    3db4:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3db6:	e0 91 f4 02 	lds	r30, 0x02F4
    3dba:	f0 91 f5 02 	lds	r31, 0x02F5
    3dbe:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3dc0:	0f 90       	pop	r0
    3dc2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3dc4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3dc6:	2d 96       	adiw	r28, 0x0d	; 13
    3dc8:	0f b6       	in	r0, 0x3f	; 63
    3dca:	f8 94       	cli
    3dcc:	de bf       	out	0x3e, r29	; 62
    3dce:	0f be       	out	0x3f, r0	; 63
    3dd0:	cd bf       	out	0x3d, r28	; 61
    3dd2:	cf 91       	pop	r28
    3dd4:	df 91       	pop	r29
    3dd6:	1f 91       	pop	r17
    3dd8:	0f 91       	pop	r16
    3dda:	ff 90       	pop	r15
    3ddc:	ef 90       	pop	r14
    3dde:	08 95       	ret

00003de0 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    3de0:	0f 93       	push	r16
    3de2:	1f 93       	push	r17
    3de4:	df 93       	push	r29
    3de6:	cf 93       	push	r28
    3de8:	cd b7       	in	r28, 0x3d	; 61
    3dea:	de b7       	in	r29, 0x3e	; 62
    3dec:	2f 97       	sbiw	r28, 0x0f	; 15
    3dee:	0f b6       	in	r0, 0x3f	; 63
    3df0:	f8 94       	cli
    3df2:	de bf       	out	0x3e, r29	; 62
    3df4:	0f be       	out	0x3f, r0	; 63
    3df6:	cd bf       	out	0x3d, r28	; 61
    3df8:	9e 83       	std	Y+6, r25	; 0x06
    3dfa:	8d 83       	std	Y+5, r24	; 0x05
    3dfc:	4f 83       	std	Y+7, r20	; 0x07
    3dfe:	58 87       	std	Y+8, r21	; 0x08
    3e00:	69 87       	std	Y+9, r22	; 0x09
    3e02:	7a 87       	std	Y+10, r23	; 0x0a
    3e04:	2b 87       	std	Y+11, r18	; 0x0b
    3e06:	1d 87       	std	Y+13, r17	; 0x0d
    3e08:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    3e0a:	81 e0       	ldi	r24, 0x01	; 1
    3e0c:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    3e0e:	8d 81       	ldd	r24, Y+5	; 0x05
    3e10:	9e 81       	ldd	r25, Y+6	; 0x06
    3e12:	9c 83       	std	Y+4, r25	; 0x04
    3e14:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    3e16:	0f b6       	in	r0, 0x3f	; 63
    3e18:	f8 94       	cli
    3e1a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    3e1c:	8c 85       	ldd	r24, Y+12	; 0x0c
    3e1e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3e20:	00 97       	sbiw	r24, 0x00	; 0
    3e22:	61 f0       	breq	.+24     	; 0x3e3c <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3e24:	eb 81       	ldd	r30, Y+3	; 0x03
    3e26:	fc 81       	ldd	r31, Y+4	; 0x04
    3e28:	81 a1       	ldd	r24, Z+33	; 0x21
    3e2a:	92 a1       	ldd	r25, Z+34	; 0x22
    3e2c:	a3 a1       	ldd	r26, Z+35	; 0x23
    3e2e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3e30:	ec 85       	ldd	r30, Y+12	; 0x0c
    3e32:	fd 85       	ldd	r31, Y+13	; 0x0d
    3e34:	80 83       	st	Z, r24
    3e36:	91 83       	std	Z+1, r25	; 0x01
    3e38:	a2 83       	std	Z+2, r26	; 0x02
    3e3a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3e3c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e3e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e40:	85 a1       	ldd	r24, Z+37	; 0x25
    3e42:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3e44:	eb 81       	ldd	r30, Y+3	; 0x03
    3e46:	fc 81       	ldd	r31, Y+4	; 0x04
    3e48:	82 e0       	ldi	r24, 0x02	; 2
    3e4a:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    3e4c:	8b 85       	ldd	r24, Y+11	; 0x0b
    3e4e:	28 2f       	mov	r18, r24
    3e50:	30 e0       	ldi	r19, 0x00	; 0
    3e52:	3f 87       	std	Y+15, r19	; 0x0f
    3e54:	2e 87       	std	Y+14, r18	; 0x0e
    3e56:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e58:	9f 85       	ldd	r25, Y+15	; 0x0f
    3e5a:	82 30       	cpi	r24, 0x02	; 2
    3e5c:	91 05       	cpc	r25, r1
    3e5e:	59 f1       	breq	.+86     	; 0x3eb6 <xTaskGenericNotify+0xd6>
    3e60:	2e 85       	ldd	r18, Y+14	; 0x0e
    3e62:	3f 85       	ldd	r19, Y+15	; 0x0f
    3e64:	23 30       	cpi	r18, 0x03	; 3
    3e66:	31 05       	cpc	r19, r1
    3e68:	34 f4       	brge	.+12     	; 0x3e76 <xTaskGenericNotify+0x96>
    3e6a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e6c:	9f 85       	ldd	r25, Y+15	; 0x0f
    3e6e:	81 30       	cpi	r24, 0x01	; 1
    3e70:	91 05       	cpc	r25, r1
    3e72:	61 f0       	breq	.+24     	; 0x3e8c <xTaskGenericNotify+0xac>
    3e74:	4a c0       	rjmp	.+148    	; 0x3f0a <xTaskGenericNotify+0x12a>
    3e76:	2e 85       	ldd	r18, Y+14	; 0x0e
    3e78:	3f 85       	ldd	r19, Y+15	; 0x0f
    3e7a:	23 30       	cpi	r18, 0x03	; 3
    3e7c:	31 05       	cpc	r19, r1
    3e7e:	59 f1       	breq	.+86     	; 0x3ed6 <xTaskGenericNotify+0xf6>
    3e80:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e82:	9f 85       	ldd	r25, Y+15	; 0x0f
    3e84:	84 30       	cpi	r24, 0x04	; 4
    3e86:	91 05       	cpc	r25, r1
    3e88:	89 f1       	breq	.+98     	; 0x3eec <xTaskGenericNotify+0x10c>
    3e8a:	3f c0       	rjmp	.+126    	; 0x3f0a <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3e8c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e8e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e90:	21 a1       	ldd	r18, Z+33	; 0x21
    3e92:	32 a1       	ldd	r19, Z+34	; 0x22
    3e94:	43 a1       	ldd	r20, Z+35	; 0x23
    3e96:	54 a1       	ldd	r21, Z+36	; 0x24
    3e98:	8f 81       	ldd	r24, Y+7	; 0x07
    3e9a:	98 85       	ldd	r25, Y+8	; 0x08
    3e9c:	a9 85       	ldd	r26, Y+9	; 0x09
    3e9e:	ba 85       	ldd	r27, Y+10	; 0x0a
    3ea0:	82 2b       	or	r24, r18
    3ea2:	93 2b       	or	r25, r19
    3ea4:	a4 2b       	or	r26, r20
    3ea6:	b5 2b       	or	r27, r21
    3ea8:	eb 81       	ldd	r30, Y+3	; 0x03
    3eaa:	fc 81       	ldd	r31, Y+4	; 0x04
    3eac:	81 a3       	std	Z+33, r24	; 0x21
    3eae:	92 a3       	std	Z+34, r25	; 0x22
    3eb0:	a3 a3       	std	Z+35, r26	; 0x23
    3eb2:	b4 a3       	std	Z+36, r27	; 0x24
    3eb4:	2a c0       	rjmp	.+84     	; 0x3f0a <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3eb6:	eb 81       	ldd	r30, Y+3	; 0x03
    3eb8:	fc 81       	ldd	r31, Y+4	; 0x04
    3eba:	81 a1       	ldd	r24, Z+33	; 0x21
    3ebc:	92 a1       	ldd	r25, Z+34	; 0x22
    3ebe:	a3 a1       	ldd	r26, Z+35	; 0x23
    3ec0:	b4 a1       	ldd	r27, Z+36	; 0x24
    3ec2:	01 96       	adiw	r24, 0x01	; 1
    3ec4:	a1 1d       	adc	r26, r1
    3ec6:	b1 1d       	adc	r27, r1
    3ec8:	eb 81       	ldd	r30, Y+3	; 0x03
    3eca:	fc 81       	ldd	r31, Y+4	; 0x04
    3ecc:	81 a3       	std	Z+33, r24	; 0x21
    3ece:	92 a3       	std	Z+34, r25	; 0x22
    3ed0:	a3 a3       	std	Z+35, r26	; 0x23
    3ed2:	b4 a3       	std	Z+36, r27	; 0x24
    3ed4:	1a c0       	rjmp	.+52     	; 0x3f0a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3ed6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ed8:	fc 81       	ldd	r31, Y+4	; 0x04
    3eda:	8f 81       	ldd	r24, Y+7	; 0x07
    3edc:	98 85       	ldd	r25, Y+8	; 0x08
    3ede:	a9 85       	ldd	r26, Y+9	; 0x09
    3ee0:	ba 85       	ldd	r27, Y+10	; 0x0a
    3ee2:	81 a3       	std	Z+33, r24	; 0x21
    3ee4:	92 a3       	std	Z+34, r25	; 0x22
    3ee6:	a3 a3       	std	Z+35, r26	; 0x23
    3ee8:	b4 a3       	std	Z+36, r27	; 0x24
    3eea:	0f c0       	rjmp	.+30     	; 0x3f0a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3eec:	89 81       	ldd	r24, Y+1	; 0x01
    3eee:	82 30       	cpi	r24, 0x02	; 2
    3ef0:	59 f0       	breq	.+22     	; 0x3f08 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3ef2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ef4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ef6:	8f 81       	ldd	r24, Y+7	; 0x07
    3ef8:	98 85       	ldd	r25, Y+8	; 0x08
    3efa:	a9 85       	ldd	r26, Y+9	; 0x09
    3efc:	ba 85       	ldd	r27, Y+10	; 0x0a
    3efe:	81 a3       	std	Z+33, r24	; 0x21
    3f00:	92 a3       	std	Z+34, r25	; 0x22
    3f02:	a3 a3       	std	Z+35, r26	; 0x23
    3f04:	b4 a3       	std	Z+36, r27	; 0x24
    3f06:	01 c0       	rjmp	.+2      	; 0x3f0a <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3f08:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3f0a:	89 81       	ldd	r24, Y+1	; 0x01
    3f0c:	81 30       	cpi	r24, 0x01	; 1
    3f0e:	b9 f5       	brne	.+110    	; 0x3f7e <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3f10:	8b 81       	ldd	r24, Y+3	; 0x03
    3f12:	9c 81       	ldd	r25, Y+4	; 0x04
    3f14:	02 96       	adiw	r24, 0x02	; 2
    3f16:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    3f1a:	eb 81       	ldd	r30, Y+3	; 0x03
    3f1c:	fc 81       	ldd	r31, Y+4	; 0x04
    3f1e:	96 89       	ldd	r25, Z+22	; 0x16
    3f20:	80 91 f9 02 	lds	r24, 0x02F9
    3f24:	89 17       	cp	r24, r25
    3f26:	28 f4       	brcc	.+10     	; 0x3f32 <xTaskGenericNotify+0x152>
    3f28:	eb 81       	ldd	r30, Y+3	; 0x03
    3f2a:	fc 81       	ldd	r31, Y+4	; 0x04
    3f2c:	86 89       	ldd	r24, Z+22	; 0x16
    3f2e:	80 93 f9 02 	sts	0x02F9, r24
    3f32:	eb 81       	ldd	r30, Y+3	; 0x03
    3f34:	fc 81       	ldd	r31, Y+4	; 0x04
    3f36:	86 89       	ldd	r24, Z+22	; 0x16
    3f38:	28 2f       	mov	r18, r24
    3f3a:	30 e0       	ldi	r19, 0x00	; 0
    3f3c:	c9 01       	movw	r24, r18
    3f3e:	88 0f       	add	r24, r24
    3f40:	99 1f       	adc	r25, r25
    3f42:	88 0f       	add	r24, r24
    3f44:	99 1f       	adc	r25, r25
    3f46:	88 0f       	add	r24, r24
    3f48:	99 1f       	adc	r25, r25
    3f4a:	82 0f       	add	r24, r18
    3f4c:	93 1f       	adc	r25, r19
    3f4e:	ac 01       	movw	r20, r24
    3f50:	4c 5f       	subi	r20, 0xFC	; 252
    3f52:	5c 4f       	sbci	r21, 0xFC	; 252
    3f54:	8b 81       	ldd	r24, Y+3	; 0x03
    3f56:	9c 81       	ldd	r25, Y+4	; 0x04
    3f58:	9c 01       	movw	r18, r24
    3f5a:	2e 5f       	subi	r18, 0xFE	; 254
    3f5c:	3f 4f       	sbci	r19, 0xFF	; 255
    3f5e:	ca 01       	movw	r24, r20
    3f60:	b9 01       	movw	r22, r18
    3f62:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3f66:	eb 81       	ldd	r30, Y+3	; 0x03
    3f68:	fc 81       	ldd	r31, Y+4	; 0x04
    3f6a:	96 89       	ldd	r25, Z+22	; 0x16
    3f6c:	e0 91 f4 02 	lds	r30, 0x02F4
    3f70:	f0 91 f5 02 	lds	r31, 0x02F5
    3f74:	86 89       	ldd	r24, Z+22	; 0x16
    3f76:	89 17       	cp	r24, r25
    3f78:	10 f4       	brcc	.+4      	; 0x3f7e <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    3f7a:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3f7e:	0f 90       	pop	r0
    3f80:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3f82:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    3f84:	2f 96       	adiw	r28, 0x0f	; 15
    3f86:	0f b6       	in	r0, 0x3f	; 63
    3f88:	f8 94       	cli
    3f8a:	de bf       	out	0x3e, r29	; 62
    3f8c:	0f be       	out	0x3f, r0	; 63
    3f8e:	cd bf       	out	0x3d, r28	; 61
    3f90:	cf 91       	pop	r28
    3f92:	df 91       	pop	r29
    3f94:	1f 91       	pop	r17
    3f96:	0f 91       	pop	r16
    3f98:	08 95       	ret

00003f9a <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3f9a:	ef 92       	push	r14
    3f9c:	ff 92       	push	r15
    3f9e:	0f 93       	push	r16
    3fa0:	1f 93       	push	r17
    3fa2:	df 93       	push	r29
    3fa4:	cf 93       	push	r28
    3fa6:	cd b7       	in	r28, 0x3d	; 61
    3fa8:	de b7       	in	r29, 0x3e	; 62
    3faa:	62 97       	sbiw	r28, 0x12	; 18
    3fac:	0f b6       	in	r0, 0x3f	; 63
    3fae:	f8 94       	cli
    3fb0:	de bf       	out	0x3e, r29	; 62
    3fb2:	0f be       	out	0x3f, r0	; 63
    3fb4:	cd bf       	out	0x3d, r28	; 61
    3fb6:	9f 83       	std	Y+7, r25	; 0x07
    3fb8:	8e 83       	std	Y+6, r24	; 0x06
    3fba:	48 87       	std	Y+8, r20	; 0x08
    3fbc:	59 87       	std	Y+9, r21	; 0x09
    3fbe:	6a 87       	std	Y+10, r22	; 0x0a
    3fc0:	7b 87       	std	Y+11, r23	; 0x0b
    3fc2:	2c 87       	std	Y+12, r18	; 0x0c
    3fc4:	1e 87       	std	Y+14, r17	; 0x0e
    3fc6:	0d 87       	std	Y+13, r16	; 0x0d
    3fc8:	f8 8a       	std	Y+16, r15	; 0x10
    3fca:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    3fcc:	81 e0       	ldi	r24, 0x01	; 1
    3fce:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3fd0:	8e 81       	ldd	r24, Y+6	; 0x06
    3fd2:	9f 81       	ldd	r25, Y+7	; 0x07
    3fd4:	9d 83       	std	Y+5, r25	; 0x05
    3fd6:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3fd8:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    3fda:	8d 85       	ldd	r24, Y+13	; 0x0d
    3fdc:	9e 85       	ldd	r25, Y+14	; 0x0e
    3fde:	00 97       	sbiw	r24, 0x00	; 0
    3fe0:	61 f0       	breq	.+24     	; 0x3ffa <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3fe2:	ec 81       	ldd	r30, Y+4	; 0x04
    3fe4:	fd 81       	ldd	r31, Y+5	; 0x05
    3fe6:	81 a1       	ldd	r24, Z+33	; 0x21
    3fe8:	92 a1       	ldd	r25, Z+34	; 0x22
    3fea:	a3 a1       	ldd	r26, Z+35	; 0x23
    3fec:	b4 a1       	ldd	r27, Z+36	; 0x24
    3fee:	ed 85       	ldd	r30, Y+13	; 0x0d
    3ff0:	fe 85       	ldd	r31, Y+14	; 0x0e
    3ff2:	80 83       	st	Z, r24
    3ff4:	91 83       	std	Z+1, r25	; 0x01
    3ff6:	a2 83       	std	Z+2, r26	; 0x02
    3ff8:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3ffa:	ec 81       	ldd	r30, Y+4	; 0x04
    3ffc:	fd 81       	ldd	r31, Y+5	; 0x05
    3ffe:	85 a1       	ldd	r24, Z+37	; 0x25
    4000:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4002:	ec 81       	ldd	r30, Y+4	; 0x04
    4004:	fd 81       	ldd	r31, Y+5	; 0x05
    4006:	82 e0       	ldi	r24, 0x02	; 2
    4008:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    400a:	8c 85       	ldd	r24, Y+12	; 0x0c
    400c:	28 2f       	mov	r18, r24
    400e:	30 e0       	ldi	r19, 0x00	; 0
    4010:	3a 8b       	std	Y+18, r19	; 0x12
    4012:	29 8b       	std	Y+17, r18	; 0x11
    4014:	89 89       	ldd	r24, Y+17	; 0x11
    4016:	9a 89       	ldd	r25, Y+18	; 0x12
    4018:	82 30       	cpi	r24, 0x02	; 2
    401a:	91 05       	cpc	r25, r1
    401c:	59 f1       	breq	.+86     	; 0x4074 <xTaskGenericNotifyFromISR+0xda>
    401e:	29 89       	ldd	r18, Y+17	; 0x11
    4020:	3a 89       	ldd	r19, Y+18	; 0x12
    4022:	23 30       	cpi	r18, 0x03	; 3
    4024:	31 05       	cpc	r19, r1
    4026:	34 f4       	brge	.+12     	; 0x4034 <xTaskGenericNotifyFromISR+0x9a>
    4028:	89 89       	ldd	r24, Y+17	; 0x11
    402a:	9a 89       	ldd	r25, Y+18	; 0x12
    402c:	81 30       	cpi	r24, 0x01	; 1
    402e:	91 05       	cpc	r25, r1
    4030:	61 f0       	breq	.+24     	; 0x404a <xTaskGenericNotifyFromISR+0xb0>
    4032:	4a c0       	rjmp	.+148    	; 0x40c8 <xTaskGenericNotifyFromISR+0x12e>
    4034:	29 89       	ldd	r18, Y+17	; 0x11
    4036:	3a 89       	ldd	r19, Y+18	; 0x12
    4038:	23 30       	cpi	r18, 0x03	; 3
    403a:	31 05       	cpc	r19, r1
    403c:	59 f1       	breq	.+86     	; 0x4094 <xTaskGenericNotifyFromISR+0xfa>
    403e:	89 89       	ldd	r24, Y+17	; 0x11
    4040:	9a 89       	ldd	r25, Y+18	; 0x12
    4042:	84 30       	cpi	r24, 0x04	; 4
    4044:	91 05       	cpc	r25, r1
    4046:	89 f1       	breq	.+98     	; 0x40aa <xTaskGenericNotifyFromISR+0x110>
    4048:	3f c0       	rjmp	.+126    	; 0x40c8 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    404a:	ec 81       	ldd	r30, Y+4	; 0x04
    404c:	fd 81       	ldd	r31, Y+5	; 0x05
    404e:	21 a1       	ldd	r18, Z+33	; 0x21
    4050:	32 a1       	ldd	r19, Z+34	; 0x22
    4052:	43 a1       	ldd	r20, Z+35	; 0x23
    4054:	54 a1       	ldd	r21, Z+36	; 0x24
    4056:	88 85       	ldd	r24, Y+8	; 0x08
    4058:	99 85       	ldd	r25, Y+9	; 0x09
    405a:	aa 85       	ldd	r26, Y+10	; 0x0a
    405c:	bb 85       	ldd	r27, Y+11	; 0x0b
    405e:	82 2b       	or	r24, r18
    4060:	93 2b       	or	r25, r19
    4062:	a4 2b       	or	r26, r20
    4064:	b5 2b       	or	r27, r21
    4066:	ec 81       	ldd	r30, Y+4	; 0x04
    4068:	fd 81       	ldd	r31, Y+5	; 0x05
    406a:	81 a3       	std	Z+33, r24	; 0x21
    406c:	92 a3       	std	Z+34, r25	; 0x22
    406e:	a3 a3       	std	Z+35, r26	; 0x23
    4070:	b4 a3       	std	Z+36, r27	; 0x24
    4072:	2a c0       	rjmp	.+84     	; 0x40c8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4074:	ec 81       	ldd	r30, Y+4	; 0x04
    4076:	fd 81       	ldd	r31, Y+5	; 0x05
    4078:	81 a1       	ldd	r24, Z+33	; 0x21
    407a:	92 a1       	ldd	r25, Z+34	; 0x22
    407c:	a3 a1       	ldd	r26, Z+35	; 0x23
    407e:	b4 a1       	ldd	r27, Z+36	; 0x24
    4080:	01 96       	adiw	r24, 0x01	; 1
    4082:	a1 1d       	adc	r26, r1
    4084:	b1 1d       	adc	r27, r1
    4086:	ec 81       	ldd	r30, Y+4	; 0x04
    4088:	fd 81       	ldd	r31, Y+5	; 0x05
    408a:	81 a3       	std	Z+33, r24	; 0x21
    408c:	92 a3       	std	Z+34, r25	; 0x22
    408e:	a3 a3       	std	Z+35, r26	; 0x23
    4090:	b4 a3       	std	Z+36, r27	; 0x24
    4092:	1a c0       	rjmp	.+52     	; 0x40c8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4094:	ec 81       	ldd	r30, Y+4	; 0x04
    4096:	fd 81       	ldd	r31, Y+5	; 0x05
    4098:	88 85       	ldd	r24, Y+8	; 0x08
    409a:	99 85       	ldd	r25, Y+9	; 0x09
    409c:	aa 85       	ldd	r26, Y+10	; 0x0a
    409e:	bb 85       	ldd	r27, Y+11	; 0x0b
    40a0:	81 a3       	std	Z+33, r24	; 0x21
    40a2:	92 a3       	std	Z+34, r25	; 0x22
    40a4:	a3 a3       	std	Z+35, r26	; 0x23
    40a6:	b4 a3       	std	Z+36, r27	; 0x24
    40a8:	0f c0       	rjmp	.+30     	; 0x40c8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    40aa:	8b 81       	ldd	r24, Y+3	; 0x03
    40ac:	82 30       	cpi	r24, 0x02	; 2
    40ae:	59 f0       	breq	.+22     	; 0x40c6 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    40b0:	ec 81       	ldd	r30, Y+4	; 0x04
    40b2:	fd 81       	ldd	r31, Y+5	; 0x05
    40b4:	88 85       	ldd	r24, Y+8	; 0x08
    40b6:	99 85       	ldd	r25, Y+9	; 0x09
    40b8:	aa 85       	ldd	r26, Y+10	; 0x0a
    40ba:	bb 85       	ldd	r27, Y+11	; 0x0b
    40bc:	81 a3       	std	Z+33, r24	; 0x21
    40be:	92 a3       	std	Z+34, r25	; 0x22
    40c0:	a3 a3       	std	Z+35, r26	; 0x23
    40c2:	b4 a3       	std	Z+36, r27	; 0x24
    40c4:	01 c0       	rjmp	.+2      	; 0x40c8 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    40c6:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    40c8:	8b 81       	ldd	r24, Y+3	; 0x03
    40ca:	81 30       	cpi	r24, 0x01	; 1
    40cc:	09 f0       	breq	.+2      	; 0x40d0 <xTaskGenericNotifyFromISR+0x136>
    40ce:	4f c0       	rjmp	.+158    	; 0x416e <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    40d0:	80 91 03 03 	lds	r24, 0x0303
    40d4:	88 23       	and	r24, r24
    40d6:	61 f5       	brne	.+88     	; 0x4130 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    40d8:	8c 81       	ldd	r24, Y+4	; 0x04
    40da:	9d 81       	ldd	r25, Y+5	; 0x05
    40dc:	02 96       	adiw	r24, 0x02	; 2
    40de:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    40e2:	ec 81       	ldd	r30, Y+4	; 0x04
    40e4:	fd 81       	ldd	r31, Y+5	; 0x05
    40e6:	96 89       	ldd	r25, Z+22	; 0x16
    40e8:	80 91 f9 02 	lds	r24, 0x02F9
    40ec:	89 17       	cp	r24, r25
    40ee:	28 f4       	brcc	.+10     	; 0x40fa <xTaskGenericNotifyFromISR+0x160>
    40f0:	ec 81       	ldd	r30, Y+4	; 0x04
    40f2:	fd 81       	ldd	r31, Y+5	; 0x05
    40f4:	86 89       	ldd	r24, Z+22	; 0x16
    40f6:	80 93 f9 02 	sts	0x02F9, r24
    40fa:	ec 81       	ldd	r30, Y+4	; 0x04
    40fc:	fd 81       	ldd	r31, Y+5	; 0x05
    40fe:	86 89       	ldd	r24, Z+22	; 0x16
    4100:	28 2f       	mov	r18, r24
    4102:	30 e0       	ldi	r19, 0x00	; 0
    4104:	c9 01       	movw	r24, r18
    4106:	88 0f       	add	r24, r24
    4108:	99 1f       	adc	r25, r25
    410a:	88 0f       	add	r24, r24
    410c:	99 1f       	adc	r25, r25
    410e:	88 0f       	add	r24, r24
    4110:	99 1f       	adc	r25, r25
    4112:	82 0f       	add	r24, r18
    4114:	93 1f       	adc	r25, r19
    4116:	ac 01       	movw	r20, r24
    4118:	4c 5f       	subi	r20, 0xFC	; 252
    411a:	5c 4f       	sbci	r21, 0xFC	; 252
    411c:	8c 81       	ldd	r24, Y+4	; 0x04
    411e:	9d 81       	ldd	r25, Y+5	; 0x05
    4120:	9c 01       	movw	r18, r24
    4122:	2e 5f       	subi	r18, 0xFE	; 254
    4124:	3f 4f       	sbci	r19, 0xFF	; 255
    4126:	ca 01       	movw	r24, r20
    4128:	b9 01       	movw	r22, r18
    412a:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>
    412e:	0a c0       	rjmp	.+20     	; 0x4144 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4130:	8c 81       	ldd	r24, Y+4	; 0x04
    4132:	9d 81       	ldd	r25, Y+5	; 0x05
    4134:	9c 01       	movw	r18, r24
    4136:	24 5f       	subi	r18, 0xF4	; 244
    4138:	3f 4f       	sbci	r19, 0xFF	; 255
    413a:	8e e3       	ldi	r24, 0x3E	; 62
    413c:	93 e0       	ldi	r25, 0x03	; 3
    413e:	b9 01       	movw	r22, r18
    4140:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4144:	ec 81       	ldd	r30, Y+4	; 0x04
    4146:	fd 81       	ldd	r31, Y+5	; 0x05
    4148:	96 89       	ldd	r25, Z+22	; 0x16
    414a:	e0 91 f4 02 	lds	r30, 0x02F4
    414e:	f0 91 f5 02 	lds	r31, 0x02F5
    4152:	86 89       	ldd	r24, Z+22	; 0x16
    4154:	89 17       	cp	r24, r25
    4156:	58 f4       	brcc	.+22     	; 0x416e <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4158:	8f 85       	ldd	r24, Y+15	; 0x0f
    415a:	98 89       	ldd	r25, Y+16	; 0x10
    415c:	00 97       	sbiw	r24, 0x00	; 0
    415e:	21 f0       	breq	.+8      	; 0x4168 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4160:	ef 85       	ldd	r30, Y+15	; 0x0f
    4162:	f8 89       	ldd	r31, Y+16	; 0x10
    4164:	81 e0       	ldi	r24, 0x01	; 1
    4166:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4168:	81 e0       	ldi	r24, 0x01	; 1
    416a:	80 93 fc 02 	sts	0x02FC, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    416e:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4170:	62 96       	adiw	r28, 0x12	; 18
    4172:	0f b6       	in	r0, 0x3f	; 63
    4174:	f8 94       	cli
    4176:	de bf       	out	0x3e, r29	; 62
    4178:	0f be       	out	0x3f, r0	; 63
    417a:	cd bf       	out	0x3d, r28	; 61
    417c:	cf 91       	pop	r28
    417e:	df 91       	pop	r29
    4180:	1f 91       	pop	r17
    4182:	0f 91       	pop	r16
    4184:	ff 90       	pop	r15
    4186:	ef 90       	pop	r14
    4188:	08 95       	ret

0000418a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    418a:	df 93       	push	r29
    418c:	cf 93       	push	r28
    418e:	cd b7       	in	r28, 0x3d	; 61
    4190:	de b7       	in	r29, 0x3e	; 62
    4192:	28 97       	sbiw	r28, 0x08	; 8
    4194:	0f b6       	in	r0, 0x3f	; 63
    4196:	f8 94       	cli
    4198:	de bf       	out	0x3e, r29	; 62
    419a:	0f be       	out	0x3f, r0	; 63
    419c:	cd bf       	out	0x3d, r28	; 61
    419e:	9e 83       	std	Y+6, r25	; 0x06
    41a0:	8d 83       	std	Y+5, r24	; 0x05
    41a2:	78 87       	std	Y+8, r23	; 0x08
    41a4:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    41a6:	8d 81       	ldd	r24, Y+5	; 0x05
    41a8:	9e 81       	ldd	r25, Y+6	; 0x06
    41aa:	9c 83       	std	Y+4, r25	; 0x04
    41ac:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    41ae:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    41b0:	eb 81       	ldd	r30, Y+3	; 0x03
    41b2:	fc 81       	ldd	r31, Y+4	; 0x04
    41b4:	85 a1       	ldd	r24, Z+37	; 0x25
    41b6:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    41b8:	eb 81       	ldd	r30, Y+3	; 0x03
    41ba:	fc 81       	ldd	r31, Y+4	; 0x04
    41bc:	82 e0       	ldi	r24, 0x02	; 2
    41be:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    41c0:	eb 81       	ldd	r30, Y+3	; 0x03
    41c2:	fc 81       	ldd	r31, Y+4	; 0x04
    41c4:	81 a1       	ldd	r24, Z+33	; 0x21
    41c6:	92 a1       	ldd	r25, Z+34	; 0x22
    41c8:	a3 a1       	ldd	r26, Z+35	; 0x23
    41ca:	b4 a1       	ldd	r27, Z+36	; 0x24
    41cc:	01 96       	adiw	r24, 0x01	; 1
    41ce:	a1 1d       	adc	r26, r1
    41d0:	b1 1d       	adc	r27, r1
    41d2:	eb 81       	ldd	r30, Y+3	; 0x03
    41d4:	fc 81       	ldd	r31, Y+4	; 0x04
    41d6:	81 a3       	std	Z+33, r24	; 0x21
    41d8:	92 a3       	std	Z+34, r25	; 0x22
    41da:	a3 a3       	std	Z+35, r26	; 0x23
    41dc:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    41de:	8a 81       	ldd	r24, Y+2	; 0x02
    41e0:	81 30       	cpi	r24, 0x01	; 1
    41e2:	09 f0       	breq	.+2      	; 0x41e6 <vTaskNotifyGiveFromISR+0x5c>
    41e4:	4f c0       	rjmp	.+158    	; 0x4284 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    41e6:	80 91 03 03 	lds	r24, 0x0303
    41ea:	88 23       	and	r24, r24
    41ec:	61 f5       	brne	.+88     	; 0x4246 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    41ee:	8b 81       	ldd	r24, Y+3	; 0x03
    41f0:	9c 81       	ldd	r25, Y+4	; 0x04
    41f2:	02 96       	adiw	r24, 0x02	; 2
    41f4:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    41f8:	eb 81       	ldd	r30, Y+3	; 0x03
    41fa:	fc 81       	ldd	r31, Y+4	; 0x04
    41fc:	96 89       	ldd	r25, Z+22	; 0x16
    41fe:	80 91 f9 02 	lds	r24, 0x02F9
    4202:	89 17       	cp	r24, r25
    4204:	28 f4       	brcc	.+10     	; 0x4210 <vTaskNotifyGiveFromISR+0x86>
    4206:	eb 81       	ldd	r30, Y+3	; 0x03
    4208:	fc 81       	ldd	r31, Y+4	; 0x04
    420a:	86 89       	ldd	r24, Z+22	; 0x16
    420c:	80 93 f9 02 	sts	0x02F9, r24
    4210:	eb 81       	ldd	r30, Y+3	; 0x03
    4212:	fc 81       	ldd	r31, Y+4	; 0x04
    4214:	86 89       	ldd	r24, Z+22	; 0x16
    4216:	28 2f       	mov	r18, r24
    4218:	30 e0       	ldi	r19, 0x00	; 0
    421a:	c9 01       	movw	r24, r18
    421c:	88 0f       	add	r24, r24
    421e:	99 1f       	adc	r25, r25
    4220:	88 0f       	add	r24, r24
    4222:	99 1f       	adc	r25, r25
    4224:	88 0f       	add	r24, r24
    4226:	99 1f       	adc	r25, r25
    4228:	82 0f       	add	r24, r18
    422a:	93 1f       	adc	r25, r19
    422c:	ac 01       	movw	r20, r24
    422e:	4c 5f       	subi	r20, 0xFC	; 252
    4230:	5c 4f       	sbci	r21, 0xFC	; 252
    4232:	8b 81       	ldd	r24, Y+3	; 0x03
    4234:	9c 81       	ldd	r25, Y+4	; 0x04
    4236:	9c 01       	movw	r18, r24
    4238:	2e 5f       	subi	r18, 0xFE	; 254
    423a:	3f 4f       	sbci	r19, 0xFF	; 255
    423c:	ca 01       	movw	r24, r20
    423e:	b9 01       	movw	r22, r18
    4240:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>
    4244:	0a c0       	rjmp	.+20     	; 0x425a <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4246:	8b 81       	ldd	r24, Y+3	; 0x03
    4248:	9c 81       	ldd	r25, Y+4	; 0x04
    424a:	9c 01       	movw	r18, r24
    424c:	24 5f       	subi	r18, 0xF4	; 244
    424e:	3f 4f       	sbci	r19, 0xFF	; 255
    4250:	8e e3       	ldi	r24, 0x3E	; 62
    4252:	93 e0       	ldi	r25, 0x03	; 3
    4254:	b9 01       	movw	r22, r18
    4256:	0e 94 c5 0b 	call	0x178a	; 0x178a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    425a:	eb 81       	ldd	r30, Y+3	; 0x03
    425c:	fc 81       	ldd	r31, Y+4	; 0x04
    425e:	96 89       	ldd	r25, Z+22	; 0x16
    4260:	e0 91 f4 02 	lds	r30, 0x02F4
    4264:	f0 91 f5 02 	lds	r31, 0x02F5
    4268:	86 89       	ldd	r24, Z+22	; 0x16
    426a:	89 17       	cp	r24, r25
    426c:	58 f4       	brcc	.+22     	; 0x4284 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    426e:	8f 81       	ldd	r24, Y+7	; 0x07
    4270:	98 85       	ldd	r25, Y+8	; 0x08
    4272:	00 97       	sbiw	r24, 0x00	; 0
    4274:	21 f0       	breq	.+8      	; 0x427e <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4276:	ef 81       	ldd	r30, Y+7	; 0x07
    4278:	f8 85       	ldd	r31, Y+8	; 0x08
    427a:	81 e0       	ldi	r24, 0x01	; 1
    427c:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    427e:	81 e0       	ldi	r24, 0x01	; 1
    4280:	80 93 fc 02 	sts	0x02FC, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4284:	28 96       	adiw	r28, 0x08	; 8
    4286:	0f b6       	in	r0, 0x3f	; 63
    4288:	f8 94       	cli
    428a:	de bf       	out	0x3e, r29	; 62
    428c:	0f be       	out	0x3f, r0	; 63
    428e:	cd bf       	out	0x3d, r28	; 61
    4290:	cf 91       	pop	r28
    4292:	df 91       	pop	r29
    4294:	08 95       	ret

00004296 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    4296:	df 93       	push	r29
    4298:	cf 93       	push	r28
    429a:	cd b7       	in	r28, 0x3d	; 61
    429c:	de b7       	in	r29, 0x3e	; 62
    429e:	27 97       	sbiw	r28, 0x07	; 7
    42a0:	0f b6       	in	r0, 0x3f	; 63
    42a2:	f8 94       	cli
    42a4:	de bf       	out	0x3e, r29	; 62
    42a6:	0f be       	out	0x3f, r0	; 63
    42a8:	cd bf       	out	0x3d, r28	; 61
    42aa:	9d 83       	std	Y+5, r25	; 0x05
    42ac:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    42ae:	8c 81       	ldd	r24, Y+4	; 0x04
    42b0:	9d 81       	ldd	r25, Y+5	; 0x05
    42b2:	00 97       	sbiw	r24, 0x00	; 0
    42b4:	39 f4       	brne	.+14     	; 0x42c4 <xTaskNotifyStateClear+0x2e>
    42b6:	80 91 f4 02 	lds	r24, 0x02F4
    42ba:	90 91 f5 02 	lds	r25, 0x02F5
    42be:	9f 83       	std	Y+7, r25	; 0x07
    42c0:	8e 83       	std	Y+6, r24	; 0x06
    42c2:	04 c0       	rjmp	.+8      	; 0x42cc <xTaskNotifyStateClear+0x36>
    42c4:	8c 81       	ldd	r24, Y+4	; 0x04
    42c6:	9d 81       	ldd	r25, Y+5	; 0x05
    42c8:	9f 83       	std	Y+7, r25	; 0x07
    42ca:	8e 83       	std	Y+6, r24	; 0x06
    42cc:	8e 81       	ldd	r24, Y+6	; 0x06
    42ce:	9f 81       	ldd	r25, Y+7	; 0x07
    42d0:	9b 83       	std	Y+3, r25	; 0x03
    42d2:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    42d4:	0f b6       	in	r0, 0x3f	; 63
    42d6:	f8 94       	cli
    42d8:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    42da:	ea 81       	ldd	r30, Y+2	; 0x02
    42dc:	fb 81       	ldd	r31, Y+3	; 0x03
    42de:	85 a1       	ldd	r24, Z+37	; 0x25
    42e0:	82 30       	cpi	r24, 0x02	; 2
    42e2:	31 f4       	brne	.+12     	; 0x42f0 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    42e4:	ea 81       	ldd	r30, Y+2	; 0x02
    42e6:	fb 81       	ldd	r31, Y+3	; 0x03
    42e8:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    42ea:	81 e0       	ldi	r24, 0x01	; 1
    42ec:	89 83       	std	Y+1, r24	; 0x01
    42ee:	01 c0       	rjmp	.+2      	; 0x42f2 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    42f0:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    42f2:	0f 90       	pop	r0
    42f4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    42f6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    42f8:	27 96       	adiw	r28, 0x07	; 7
    42fa:	0f b6       	in	r0, 0x3f	; 63
    42fc:	f8 94       	cli
    42fe:	de bf       	out	0x3e, r29	; 62
    4300:	0f be       	out	0x3f, r0	; 63
    4302:	cd bf       	out	0x3d, r28	; 61
    4304:	cf 91       	pop	r28
    4306:	df 91       	pop	r29
    4308:	08 95       	ret

0000430a <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    430a:	df 93       	push	r29
    430c:	cf 93       	push	r28
    430e:	cd b7       	in	r28, 0x3d	; 61
    4310:	de b7       	in	r29, 0x3e	; 62
    4312:	27 97       	sbiw	r28, 0x07	; 7
    4314:	0f b6       	in	r0, 0x3f	; 63
    4316:	f8 94       	cli
    4318:	de bf       	out	0x3e, r29	; 62
    431a:	0f be       	out	0x3f, r0	; 63
    431c:	cd bf       	out	0x3d, r28	; 61
    431e:	9e 83       	std	Y+6, r25	; 0x06
    4320:	8d 83       	std	Y+5, r24	; 0x05
    4322:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    4324:	80 91 f7 02 	lds	r24, 0x02F7
    4328:	90 91 f8 02 	lds	r25, 0x02F8
    432c:	9a 83       	std	Y+2, r25	; 0x02
    432e:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4330:	80 91 f4 02 	lds	r24, 0x02F4
    4334:	90 91 f5 02 	lds	r25, 0x02F5
    4338:	02 96       	adiw	r24, 0x02	; 2
    433a:	0e 94 75 0c 	call	0x18ea	; 0x18ea <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    433e:	29 81       	ldd	r18, Y+1	; 0x01
    4340:	3a 81       	ldd	r19, Y+2	; 0x02
    4342:	8d 81       	ldd	r24, Y+5	; 0x05
    4344:	9e 81       	ldd	r25, Y+6	; 0x06
    4346:	82 0f       	add	r24, r18
    4348:	93 1f       	adc	r25, r19
    434a:	9c 83       	std	Y+4, r25	; 0x04
    434c:	8b 83       	std	Y+3, r24	; 0x03

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    434e:	e0 91 f4 02 	lds	r30, 0x02F4
    4352:	f0 91 f5 02 	lds	r31, 0x02F5
    4356:	8b 81       	ldd	r24, Y+3	; 0x03
    4358:	9c 81       	ldd	r25, Y+4	; 0x04
    435a:	93 83       	std	Z+3, r25	; 0x03
    435c:	82 83       	std	Z+2, r24	; 0x02

		if( xTimeToWake < xConstTickCount )
    435e:	2b 81       	ldd	r18, Y+3	; 0x03
    4360:	3c 81       	ldd	r19, Y+4	; 0x04
    4362:	89 81       	ldd	r24, Y+1	; 0x01
    4364:	9a 81       	ldd	r25, Y+2	; 0x02
    4366:	28 17       	cp	r18, r24
    4368:	39 07       	cpc	r19, r25
    436a:	70 f4       	brcc	.+28     	; 0x4388 <prvAddCurrentTaskToDelayedList+0x7e>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    436c:	80 91 3c 03 	lds	r24, 0x033C
    4370:	90 91 3d 03 	lds	r25, 0x033D
    4374:	20 91 f4 02 	lds	r18, 0x02F4
    4378:	30 91 f5 02 	lds	r19, 0x02F5
    437c:	2e 5f       	subi	r18, 0xFE	; 254
    437e:	3f 4f       	sbci	r19, 0xFF	; 255
    4380:	b9 01       	movw	r22, r18
    4382:	0e 94 09 0c 	call	0x1812	; 0x1812 <vListInsert>
    4386:	1e c0       	rjmp	.+60     	; 0x43c4 <prvAddCurrentTaskToDelayedList+0xba>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4388:	40 91 3a 03 	lds	r20, 0x033A
    438c:	50 91 3b 03 	lds	r21, 0x033B
    4390:	80 91 f4 02 	lds	r24, 0x02F4
    4394:	90 91 f5 02 	lds	r25, 0x02F5
    4398:	9c 01       	movw	r18, r24
    439a:	2e 5f       	subi	r18, 0xFE	; 254
    439c:	3f 4f       	sbci	r19, 0xFF	; 255
    439e:	ca 01       	movw	r24, r20
    43a0:	b9 01       	movw	r22, r18
    43a2:	0e 94 09 0c 	call	0x1812	; 0x1812 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    43a6:	20 91 ff 02 	lds	r18, 0x02FF
    43aa:	30 91 00 03 	lds	r19, 0x0300
    43ae:	8b 81       	ldd	r24, Y+3	; 0x03
    43b0:	9c 81       	ldd	r25, Y+4	; 0x04
    43b2:	82 17       	cp	r24, r18
    43b4:	93 07       	cpc	r25, r19
    43b6:	30 f4       	brcc	.+12     	; 0x43c4 <prvAddCurrentTaskToDelayedList+0xba>
			{
				xNextTaskUnblockTime = xTimeToWake;
    43b8:	8b 81       	ldd	r24, Y+3	; 0x03
    43ba:	9c 81       	ldd	r25, Y+4	; 0x04
    43bc:	90 93 00 03 	sts	0x0300, r25
    43c0:	80 93 ff 02 	sts	0x02FF, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    43c4:	27 96       	adiw	r28, 0x07	; 7
    43c6:	0f b6       	in	r0, 0x3f	; 63
    43c8:	f8 94       	cli
    43ca:	de bf       	out	0x3e, r29	; 62
    43cc:	0f be       	out	0x3f, r0	; 63
    43ce:	cd bf       	out	0x3d, r28	; 61
    43d0:	cf 91       	pop	r28
    43d2:	df 91       	pop	r29
    43d4:	08 95       	ret

000043d6 <DIO_void_set_port_dir>:


/* Implementing of the driver functions */
/* Set direction of PORTx functions */
void DIO_void_set_port_dir(u8 copy_u8_port_id, u8 port_dir_copy)
{
    43d6:	df 93       	push	r29
    43d8:	cf 93       	push	r28
    43da:	00 d0       	rcall	.+0      	; 0x43dc <DIO_void_set_port_dir+0x6>
    43dc:	cd b7       	in	r28, 0x3d	; 61
    43de:	de b7       	in	r29, 0x3e	; 62
    43e0:	89 83       	std	Y+1, r24	; 0x01
    43e2:	6a 83       	std	Y+2, r22	; 0x02
	 *						1: for output pin
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT Direction Register DDRx
	 */
	*(DIO_DDRx_REF[copy_u8_port_id]) = port_dir_copy;
    43e4:	89 81       	ldd	r24, Y+1	; 0x01
    43e6:	88 2f       	mov	r24, r24
    43e8:	90 e0       	ldi	r25, 0x00	; 0
    43ea:	88 0f       	add	r24, r24
    43ec:	99 1f       	adc	r25, r25
    43ee:	fc 01       	movw	r30, r24
    43f0:	e9 57       	subi	r30, 0x79	; 121
    43f2:	ff 4f       	sbci	r31, 0xFF	; 255
    43f4:	01 90       	ld	r0, Z+
    43f6:	f0 81       	ld	r31, Z
    43f8:	e0 2d       	mov	r30, r0
    43fa:	8a 81       	ldd	r24, Y+2	; 0x02
    43fc:	80 83       	st	Z, r24
}
    43fe:	0f 90       	pop	r0
    4400:	0f 90       	pop	r0
    4402:	cf 91       	pop	r28
    4404:	df 91       	pop	r29
    4406:	08 95       	ret

00004408 <DIO_void_set_port_in_pullUp>:


void DIO_void_set_port_in_pullUp(u8 copy_u8_port_id)
{
    4408:	df 93       	push	r29
    440a:	cf 93       	push	r28
    440c:	0f 92       	push	r0
    440e:	cd b7       	in	r28, 0x3d	; 61
    4410:	de b7       	in	r29, 0x3e	; 62
    4412:	89 83       	std	Y+1, r24	; 0x01
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT Direction Register DDRx
	 */
	*(DIO_DDRx_REF[copy_u8_port_id]) = INPUT;
    4414:	89 81       	ldd	r24, Y+1	; 0x01
    4416:	88 2f       	mov	r24, r24
    4418:	90 e0       	ldi	r25, 0x00	; 0
    441a:	88 0f       	add	r24, r24
    441c:	99 1f       	adc	r25, r25
    441e:	fc 01       	movw	r30, r24
    4420:	e9 57       	subi	r30, 0x79	; 121
    4422:	ff 4f       	sbci	r31, 0xFF	; 255
    4424:	01 90       	ld	r0, Z+
    4426:	f0 81       	ld	r31, Z
    4428:	e0 2d       	mov	r30, r0
    442a:	10 82       	st	Z, r1
	*(DIO_PORTx_REF[copy_u8_port_id]) = PORT_MAX;
    442c:	89 81       	ldd	r24, Y+1	; 0x01
    442e:	88 2f       	mov	r24, r24
    4430:	90 e0       	ldi	r25, 0x00	; 0
    4432:	88 0f       	add	r24, r24
    4434:	99 1f       	adc	r25, r25
    4436:	fc 01       	movw	r30, r24
    4438:	e1 57       	subi	r30, 0x71	; 113
    443a:	ff 4f       	sbci	r31, 0xFF	; 255
    443c:	01 90       	ld	r0, Z+
    443e:	f0 81       	ld	r31, Z
    4440:	e0 2d       	mov	r30, r0
    4442:	8f ef       	ldi	r24, 0xFF	; 255
    4444:	80 83       	st	Z, r24
}
    4446:	0f 90       	pop	r0
    4448:	cf 91       	pop	r28
    444a:	df 91       	pop	r29
    444c:	08 95       	ret

0000444e <DIO_u8_get_PortDir>:


u8 DIO_u8_get_PortDir(u8 copy_u8_port_id)
{
    444e:	df 93       	push	r29
    4450:	cf 93       	push	r28
    4452:	0f 92       	push	r0
    4454:	cd b7       	in	r28, 0x3d	; 61
    4456:	de b7       	in	r29, 0x3e	; 62
    4458:	89 83       	std	Y+1, r24	; 0x01
	return *(DIO_DDRx_REF[copy_u8_port_id]);
    445a:	89 81       	ldd	r24, Y+1	; 0x01
    445c:	88 2f       	mov	r24, r24
    445e:	90 e0       	ldi	r25, 0x00	; 0
    4460:	88 0f       	add	r24, r24
    4462:	99 1f       	adc	r25, r25
    4464:	fc 01       	movw	r30, r24
    4466:	e9 57       	subi	r30, 0x79	; 121
    4468:	ff 4f       	sbci	r31, 0xFF	; 255
    446a:	01 90       	ld	r0, Z+
    446c:	f0 81       	ld	r31, Z
    446e:	e0 2d       	mov	r30, r0
    4470:	80 81       	ld	r24, Z
}
    4472:	0f 90       	pop	r0
    4474:	cf 91       	pop	r28
    4476:	df 91       	pop	r29
    4478:	08 95       	ret

0000447a <DIO_void_set_pin_dir>:

/* Set direction of PINx functions */
void DIO_void_set_pin_dir(u8 copy_u8_port_id, u8 copy_u8_pin_num, u8 pin_dir_copy)
{
    447a:	df 93       	push	r29
    447c:	cf 93       	push	r28
    447e:	00 d0       	rcall	.+0      	; 0x4480 <DIO_void_set_pin_dir+0x6>
    4480:	0f 92       	push	r0
    4482:	cd b7       	in	r28, 0x3d	; 61
    4484:	de b7       	in	r29, 0x3e	; 62
    4486:	89 83       	std	Y+1, r24	; 0x01
    4488:	6a 83       	std	Y+2, r22	; 0x02
    448a:	4b 83       	std	Y+3, r20	; 0x03
	 *				   1: for output pin
	 *
	 * Function does not return any output, yet it affects the 
	 * pin in the PORT Direction Register DDRx
	 */	
	agn_bit(*(DIO_DDRx_REF[copy_u8_port_id]), copy_u8_pin_num, pin_dir_copy);
    448c:	8b 81       	ldd	r24, Y+3	; 0x03
    448e:	88 23       	and	r24, r24
    4490:	29 f1       	breq	.+74     	; 0x44dc <DIO_void_set_pin_dir+0x62>
    4492:	89 81       	ldd	r24, Y+1	; 0x01
    4494:	88 2f       	mov	r24, r24
    4496:	90 e0       	ldi	r25, 0x00	; 0
    4498:	88 0f       	add	r24, r24
    449a:	99 1f       	adc	r25, r25
    449c:	fc 01       	movw	r30, r24
    449e:	e9 57       	subi	r30, 0x79	; 121
    44a0:	ff 4f       	sbci	r31, 0xFF	; 255
    44a2:	a0 81       	ld	r26, Z
    44a4:	b1 81       	ldd	r27, Z+1	; 0x01
    44a6:	89 81       	ldd	r24, Y+1	; 0x01
    44a8:	88 2f       	mov	r24, r24
    44aa:	90 e0       	ldi	r25, 0x00	; 0
    44ac:	88 0f       	add	r24, r24
    44ae:	99 1f       	adc	r25, r25
    44b0:	fc 01       	movw	r30, r24
    44b2:	e9 57       	subi	r30, 0x79	; 121
    44b4:	ff 4f       	sbci	r31, 0xFF	; 255
    44b6:	01 90       	ld	r0, Z+
    44b8:	f0 81       	ld	r31, Z
    44ba:	e0 2d       	mov	r30, r0
    44bc:	80 81       	ld	r24, Z
    44be:	48 2f       	mov	r20, r24
    44c0:	8a 81       	ldd	r24, Y+2	; 0x02
    44c2:	28 2f       	mov	r18, r24
    44c4:	30 e0       	ldi	r19, 0x00	; 0
    44c6:	81 e0       	ldi	r24, 0x01	; 1
    44c8:	90 e0       	ldi	r25, 0x00	; 0
    44ca:	02 2e       	mov	r0, r18
    44cc:	02 c0       	rjmp	.+4      	; 0x44d2 <DIO_void_set_pin_dir+0x58>
    44ce:	88 0f       	add	r24, r24
    44d0:	99 1f       	adc	r25, r25
    44d2:	0a 94       	dec	r0
    44d4:	e2 f7       	brpl	.-8      	; 0x44ce <DIO_void_set_pin_dir+0x54>
    44d6:	84 2b       	or	r24, r20
    44d8:	8c 93       	st	X, r24
    44da:	25 c0       	rjmp	.+74     	; 0x4526 <DIO_void_set_pin_dir+0xac>
    44dc:	89 81       	ldd	r24, Y+1	; 0x01
    44de:	88 2f       	mov	r24, r24
    44e0:	90 e0       	ldi	r25, 0x00	; 0
    44e2:	88 0f       	add	r24, r24
    44e4:	99 1f       	adc	r25, r25
    44e6:	fc 01       	movw	r30, r24
    44e8:	e9 57       	subi	r30, 0x79	; 121
    44ea:	ff 4f       	sbci	r31, 0xFF	; 255
    44ec:	a0 81       	ld	r26, Z
    44ee:	b1 81       	ldd	r27, Z+1	; 0x01
    44f0:	89 81       	ldd	r24, Y+1	; 0x01
    44f2:	88 2f       	mov	r24, r24
    44f4:	90 e0       	ldi	r25, 0x00	; 0
    44f6:	88 0f       	add	r24, r24
    44f8:	99 1f       	adc	r25, r25
    44fa:	fc 01       	movw	r30, r24
    44fc:	e9 57       	subi	r30, 0x79	; 121
    44fe:	ff 4f       	sbci	r31, 0xFF	; 255
    4500:	01 90       	ld	r0, Z+
    4502:	f0 81       	ld	r31, Z
    4504:	e0 2d       	mov	r30, r0
    4506:	80 81       	ld	r24, Z
    4508:	48 2f       	mov	r20, r24
    450a:	8a 81       	ldd	r24, Y+2	; 0x02
    450c:	28 2f       	mov	r18, r24
    450e:	30 e0       	ldi	r19, 0x00	; 0
    4510:	81 e0       	ldi	r24, 0x01	; 1
    4512:	90 e0       	ldi	r25, 0x00	; 0
    4514:	02 2e       	mov	r0, r18
    4516:	02 c0       	rjmp	.+4      	; 0x451c <DIO_void_set_pin_dir+0xa2>
    4518:	88 0f       	add	r24, r24
    451a:	99 1f       	adc	r25, r25
    451c:	0a 94       	dec	r0
    451e:	e2 f7       	brpl	.-8      	; 0x4518 <DIO_void_set_pin_dir+0x9e>
    4520:	80 95       	com	r24
    4522:	84 23       	and	r24, r20
    4524:	8c 93       	st	X, r24
}
    4526:	0f 90       	pop	r0
    4528:	0f 90       	pop	r0
    452a:	0f 90       	pop	r0
    452c:	cf 91       	pop	r28
    452e:	df 91       	pop	r29
    4530:	08 95       	ret

00004532 <DIO_void_set_pin_in_pullUP>:


void DIO_void_set_pin_in_pullUP(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    4532:	df 93       	push	r29
    4534:	cf 93       	push	r28
    4536:	00 d0       	rcall	.+0      	; 0x4538 <DIO_void_set_pin_in_pullUP+0x6>
    4538:	cd b7       	in	r28, 0x3d	; 61
    453a:	de b7       	in	r29, 0x3e	; 62
    453c:	89 83       	std	Y+1, r24	; 0x01
    453e:	6a 83       	std	Y+2, r22	; 0x02
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	pin in the PORT Direction Register DDRx					  
	 */
	clr_bit(*(DIO_DDRx_REF[copy_u8_port_id]), copy_u8_pin_num);
    4540:	89 81       	ldd	r24, Y+1	; 0x01
    4542:	88 2f       	mov	r24, r24
    4544:	90 e0       	ldi	r25, 0x00	; 0
    4546:	88 0f       	add	r24, r24
    4548:	99 1f       	adc	r25, r25
    454a:	fc 01       	movw	r30, r24
    454c:	e9 57       	subi	r30, 0x79	; 121
    454e:	ff 4f       	sbci	r31, 0xFF	; 255
    4550:	a0 81       	ld	r26, Z
    4552:	b1 81       	ldd	r27, Z+1	; 0x01
    4554:	89 81       	ldd	r24, Y+1	; 0x01
    4556:	88 2f       	mov	r24, r24
    4558:	90 e0       	ldi	r25, 0x00	; 0
    455a:	88 0f       	add	r24, r24
    455c:	99 1f       	adc	r25, r25
    455e:	fc 01       	movw	r30, r24
    4560:	e9 57       	subi	r30, 0x79	; 121
    4562:	ff 4f       	sbci	r31, 0xFF	; 255
    4564:	01 90       	ld	r0, Z+
    4566:	f0 81       	ld	r31, Z
    4568:	e0 2d       	mov	r30, r0
    456a:	80 81       	ld	r24, Z
    456c:	48 2f       	mov	r20, r24
    456e:	8a 81       	ldd	r24, Y+2	; 0x02
    4570:	28 2f       	mov	r18, r24
    4572:	30 e0       	ldi	r19, 0x00	; 0
    4574:	81 e0       	ldi	r24, 0x01	; 1
    4576:	90 e0       	ldi	r25, 0x00	; 0
    4578:	02 c0       	rjmp	.+4      	; 0x457e <DIO_void_set_pin_in_pullUP+0x4c>
    457a:	88 0f       	add	r24, r24
    457c:	99 1f       	adc	r25, r25
    457e:	2a 95       	dec	r18
    4580:	e2 f7       	brpl	.-8      	; 0x457a <DIO_void_set_pin_in_pullUP+0x48>
    4582:	80 95       	com	r24
    4584:	84 23       	and	r24, r20
    4586:	8c 93       	st	X, r24
	set_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    4588:	89 81       	ldd	r24, Y+1	; 0x01
    458a:	88 2f       	mov	r24, r24
    458c:	90 e0       	ldi	r25, 0x00	; 0
    458e:	88 0f       	add	r24, r24
    4590:	99 1f       	adc	r25, r25
    4592:	fc 01       	movw	r30, r24
    4594:	e1 57       	subi	r30, 0x71	; 113
    4596:	ff 4f       	sbci	r31, 0xFF	; 255
    4598:	a0 81       	ld	r26, Z
    459a:	b1 81       	ldd	r27, Z+1	; 0x01
    459c:	89 81       	ldd	r24, Y+1	; 0x01
    459e:	88 2f       	mov	r24, r24
    45a0:	90 e0       	ldi	r25, 0x00	; 0
    45a2:	88 0f       	add	r24, r24
    45a4:	99 1f       	adc	r25, r25
    45a6:	fc 01       	movw	r30, r24
    45a8:	e1 57       	subi	r30, 0x71	; 113
    45aa:	ff 4f       	sbci	r31, 0xFF	; 255
    45ac:	01 90       	ld	r0, Z+
    45ae:	f0 81       	ld	r31, Z
    45b0:	e0 2d       	mov	r30, r0
    45b2:	80 81       	ld	r24, Z
    45b4:	48 2f       	mov	r20, r24
    45b6:	8a 81       	ldd	r24, Y+2	; 0x02
    45b8:	28 2f       	mov	r18, r24
    45ba:	30 e0       	ldi	r19, 0x00	; 0
    45bc:	81 e0       	ldi	r24, 0x01	; 1
    45be:	90 e0       	ldi	r25, 0x00	; 0
    45c0:	02 2e       	mov	r0, r18
    45c2:	02 c0       	rjmp	.+4      	; 0x45c8 <DIO_void_set_pin_in_pullUP+0x96>
    45c4:	88 0f       	add	r24, r24
    45c6:	99 1f       	adc	r25, r25
    45c8:	0a 94       	dec	r0
    45ca:	e2 f7       	brpl	.-8      	; 0x45c4 <DIO_void_set_pin_in_pullUP+0x92>
    45cc:	84 2b       	or	r24, r20
    45ce:	8c 93       	st	X, r24
}
    45d0:	0f 90       	pop	r0
    45d2:	0f 90       	pop	r0
    45d4:	cf 91       	pop	r28
    45d6:	df 91       	pop	r29
    45d8:	08 95       	ret

000045da <DIO_u8_get_PinDir>:


u8 DIO_u8_get_PinDir(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    45da:	df 93       	push	r29
    45dc:	cf 93       	push	r28
    45de:	00 d0       	rcall	.+0      	; 0x45e0 <DIO_u8_get_PinDir+0x6>
    45e0:	cd b7       	in	r28, 0x3d	; 61
    45e2:	de b7       	in	r29, 0x3e	; 62
    45e4:	89 83       	std	Y+1, r24	; 0x01
    45e6:	6a 83       	std	Y+2, r22	; 0x02
	return get_bit(*(DIO_DDRx_REF[copy_u8_port_id]), copy_u8_pin_num);
    45e8:	89 81       	ldd	r24, Y+1	; 0x01
    45ea:	88 2f       	mov	r24, r24
    45ec:	90 e0       	ldi	r25, 0x00	; 0
    45ee:	88 0f       	add	r24, r24
    45f0:	99 1f       	adc	r25, r25
    45f2:	fc 01       	movw	r30, r24
    45f4:	e9 57       	subi	r30, 0x79	; 121
    45f6:	ff 4f       	sbci	r31, 0xFF	; 255
    45f8:	01 90       	ld	r0, Z+
    45fa:	f0 81       	ld	r31, Z
    45fc:	e0 2d       	mov	r30, r0
    45fe:	80 81       	ld	r24, Z
    4600:	28 2f       	mov	r18, r24
    4602:	30 e0       	ldi	r19, 0x00	; 0
    4604:	8a 81       	ldd	r24, Y+2	; 0x02
    4606:	88 2f       	mov	r24, r24
    4608:	90 e0       	ldi	r25, 0x00	; 0
    460a:	a9 01       	movw	r20, r18
    460c:	02 c0       	rjmp	.+4      	; 0x4612 <DIO_u8_get_PinDir+0x38>
    460e:	55 95       	asr	r21
    4610:	47 95       	ror	r20
    4612:	8a 95       	dec	r24
    4614:	e2 f7       	brpl	.-8      	; 0x460e <DIO_u8_get_PinDir+0x34>
    4616:	ca 01       	movw	r24, r20
    4618:	81 70       	andi	r24, 0x01	; 1
}
    461a:	0f 90       	pop	r0
    461c:	0f 90       	pop	r0
    461e:	cf 91       	pop	r28
    4620:	df 91       	pop	r29
    4622:	08 95       	ret

00004624 <DIO_void_set_port>:


/* Assign Value to output PORTx functions */
void DIO_void_set_port(u8 copy_u8_port_id)
{
    4624:	df 93       	push	r29
    4626:	cf 93       	push	r28
    4628:	0f 92       	push	r0
    462a:	cd b7       	in	r28, 0x3d	; 61
    462c:	de b7       	in	r29, 0x3e	; 62
    462e:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = PORT_MAX;
    4630:	89 81       	ldd	r24, Y+1	; 0x01
    4632:	88 2f       	mov	r24, r24
    4634:	90 e0       	ldi	r25, 0x00	; 0
    4636:	88 0f       	add	r24, r24
    4638:	99 1f       	adc	r25, r25
    463a:	fc 01       	movw	r30, r24
    463c:	e1 57       	subi	r30, 0x71	; 113
    463e:	ff 4f       	sbci	r31, 0xFF	; 255
    4640:	01 90       	ld	r0, Z+
    4642:	f0 81       	ld	r31, Z
    4644:	e0 2d       	mov	r30, r0
    4646:	8f ef       	ldi	r24, 0xFF	; 255
    4648:	80 83       	st	Z, r24
}
    464a:	0f 90       	pop	r0
    464c:	cf 91       	pop	r28
    464e:	df 91       	pop	r29
    4650:	08 95       	ret

00004652 <DIO_void_clear_port>:


void DIO_void_clear_port(u8 copy_u8_port_id)
{
    4652:	df 93       	push	r29
    4654:	cf 93       	push	r28
    4656:	0f 92       	push	r0
    4658:	cd b7       	in	r28, 0x3d	; 61
    465a:	de b7       	in	r29, 0x3e	; 62
    465c:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = LOW;
    465e:	89 81       	ldd	r24, Y+1	; 0x01
    4660:	88 2f       	mov	r24, r24
    4662:	90 e0       	ldi	r25, 0x00	; 0
    4664:	88 0f       	add	r24, r24
    4666:	99 1f       	adc	r25, r25
    4668:	fc 01       	movw	r30, r24
    466a:	e1 57       	subi	r30, 0x71	; 113
    466c:	ff 4f       	sbci	r31, 0xFF	; 255
    466e:	01 90       	ld	r0, Z+
    4670:	f0 81       	ld	r31, Z
    4672:	e0 2d       	mov	r30, r0
    4674:	10 82       	st	Z, r1
}
    4676:	0f 90       	pop	r0
    4678:	cf 91       	pop	r28
    467a:	df 91       	pop	r29
    467c:	08 95       	ret

0000467e <DIO_void_toggle_port>:


void DIO_void_toggle_port(u8 copy_u8_port_id)
{
    467e:	df 93       	push	r29
    4680:	cf 93       	push	r28
    4682:	0f 92       	push	r0
    4684:	cd b7       	in	r28, 0x3d	; 61
    4686:	de b7       	in	r29, 0x3e	; 62
    4688:	89 83       	std	Y+1, r24	; 0x01
	 *													 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) ^= PORT_MAX;
    468a:	89 81       	ldd	r24, Y+1	; 0x01
    468c:	88 2f       	mov	r24, r24
    468e:	90 e0       	ldi	r25, 0x00	; 0
    4690:	88 0f       	add	r24, r24
    4692:	99 1f       	adc	r25, r25
    4694:	fc 01       	movw	r30, r24
    4696:	e1 57       	subi	r30, 0x71	; 113
    4698:	ff 4f       	sbci	r31, 0xFF	; 255
    469a:	a0 81       	ld	r26, Z
    469c:	b1 81       	ldd	r27, Z+1	; 0x01
    469e:	89 81       	ldd	r24, Y+1	; 0x01
    46a0:	88 2f       	mov	r24, r24
    46a2:	90 e0       	ldi	r25, 0x00	; 0
    46a4:	88 0f       	add	r24, r24
    46a6:	99 1f       	adc	r25, r25
    46a8:	fc 01       	movw	r30, r24
    46aa:	e1 57       	subi	r30, 0x71	; 113
    46ac:	ff 4f       	sbci	r31, 0xFF	; 255
    46ae:	01 90       	ld	r0, Z+
    46b0:	f0 81       	ld	r31, Z
    46b2:	e0 2d       	mov	r30, r0
    46b4:	80 81       	ld	r24, Z
    46b6:	80 95       	com	r24
    46b8:	8c 93       	st	X, r24
}
    46ba:	0f 90       	pop	r0
    46bc:	cf 91       	pop	r28
    46be:	df 91       	pop	r29
    46c0:	08 95       	ret

000046c2 <DIO_void_assign_port>:


void DIO_void_assign_port(u8 copy_u8_port_id, u8 port_val)
{
    46c2:	df 93       	push	r29
    46c4:	cf 93       	push	r28
    46c6:	00 d0       	rcall	.+0      	; 0x46c8 <DIO_void_assign_port+0x6>
    46c8:	cd b7       	in	r28, 0x3d	; 61
    46ca:	de b7       	in	r29, 0x3e	; 62
    46cc:	89 83       	std	Y+1, r24	; 0x01
    46ce:	6a 83       	std	Y+2, r22	; 0x02
	 *												  	 (3, PORTD)
	 *	
	 *	Function does not return any output, yet it affects the 
	 *	PORT output Register PORTx							       
	 */
	*(DIO_PORTx_REF[copy_u8_port_id]) = port_val;
    46d0:	89 81       	ldd	r24, Y+1	; 0x01
    46d2:	88 2f       	mov	r24, r24
    46d4:	90 e0       	ldi	r25, 0x00	; 0
    46d6:	88 0f       	add	r24, r24
    46d8:	99 1f       	adc	r25, r25
    46da:	fc 01       	movw	r30, r24
    46dc:	e1 57       	subi	r30, 0x71	; 113
    46de:	ff 4f       	sbci	r31, 0xFF	; 255
    46e0:	01 90       	ld	r0, Z+
    46e2:	f0 81       	ld	r31, Z
    46e4:	e0 2d       	mov	r30, r0
    46e6:	8a 81       	ldd	r24, Y+2	; 0x02
    46e8:	80 83       	st	Z, r24
}
    46ea:	0f 90       	pop	r0
    46ec:	0f 90       	pop	r0
    46ee:	cf 91       	pop	r28
    46f0:	df 91       	pop	r29
    46f2:	08 95       	ret

000046f4 <DIO_u8_get_PortOut>:


u8 DIO_u8_get_PortOut(u8 copy_u8_port_id)
{
    46f4:	df 93       	push	r29
    46f6:	cf 93       	push	r28
    46f8:	0f 92       	push	r0
    46fa:	cd b7       	in	r28, 0x3d	; 61
    46fc:	de b7       	in	r29, 0x3e	; 62
    46fe:	89 83       	std	Y+1, r24	; 0x01
	/*
	 *
	 */
	return *(DIO_PORTx_REF[copy_u8_port_id]);
    4700:	89 81       	ldd	r24, Y+1	; 0x01
    4702:	88 2f       	mov	r24, r24
    4704:	90 e0       	ldi	r25, 0x00	; 0
    4706:	88 0f       	add	r24, r24
    4708:	99 1f       	adc	r25, r25
    470a:	fc 01       	movw	r30, r24
    470c:	e1 57       	subi	r30, 0x71	; 113
    470e:	ff 4f       	sbci	r31, 0xFF	; 255
    4710:	01 90       	ld	r0, Z+
    4712:	f0 81       	ld	r31, Z
    4714:	e0 2d       	mov	r30, r0
    4716:	80 81       	ld	r24, Z
}
    4718:	0f 90       	pop	r0
    471a:	cf 91       	pop	r28
    471c:	df 91       	pop	r29
    471e:	08 95       	ret

00004720 <DIO_void_set_pin>:


/* Assign Value to output PINx functions */
void DIO_void_set_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    4720:	df 93       	push	r29
    4722:	cf 93       	push	r28
    4724:	00 d0       	rcall	.+0      	; 0x4726 <DIO_void_set_pin+0x6>
    4726:	cd b7       	in	r28, 0x3d	; 61
    4728:	de b7       	in	r29, 0x3e	; 62
    472a:	89 83       	std	Y+1, r24	; 0x01
    472c:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	set_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    472e:	89 81       	ldd	r24, Y+1	; 0x01
    4730:	88 2f       	mov	r24, r24
    4732:	90 e0       	ldi	r25, 0x00	; 0
    4734:	88 0f       	add	r24, r24
    4736:	99 1f       	adc	r25, r25
    4738:	fc 01       	movw	r30, r24
    473a:	e1 57       	subi	r30, 0x71	; 113
    473c:	ff 4f       	sbci	r31, 0xFF	; 255
    473e:	a0 81       	ld	r26, Z
    4740:	b1 81       	ldd	r27, Z+1	; 0x01
    4742:	89 81       	ldd	r24, Y+1	; 0x01
    4744:	88 2f       	mov	r24, r24
    4746:	90 e0       	ldi	r25, 0x00	; 0
    4748:	88 0f       	add	r24, r24
    474a:	99 1f       	adc	r25, r25
    474c:	fc 01       	movw	r30, r24
    474e:	e1 57       	subi	r30, 0x71	; 113
    4750:	ff 4f       	sbci	r31, 0xFF	; 255
    4752:	01 90       	ld	r0, Z+
    4754:	f0 81       	ld	r31, Z
    4756:	e0 2d       	mov	r30, r0
    4758:	80 81       	ld	r24, Z
    475a:	48 2f       	mov	r20, r24
    475c:	8a 81       	ldd	r24, Y+2	; 0x02
    475e:	28 2f       	mov	r18, r24
    4760:	30 e0       	ldi	r19, 0x00	; 0
    4762:	81 e0       	ldi	r24, 0x01	; 1
    4764:	90 e0       	ldi	r25, 0x00	; 0
    4766:	02 2e       	mov	r0, r18
    4768:	02 c0       	rjmp	.+4      	; 0x476e <DIO_void_set_pin+0x4e>
    476a:	88 0f       	add	r24, r24
    476c:	99 1f       	adc	r25, r25
    476e:	0a 94       	dec	r0
    4770:	e2 f7       	brpl	.-8      	; 0x476a <DIO_void_set_pin+0x4a>
    4772:	84 2b       	or	r24, r20
    4774:	8c 93       	st	X, r24
}
    4776:	0f 90       	pop	r0
    4778:	0f 90       	pop	r0
    477a:	cf 91       	pop	r28
    477c:	df 91       	pop	r29
    477e:	08 95       	ret

00004780 <DIO_void_clear_pin>:


void DIO_void_clear_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    4780:	df 93       	push	r29
    4782:	cf 93       	push	r28
    4784:	00 d0       	rcall	.+0      	; 0x4786 <DIO_void_clear_pin+0x6>
    4786:	cd b7       	in	r28, 0x3d	; 61
    4788:	de b7       	in	r29, 0x3e	; 62
    478a:	89 83       	std	Y+1, r24	; 0x01
    478c:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	clr_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    478e:	89 81       	ldd	r24, Y+1	; 0x01
    4790:	88 2f       	mov	r24, r24
    4792:	90 e0       	ldi	r25, 0x00	; 0
    4794:	88 0f       	add	r24, r24
    4796:	99 1f       	adc	r25, r25
    4798:	fc 01       	movw	r30, r24
    479a:	e1 57       	subi	r30, 0x71	; 113
    479c:	ff 4f       	sbci	r31, 0xFF	; 255
    479e:	a0 81       	ld	r26, Z
    47a0:	b1 81       	ldd	r27, Z+1	; 0x01
    47a2:	89 81       	ldd	r24, Y+1	; 0x01
    47a4:	88 2f       	mov	r24, r24
    47a6:	90 e0       	ldi	r25, 0x00	; 0
    47a8:	88 0f       	add	r24, r24
    47aa:	99 1f       	adc	r25, r25
    47ac:	fc 01       	movw	r30, r24
    47ae:	e1 57       	subi	r30, 0x71	; 113
    47b0:	ff 4f       	sbci	r31, 0xFF	; 255
    47b2:	01 90       	ld	r0, Z+
    47b4:	f0 81       	ld	r31, Z
    47b6:	e0 2d       	mov	r30, r0
    47b8:	80 81       	ld	r24, Z
    47ba:	48 2f       	mov	r20, r24
    47bc:	8a 81       	ldd	r24, Y+2	; 0x02
    47be:	28 2f       	mov	r18, r24
    47c0:	30 e0       	ldi	r19, 0x00	; 0
    47c2:	81 e0       	ldi	r24, 0x01	; 1
    47c4:	90 e0       	ldi	r25, 0x00	; 0
    47c6:	02 2e       	mov	r0, r18
    47c8:	02 c0       	rjmp	.+4      	; 0x47ce <DIO_void_clear_pin+0x4e>
    47ca:	88 0f       	add	r24, r24
    47cc:	99 1f       	adc	r25, r25
    47ce:	0a 94       	dec	r0
    47d0:	e2 f7       	brpl	.-8      	; 0x47ca <DIO_void_clear_pin+0x4a>
    47d2:	80 95       	com	r24
    47d4:	84 23       	and	r24, r20
    47d6:	8c 93       	st	X, r24
}
    47d8:	0f 90       	pop	r0
    47da:	0f 90       	pop	r0
    47dc:	cf 91       	pop	r28
    47de:	df 91       	pop	r29
    47e0:	08 95       	ret

000047e2 <DIO_void_toggle_pin>:


void DIO_void_toggle_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    47e2:	df 93       	push	r29
    47e4:	cf 93       	push	r28
    47e6:	00 d0       	rcall	.+0      	; 0x47e8 <DIO_void_toggle_pin+0x6>
    47e8:	cd b7       	in	r28, 0x3d	; 61
    47ea:	de b7       	in	r29, 0x3e	; 62
    47ec:	89 83       	std	Y+1, r24	; 0x01
    47ee:	6a 83       	std	Y+2, r22	; 0x02
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	tgl_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    47f0:	89 81       	ldd	r24, Y+1	; 0x01
    47f2:	88 2f       	mov	r24, r24
    47f4:	90 e0       	ldi	r25, 0x00	; 0
    47f6:	88 0f       	add	r24, r24
    47f8:	99 1f       	adc	r25, r25
    47fa:	fc 01       	movw	r30, r24
    47fc:	e1 57       	subi	r30, 0x71	; 113
    47fe:	ff 4f       	sbci	r31, 0xFF	; 255
    4800:	a0 81       	ld	r26, Z
    4802:	b1 81       	ldd	r27, Z+1	; 0x01
    4804:	89 81       	ldd	r24, Y+1	; 0x01
    4806:	88 2f       	mov	r24, r24
    4808:	90 e0       	ldi	r25, 0x00	; 0
    480a:	88 0f       	add	r24, r24
    480c:	99 1f       	adc	r25, r25
    480e:	fc 01       	movw	r30, r24
    4810:	e1 57       	subi	r30, 0x71	; 113
    4812:	ff 4f       	sbci	r31, 0xFF	; 255
    4814:	01 90       	ld	r0, Z+
    4816:	f0 81       	ld	r31, Z
    4818:	e0 2d       	mov	r30, r0
    481a:	80 81       	ld	r24, Z
    481c:	48 2f       	mov	r20, r24
    481e:	8a 81       	ldd	r24, Y+2	; 0x02
    4820:	28 2f       	mov	r18, r24
    4822:	30 e0       	ldi	r19, 0x00	; 0
    4824:	81 e0       	ldi	r24, 0x01	; 1
    4826:	90 e0       	ldi	r25, 0x00	; 0
    4828:	02 2e       	mov	r0, r18
    482a:	02 c0       	rjmp	.+4      	; 0x4830 <DIO_void_toggle_pin+0x4e>
    482c:	88 0f       	add	r24, r24
    482e:	99 1f       	adc	r25, r25
    4830:	0a 94       	dec	r0
    4832:	e2 f7       	brpl	.-8      	; 0x482c <DIO_void_toggle_pin+0x4a>
    4834:	84 27       	eor	r24, r20
    4836:	8c 93       	st	X, r24
}
    4838:	0f 90       	pop	r0
    483a:	0f 90       	pop	r0
    483c:	cf 91       	pop	r28
    483e:	df 91       	pop	r29
    4840:	08 95       	ret

00004842 <DIO_void_assign_pin>:


void DIO_void_assign_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num, u8 pin_val)
{
    4842:	df 93       	push	r29
    4844:	cf 93       	push	r28
    4846:	00 d0       	rcall	.+0      	; 0x4848 <DIO_void_assign_pin+0x6>
    4848:	0f 92       	push	r0
    484a:	cd b7       	in	r28, 0x3d	; 61
    484c:	de b7       	in	r29, 0x3e	; 62
    484e:	89 83       	std	Y+1, r24	; 0x01
    4850:	6a 83       	std	Y+2, r22	; 0x02
    4852:	4b 83       	std	Y+3, r20	; 0x03
	 *		copy_u8_pin_num>> pin number that needed to be set 0-7
	 *	
	 *	Function does not return any output, yet it affects 
	 *	given pin of the PORT output Register PORTx				   
	 */
	agn_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num, pin_val);
    4854:	8b 81       	ldd	r24, Y+3	; 0x03
    4856:	88 23       	and	r24, r24
    4858:	29 f1       	breq	.+74     	; 0x48a4 <DIO_void_assign_pin+0x62>
    485a:	89 81       	ldd	r24, Y+1	; 0x01
    485c:	88 2f       	mov	r24, r24
    485e:	90 e0       	ldi	r25, 0x00	; 0
    4860:	88 0f       	add	r24, r24
    4862:	99 1f       	adc	r25, r25
    4864:	fc 01       	movw	r30, r24
    4866:	e1 57       	subi	r30, 0x71	; 113
    4868:	ff 4f       	sbci	r31, 0xFF	; 255
    486a:	a0 81       	ld	r26, Z
    486c:	b1 81       	ldd	r27, Z+1	; 0x01
    486e:	89 81       	ldd	r24, Y+1	; 0x01
    4870:	88 2f       	mov	r24, r24
    4872:	90 e0       	ldi	r25, 0x00	; 0
    4874:	88 0f       	add	r24, r24
    4876:	99 1f       	adc	r25, r25
    4878:	fc 01       	movw	r30, r24
    487a:	e1 57       	subi	r30, 0x71	; 113
    487c:	ff 4f       	sbci	r31, 0xFF	; 255
    487e:	01 90       	ld	r0, Z+
    4880:	f0 81       	ld	r31, Z
    4882:	e0 2d       	mov	r30, r0
    4884:	80 81       	ld	r24, Z
    4886:	48 2f       	mov	r20, r24
    4888:	8a 81       	ldd	r24, Y+2	; 0x02
    488a:	28 2f       	mov	r18, r24
    488c:	30 e0       	ldi	r19, 0x00	; 0
    488e:	81 e0       	ldi	r24, 0x01	; 1
    4890:	90 e0       	ldi	r25, 0x00	; 0
    4892:	02 2e       	mov	r0, r18
    4894:	02 c0       	rjmp	.+4      	; 0x489a <DIO_void_assign_pin+0x58>
    4896:	88 0f       	add	r24, r24
    4898:	99 1f       	adc	r25, r25
    489a:	0a 94       	dec	r0
    489c:	e2 f7       	brpl	.-8      	; 0x4896 <DIO_void_assign_pin+0x54>
    489e:	84 2b       	or	r24, r20
    48a0:	8c 93       	st	X, r24
    48a2:	25 c0       	rjmp	.+74     	; 0x48ee <DIO_void_assign_pin+0xac>
    48a4:	89 81       	ldd	r24, Y+1	; 0x01
    48a6:	88 2f       	mov	r24, r24
    48a8:	90 e0       	ldi	r25, 0x00	; 0
    48aa:	88 0f       	add	r24, r24
    48ac:	99 1f       	adc	r25, r25
    48ae:	fc 01       	movw	r30, r24
    48b0:	e1 57       	subi	r30, 0x71	; 113
    48b2:	ff 4f       	sbci	r31, 0xFF	; 255
    48b4:	a0 81       	ld	r26, Z
    48b6:	b1 81       	ldd	r27, Z+1	; 0x01
    48b8:	89 81       	ldd	r24, Y+1	; 0x01
    48ba:	88 2f       	mov	r24, r24
    48bc:	90 e0       	ldi	r25, 0x00	; 0
    48be:	88 0f       	add	r24, r24
    48c0:	99 1f       	adc	r25, r25
    48c2:	fc 01       	movw	r30, r24
    48c4:	e1 57       	subi	r30, 0x71	; 113
    48c6:	ff 4f       	sbci	r31, 0xFF	; 255
    48c8:	01 90       	ld	r0, Z+
    48ca:	f0 81       	ld	r31, Z
    48cc:	e0 2d       	mov	r30, r0
    48ce:	80 81       	ld	r24, Z
    48d0:	48 2f       	mov	r20, r24
    48d2:	8a 81       	ldd	r24, Y+2	; 0x02
    48d4:	28 2f       	mov	r18, r24
    48d6:	30 e0       	ldi	r19, 0x00	; 0
    48d8:	81 e0       	ldi	r24, 0x01	; 1
    48da:	90 e0       	ldi	r25, 0x00	; 0
    48dc:	02 2e       	mov	r0, r18
    48de:	02 c0       	rjmp	.+4      	; 0x48e4 <DIO_void_assign_pin+0xa2>
    48e0:	88 0f       	add	r24, r24
    48e2:	99 1f       	adc	r25, r25
    48e4:	0a 94       	dec	r0
    48e6:	e2 f7       	brpl	.-8      	; 0x48e0 <DIO_void_assign_pin+0x9e>
    48e8:	80 95       	com	r24
    48ea:	84 23       	and	r24, r20
    48ec:	8c 93       	st	X, r24
}
    48ee:	0f 90       	pop	r0
    48f0:	0f 90       	pop	r0
    48f2:	0f 90       	pop	r0
    48f4:	cf 91       	pop	r28
    48f6:	df 91       	pop	r29
    48f8:	08 95       	ret

000048fa <DIO_u8_get_PinOut>:


u8 DIO_u8_get_PinOut(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    48fa:	df 93       	push	r29
    48fc:	cf 93       	push	r28
    48fe:	00 d0       	rcall	.+0      	; 0x4900 <DIO_u8_get_PinOut+0x6>
    4900:	cd b7       	in	r28, 0x3d	; 61
    4902:	de b7       	in	r29, 0x3e	; 62
    4904:	89 83       	std	Y+1, r24	; 0x01
    4906:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 *
	 */
	return get_bit(*(DIO_PORTx_REF[copy_u8_port_id]), copy_u8_pin_num);
    4908:	89 81       	ldd	r24, Y+1	; 0x01
    490a:	88 2f       	mov	r24, r24
    490c:	90 e0       	ldi	r25, 0x00	; 0
    490e:	88 0f       	add	r24, r24
    4910:	99 1f       	adc	r25, r25
    4912:	fc 01       	movw	r30, r24
    4914:	e1 57       	subi	r30, 0x71	; 113
    4916:	ff 4f       	sbci	r31, 0xFF	; 255
    4918:	01 90       	ld	r0, Z+
    491a:	f0 81       	ld	r31, Z
    491c:	e0 2d       	mov	r30, r0
    491e:	80 81       	ld	r24, Z
    4920:	28 2f       	mov	r18, r24
    4922:	30 e0       	ldi	r19, 0x00	; 0
    4924:	8a 81       	ldd	r24, Y+2	; 0x02
    4926:	88 2f       	mov	r24, r24
    4928:	90 e0       	ldi	r25, 0x00	; 0
    492a:	a9 01       	movw	r20, r18
    492c:	02 c0       	rjmp	.+4      	; 0x4932 <DIO_u8_get_PinOut+0x38>
    492e:	55 95       	asr	r21
    4930:	47 95       	ror	r20
    4932:	8a 95       	dec	r24
    4934:	e2 f7       	brpl	.-8      	; 0x492e <DIO_u8_get_PinOut+0x34>
    4936:	ca 01       	movw	r24, r20
    4938:	81 70       	andi	r24, 0x01	; 1
}
    493a:	0f 90       	pop	r0
    493c:	0f 90       	pop	r0
    493e:	cf 91       	pop	r28
    4940:	df 91       	pop	r29
    4942:	08 95       	ret

00004944 <DIO_u8_get_port>:


/* Get value from input PORTx functions */
u8 DIO_u8_get_port(u8 copy_u8_port_id)
{
    4944:	df 93       	push	r29
    4946:	cf 93       	push	r28
    4948:	0f 92       	push	r0
    494a:	cd b7       	in	r28, 0x3d	; 61
    494c:	de b7       	in	r29, 0x3e	; 62
    494e:	89 83       	std	Y+1, r24	; 0x01
	 *	
	 *	Function does not affect any regester it only gets
	 *	from the value in the input regester PINx of the 
	 *	given port                                                 
	 */
	return *(DIO_PINx_REF[copy_u8_port_id]);
    4950:	89 81       	ldd	r24, Y+1	; 0x01
    4952:	88 2f       	mov	r24, r24
    4954:	90 e0       	ldi	r25, 0x00	; 0
    4956:	88 0f       	add	r24, r24
    4958:	99 1f       	adc	r25, r25
    495a:	fc 01       	movw	r30, r24
    495c:	e1 58       	subi	r30, 0x81	; 129
    495e:	ff 4f       	sbci	r31, 0xFF	; 255
    4960:	01 90       	ld	r0, Z+
    4962:	f0 81       	ld	r31, Z
    4964:	e0 2d       	mov	r30, r0
    4966:	80 81       	ld	r24, Z
}
    4968:	0f 90       	pop	r0
    496a:	cf 91       	pop	r28
    496c:	df 91       	pop	r29
    496e:	08 95       	ret

00004970 <DIO_u8_get_pin>:


/* Get value from input PINx functions */
u8 DIO_u8_get_pin(u8 copy_u8_port_id, u8 copy_u8_pin_num)
{
    4970:	df 93       	push	r29
    4972:	cf 93       	push	r28
    4974:	00 d0       	rcall	.+0      	; 0x4976 <DIO_u8_get_pin+0x6>
    4976:	cd b7       	in	r28, 0x3d	; 61
    4978:	de b7       	in	r29, 0x3e	; 62
    497a:	89 83       	std	Y+1, r24	; 0x01
    497c:	6a 83       	std	Y+2, r22	; 0x02
	 *	
	 *	Function does not affect any regester it only gets the pin
	 *	value from the value in the input regester PINx of the 
	 *	given port                                                 
	 */
	return get_bit(*(DIO_PINx_REF[copy_u8_port_id]), copy_u8_pin_num);
    497e:	89 81       	ldd	r24, Y+1	; 0x01
    4980:	88 2f       	mov	r24, r24
    4982:	90 e0       	ldi	r25, 0x00	; 0
    4984:	88 0f       	add	r24, r24
    4986:	99 1f       	adc	r25, r25
    4988:	fc 01       	movw	r30, r24
    498a:	e1 58       	subi	r30, 0x81	; 129
    498c:	ff 4f       	sbci	r31, 0xFF	; 255
    498e:	01 90       	ld	r0, Z+
    4990:	f0 81       	ld	r31, Z
    4992:	e0 2d       	mov	r30, r0
    4994:	80 81       	ld	r24, Z
    4996:	28 2f       	mov	r18, r24
    4998:	30 e0       	ldi	r19, 0x00	; 0
    499a:	8a 81       	ldd	r24, Y+2	; 0x02
    499c:	88 2f       	mov	r24, r24
    499e:	90 e0       	ldi	r25, 0x00	; 0
    49a0:	a9 01       	movw	r20, r18
    49a2:	02 c0       	rjmp	.+4      	; 0x49a8 <DIO_u8_get_pin+0x38>
    49a4:	55 95       	asr	r21
    49a6:	47 95       	ror	r20
    49a8:	8a 95       	dec	r24
    49aa:	e2 f7       	brpl	.-8      	; 0x49a4 <DIO_u8_get_pin+0x34>
    49ac:	ca 01       	movw	r24, r20
    49ae:	81 70       	andi	r24, 0x01	; 1
}
    49b0:	0f 90       	pop	r0
    49b2:	0f 90       	pop	r0
    49b4:	cf 91       	pop	r28
    49b6:	df 91       	pop	r29
    49b8:	08 95       	ret

000049ba <__prologue_saves__>:
    49ba:	2f 92       	push	r2
    49bc:	3f 92       	push	r3
    49be:	4f 92       	push	r4
    49c0:	5f 92       	push	r5
    49c2:	6f 92       	push	r6
    49c4:	7f 92       	push	r7
    49c6:	8f 92       	push	r8
    49c8:	9f 92       	push	r9
    49ca:	af 92       	push	r10
    49cc:	bf 92       	push	r11
    49ce:	cf 92       	push	r12
    49d0:	df 92       	push	r13
    49d2:	ef 92       	push	r14
    49d4:	ff 92       	push	r15
    49d6:	0f 93       	push	r16
    49d8:	1f 93       	push	r17
    49da:	cf 93       	push	r28
    49dc:	df 93       	push	r29
    49de:	cd b7       	in	r28, 0x3d	; 61
    49e0:	de b7       	in	r29, 0x3e	; 62
    49e2:	ca 1b       	sub	r28, r26
    49e4:	db 0b       	sbc	r29, r27
    49e6:	0f b6       	in	r0, 0x3f	; 63
    49e8:	f8 94       	cli
    49ea:	de bf       	out	0x3e, r29	; 62
    49ec:	0f be       	out	0x3f, r0	; 63
    49ee:	cd bf       	out	0x3d, r28	; 61
    49f0:	09 94       	ijmp

000049f2 <__epilogue_restores__>:
    49f2:	2a 88       	ldd	r2, Y+18	; 0x12
    49f4:	39 88       	ldd	r3, Y+17	; 0x11
    49f6:	48 88       	ldd	r4, Y+16	; 0x10
    49f8:	5f 84       	ldd	r5, Y+15	; 0x0f
    49fa:	6e 84       	ldd	r6, Y+14	; 0x0e
    49fc:	7d 84       	ldd	r7, Y+13	; 0x0d
    49fe:	8c 84       	ldd	r8, Y+12	; 0x0c
    4a00:	9b 84       	ldd	r9, Y+11	; 0x0b
    4a02:	aa 84       	ldd	r10, Y+10	; 0x0a
    4a04:	b9 84       	ldd	r11, Y+9	; 0x09
    4a06:	c8 84       	ldd	r12, Y+8	; 0x08
    4a08:	df 80       	ldd	r13, Y+7	; 0x07
    4a0a:	ee 80       	ldd	r14, Y+6	; 0x06
    4a0c:	fd 80       	ldd	r15, Y+5	; 0x05
    4a0e:	0c 81       	ldd	r16, Y+4	; 0x04
    4a10:	1b 81       	ldd	r17, Y+3	; 0x03
    4a12:	aa 81       	ldd	r26, Y+2	; 0x02
    4a14:	b9 81       	ldd	r27, Y+1	; 0x01
    4a16:	ce 0f       	add	r28, r30
    4a18:	d1 1d       	adc	r29, r1
    4a1a:	0f b6       	in	r0, 0x3f	; 63
    4a1c:	f8 94       	cli
    4a1e:	de bf       	out	0x3e, r29	; 62
    4a20:	0f be       	out	0x3f, r0	; 63
    4a22:	cd bf       	out	0x3d, r28	; 61
    4a24:	ed 01       	movw	r28, r26
    4a26:	08 95       	ret

00004a28 <memcpy>:
    4a28:	fb 01       	movw	r30, r22
    4a2a:	dc 01       	movw	r26, r24
    4a2c:	02 c0       	rjmp	.+4      	; 0x4a32 <memcpy+0xa>
    4a2e:	01 90       	ld	r0, Z+
    4a30:	0d 92       	st	X+, r0
    4a32:	41 50       	subi	r20, 0x01	; 1
    4a34:	50 40       	sbci	r21, 0x00	; 0
    4a36:	d8 f7       	brcc	.-10     	; 0x4a2e <memcpy+0x6>
    4a38:	08 95       	ret

00004a3a <_exit>:
    4a3a:	f8 94       	cli

00004a3c <__stop_program>:
    4a3c:	ff cf       	rjmp	.-2      	; 0x4a3c <__stop_program>
